[
  {
    "objectID": "src/topics/topics.html",
    "href": "src/topics/topics.html",
    "title": "TCP/UDP 통신",
    "section": "",
    "text": "현재의 많은 장비들은 소켓 통신을 사용하여 데이터와 정보를 주고받는다. 예전의 장비들은 RS232 나 RS485 같은 직렬 통신이나 다른 다양한 통신 방법을 사용하는 경우가 많았지만 최근의 장비들은 소켓 통신을 통해 데이터를 전송하는 경우가 많다. 여기서는 소켓 통신에 대해 짧게 알아보고 실제 구현해 보기로 하자.\n\n\n\n소켓은 같은 컴퓨터의 프로세스 사이에서, 혹은 서로 다른 컴퓨터(혹은 장비)의 프로세스 사이에서 통신을 수행할 때의 종단점 (end point)이다. 같은 컴퓨터의 프로세스 사이의 소켓에는 unix domain socket 이 있으며 다른 컴퓨터 프로세스 사이에서의 통신에는 Datagram socket 과 Streaming socket 이 있다. 각각의 네트워크 하드웨어는 사양과 내부 명령어가 다르지만 운영체제 수준에서 이를 추상화하여 서로 통신할 수 있도록 한 것이 소켓이다. 여기서는 서로 다른 컴퓨터의 프로세스간 통신에 대해서만 다루기로 한다.\n\n\n\n\n전화와 같이 믿을 수 있는 양방향 통신을 제공한다. 즉 데이터를 주고받는 소켓의 양쪽이 성립된 상태에서 한쪽(서버)에서 다른 한쪽(클라이언트)으로의 연결을 초기화하고, 연결이 생성된 후에는 어느 쪽에서든 다른 쪽으로 통신할 수 있다. 데이터를 송신하고 나서 이 데이터가 실제로 도착했는지도 즉각 확인할 수 있다. 보통 전송 제어 프로토콜(Transmission Control Protocol, TCP)이라 불리는 표준 통신 프로토콜을 사용하며 이 외에도 SCTP(Stream Control Transmission Protocol) 나 DCCP (Datagram Congestion Control Protocol) 가 사용되지만 여기서는 다루지 않기로 한다. 컴퓨터 네트워크에서 데이터는 보통 패킷이라는 단위로 전송되는데, TCP는 패킷이 오류 없이 순서대로 도착하도록 설계되었다. 웹서버, 메일서버, 각 클라이언트 애플리케이션 모두는 TCP와 스트림 소켓을 사용한다.\n\n\n\n\n데이터그램 소켓의 연결은 단방향이고 신뢰할 수 없다. IP 와 포트번호를 특정하여 보내지만 수신을 확인하지 않는다. 또한 데이터가 순서대로 전송된다고 보장할 수도 없다. 사용자 데이터그램 프로토콜(User Datagram Protocol, UDP)이라는 표준 프로토콜을 사용한다. TCP 에 비해 단순하고 간단하며 부하가 적고 빠른 방법이다. 패킷 손실이 허용되기도 하며 네트워크 게임이나 음악/동영상 스트리밍에서 자주 쓰인다. UDP 를 통해 신뢰성 있는 데이터 통신을 하고 싶다면 직접 패킷을 통해 구현해야 한다.\n\n\n\n\n여기서는 접속을 기다리는 것이 서버(server), 기다리는 서버에 접근하는 것이 클라이언트(client) 라고 한다."
  },
  {
    "objectID": "src/topics/topics.html#소켓-통신",
    "href": "src/topics/topics.html#소켓-통신",
    "title": "TCP/UDP 통신",
    "section": "",
    "text": "현재의 많은 장비들은 소켓 통신을 사용하여 데이터와 정보를 주고받는다. 예전의 장비들은 RS232 나 RS485 같은 직렬 통신이나 다른 다양한 통신 방법을 사용하는 경우가 많았지만 최근의 장비들은 소켓 통신을 통해 데이터를 전송하는 경우가 많다. 여기서는 소켓 통신에 대해 짧게 알아보고 실제 구현해 보기로 하자.\n\n\n\n소켓은 같은 컴퓨터의 프로세스 사이에서, 혹은 서로 다른 컴퓨터(혹은 장비)의 프로세스 사이에서 통신을 수행할 때의 종단점 (end point)이다. 같은 컴퓨터의 프로세스 사이의 소켓에는 unix domain socket 이 있으며 다른 컴퓨터 프로세스 사이에서의 통신에는 Datagram socket 과 Streaming socket 이 있다. 각각의 네트워크 하드웨어는 사양과 내부 명령어가 다르지만 운영체제 수준에서 이를 추상화하여 서로 통신할 수 있도록 한 것이 소켓이다. 여기서는 서로 다른 컴퓨터의 프로세스간 통신에 대해서만 다루기로 한다.\n\n\n\n\n전화와 같이 믿을 수 있는 양방향 통신을 제공한다. 즉 데이터를 주고받는 소켓의 양쪽이 성립된 상태에서 한쪽(서버)에서 다른 한쪽(클라이언트)으로의 연결을 초기화하고, 연결이 생성된 후에는 어느 쪽에서든 다른 쪽으로 통신할 수 있다. 데이터를 송신하고 나서 이 데이터가 실제로 도착했는지도 즉각 확인할 수 있다. 보통 전송 제어 프로토콜(Transmission Control Protocol, TCP)이라 불리는 표준 통신 프로토콜을 사용하며 이 외에도 SCTP(Stream Control Transmission Protocol) 나 DCCP (Datagram Congestion Control Protocol) 가 사용되지만 여기서는 다루지 않기로 한다. 컴퓨터 네트워크에서 데이터는 보통 패킷이라는 단위로 전송되는데, TCP는 패킷이 오류 없이 순서대로 도착하도록 설계되었다. 웹서버, 메일서버, 각 클라이언트 애플리케이션 모두는 TCP와 스트림 소켓을 사용한다.\n\n\n\n\n데이터그램 소켓의 연결은 단방향이고 신뢰할 수 없다. IP 와 포트번호를 특정하여 보내지만 수신을 확인하지 않는다. 또한 데이터가 순서대로 전송된다고 보장할 수도 없다. 사용자 데이터그램 프로토콜(User Datagram Protocol, UDP)이라는 표준 프로토콜을 사용한다. TCP 에 비해 단순하고 간단하며 부하가 적고 빠른 방법이다. 패킷 손실이 허용되기도 하며 네트워크 게임이나 음악/동영상 스트리밍에서 자주 쓰인다. UDP 를 통해 신뢰성 있는 데이터 통신을 하고 싶다면 직접 패킷을 통해 구현해야 한다.\n\n\n\n\n여기서는 접속을 기다리는 것이 서버(server), 기다리는 서버에 접근하는 것이 클라이언트(client) 라고 한다."
  },
  {
    "objectID": "src/topics/topics.html#tcp-와-udp-를-이용한-간단한-에코-서버와-클라이언트의-저차원-구현",
    "href": "src/topics/topics.html#tcp-와-udp-를-이용한-간단한-에코-서버와-클라이언트의-저차원-구현",
    "title": "TCP/UDP 통신",
    "section": "2 TCP 와 UDP 를 이용한 간단한 에코 서버와 클라이언트의 저차원 구현",
    "text": "2 TCP 와 UDP 를 이용한 간단한 에코 서버와 클라이언트의 저차원 구현\n여기서는 Python 으로 간단한 서버와 클라이언트를 구현한다. 가장 기본적인 저차원 구현은 C 언어를 이용한 구현이지만 여기서는 이 C 구현과 가장 비슷하며 저차원 구현을 체험해 볼 수 있는 Python 구현을 통해 TCP 와 UDP 통신을 알아보기로 하자.\n\nTCP 통신\n서버가 대기하고 클라이언트와의 접속이 성립하면 클라이언트는 사용자로부터의 입력을 서버에게 보낸다. 서버는 클라이언트로부터 받은 메시지를 출력하고 그 메시지 끝에 # 을 붙여 클라이언트에게 보낸다. 클라이언트는 # 이 붙은 메시지를 받고 출력한다. 사용자로부터 -1 을 받으면 서버는 역시 # 이 붙은 메시지 -1# 을 클리이언트로 보내고 종료하며, 클라이언트 역시 종료한다.\nPython 으로 구현하지만 여기서의 방식은 소켓 통신의 기본적인 즉 low-level 방식으로 거의 모든 언어에서 기본적으로 지원한다. 물론 실제로는 이 방식보다는 이 방식을 좀 더 쓰기 편하게 만든 방식을 쓸 수도 있지만 기본 동작을 일단 확인하기 위해 low-level 방식으로 구현해보자.\n소켓 통신을 위해서는 socket 모듈을 임포트 해야 하고 소켓 객체를 구현해야 한다. 서버에는 두개의 소켓이 필요하다. 하나는 접속을 받아들이고 연결을 위한 역할을 수행하는 소켓(이하 연결 소켓)이며 다른 하나는 클라이언트와 데이터를 주고받기 위한 소캣(이하 서버 소켓)이다. 클라이언트는 데이터를 주고받는 소켓(이하 클라이언트 소켓) 하나만 있으면 된다. 연결 소켓, 서버소켓, 클라이언트 소켓은 편의상 지은 이름이며 다른 곳에서는 다른 이름으로 사용될 수 있다.\n\nTCP 서버\n일단 서버쪽에서 연결 소켓을 성립시켜야 한다. 연결 소켓을 위해서는 서버 IP 와 포트 번호가 필요하다. IP 는 \"123.123.123.12\" 형식의 문자열이며 포트 번호는 0 부터 65535 번까지의 정수이다. IP 와 포트번호는 Internet Assigned Numbers Authority (IANA) 에서 관리하는데 포트 번호중의 일부는 특별한 용도로 지정되어 있다. 자세한 것은 List of TCP and UDP port numbers 를 참고하라. 보통 49152 에서 65535 번호는 자유롭게 사용 할 수 있다.\n\n연결 소켓은 IP 와 포트번호, 그리고 프로토콜로 구성된다. 우선\nimport socket\n을 통해 소캣 모듈을 사용할 수 있도록 한다. 이후 아래와 같이 소켓 인스턴스를 만들고 프로토콜과 옵션을 정한다.\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\nsocket.socket 의 첫번째 인자로는 다음이 사용될 수 있다.\n\nsocket.AF_INET 은 IPv4 즉 4 개의 8비트 정수로 지정된 IP 번호를 사용한는 것을 의미한다. 보퉁 많이 사용하는 123.123.123.12 형식이다.\nsocket.AF_INET6 는 IPv6 주소체계를 사용한다는 것을 의미하며 16비트 정수 4개를 사용한다.\nsocket.AF_UNIX 는 네트웍 통신이 아닌 프로세스간의 통신에 대해 사용한다.\n\nsocket.socket 의 두번째 인자로는 다음이 사용될 수 있다.\n\nsocket.SOCK_STREAM 은 TCP 통신 규약을 사용한다는 것을 의미한다.\nsocket.SOCK_DGRAM 은 UDP 통신 규약을 사용한다는 것을 의미한다.\n\n\nsocket.setsockopt 함수는 소켓의 옵션을 지정한다. 첫번째 인자는 프로토콜 레벨이며 두번째 인자는 프로토콜 레벨에서의 옵션 이름, 세번째 인자부터는 앞의 두 인자에 따른 설정값 등이 온다. 자세한 내용은 setsockopt 서브루틴 을 참고하라. 여기서 socket.SO_REUSEADDR 옵션의 옵션값을 1 로 설정하면 클라이언트 소켓을 닫은 후 같은 IP 와 포트번호로 연결할 수 있다.\n\nserver_socket.bind((host, port))\nserver_socket.listen(0)\nclient_soc, addr = server_socket.accept()\nbind((host, port)) 는 연결 소켓에 IP 번호(host) 와 포트(port) 를 지정한다. 이제 listen() 을 통해 클라이언트로부터 접속 요청 대기를 시작한다. listen 함수는 최대 대기 큐의 갯수를 인자로 받을 수 있며, 인자가 없을 경우 자동으로 할당된다.\naccept() 함수는 연결을 시도한 클라이언트와 통신 할 수 있는 소켓(client_soc), 즉 서버 소켓과 연결된 클라이언트의 (IP 주소, 포트) 튜플을 반환한다. 이 서버 소켓을 통해 클라이언트와 통신한다. 이제 서버의 코드를 보자.\n# TCP 서버 프로그램 \nimport socket, time\n\nhost, port = 'localhost', 43333\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\nserver_socket.bind((host, port))\nserver_socket.listen()\n\nprint('TCP 서버 시작')\n\nclient_soc, addr = server_socket.accept()\n\nprint('연결된 client (IP, port):', addr)\n\n# 접속 유지 변수\nconnection_retained = True\n\nwhile connection_retained :\n    try:\n        data = client_soc.recv(1024)\n    except ConnectionResetError:\n        print('ConnectionResetError')\n        connection_retained = False\n    finally:    \n        msg = data.decode() # 읽은 데이터 디코딩\n        print('받은 메시지 :', msg)\n        client_soc.sendall((msg+\"#\").encode(encoding='utf-8')) # 에코메세지 클라이언트로 보냄\n\n        # 클라이언트로부터 받은 메시지가 \"-1\" 이면 접속을 종료시킨다.\n        if msg == \"-1\":\n            connection_retained = False\n            print(\"to be closed\")        \n            client_soc.close()\n        \n    time.sleep(0.2)\n    \nserver_socket.close() # 사용했던 서버 소켓을 닫아줌 \n앞서 말했듯이 클라이언트로부터 -1 메시지를 받기 전까지는 계속 클라이언트와 통신해야 한다. 이를 위해 일단 connection_retianed = True 로 두고 이 변수값이 True 인 상황에서는 계속 주고 받도록 한다. 그러나 클라이언트로부터 -1 을 받으면 connection_refused = False 가 되며 while 루프를 벗어나고 소켓이 종료되고 (server_socket.close()) 프로그램도 종료한다.\n\n\n\nTCP 클라이언트\n클라이언트는 서버보다 간단한다.\nimport socket\nserver_ip, server_port = 'localhost', 43333\nsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n서버에 접속하기 위해서는 서버의 IP 와 포트 번호를 알야야 한다(server_ip, server_port). TCP 통신이므로 소켓은 server 의 연결소켓과 같이 설정한다. 이제 연결을 시도한다\nsocket.connect((server_ip, server_port))\n서버와 마찬가지로 연결 유지를 확인하기 위한 변수 connetion_retained 가 존재한다. 코드는 아래와 같다.\n# TCP 클라이언트 프로그램\nimport socket, time\n\nserver_ip, server_port = 'localhost', 43333\nsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsocket.connect((server_ip, server_port))\nsocket.settimeout(0.1)\n\n# 연결 유지 변수\nconnection_retained = True\n\nwhile connection_retained :\n    msg = input('msg:') # 서버로 보낼 msg 입력\n    \n    if msg == \"-1\":\n        connection_retained = False\n    socket.sendall(msg.encode(encoding='utf-8'))\n\n    # 서버가 에코로 되돌려 보낸 메시지를 클라이언트가 받음\n    try:\n        data = socket.recv(1024)\n    except TimeoutError:\n        print('TimeoutError')\n    finally:\n        msg = data.decode() # 읽은 데이터 디코딩\n        print('서버로부터 받은 메시지 :', msg)\nsocket.close()\nsocket.recv(1024) 는 서버로부터 최대 1024 바이트를 는다는 의미이다. 그러나 이 함수 실행 후 지정된 시간동안 응답이 없을 경우 TimeoutError 가 발생하며 소캣이 종료된다. 응답대기시간은 socket.settimeout() 함수를 통해 지정하며 인자로 초 단위의 시간을 입력한다. 인자가 없으면 무한정 기다린다.\n여기서는 응답 대기 시간이 길더라도 문제가 없지만 예를 들어 여러 서버로부터 데이터를 받는 경우를 생각해보자. 여기서 응답을 대기한다면 다른 작업을 수행 할 수가 없으며, 이를 위해 응답 대기시간을 짧게 잡고 다른 작업을 수행한 후 다시 메시지를 기다리는 것이 좋다.\n\n\n\n\nUDP 통신\nUDP 통신과 TCP 통신의 차이는 다음과 같다.\n\n소켓 타입이 socket.SOCK_STREAM 이 아닌 socket.SOCK_DGRAM 이다.\n연결 소켓이 없으며 서버소켓이 직접 bind 된다.\nTCP 에서는 recv, send 를 통해 데이터를 주고받지만 UDP 에서는 recvfrom, sendto 함수를 사용한다. 앞서 사용한 sendall 함수는 기본 함수인 send 를 python socket 모듈에서 확장한 것이다.\nrecvfrom 함수를 통해 데이터와 데이터를 보낸 주소를 얻으며, 이 주소가 원하는 주소가 않을 경우 무시한다.\nsendto 함수의 인자로는 데이터와 데이터를 받을 IP, 포트번호의 튜플을 전달한다.\n\n\n소스코드를 보라.\n\n\nUDP 서버\n# UDP 서버 프로그램\nimport socket, time\n\nhost, port = 'localhost', 43333\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nserver_socket.bind((host, port))\n# server_socket.listen()\n\nprint('UDP 서버 시작')\n\n#client_soc, addr = server_socket.accept()\naddr = (None, None)\n\nprint('연결된 client (IP, port):', addr)\n\n# 접속 유지 변수\nconnection_retained = True\n\nwhile connection_retained :\n    try:\n        data, addr = server_socket.recvfrom(1024)\n    except ConnectionResetError:\n        print('ConnectionResetError')\n        connection_retained = False\n    finally:    \n        msg = data.decode() # 읽은 데이터 디코딩\n        print(addr, '받은 메시지 :', msg)\n        server_socket.sendto((msg+\"#\").encode(encoding='utf-8'), addr) # 에코메세지 클라이언트로 보냄\n\n        # 클라이언트로부터 받은 메시지가 \"-1\" 이면 접속을 종료시킨다.\n        if msg == \"-1\":\n            connection_retained = False\n            print(\"to be closed\")        \n            # client_soc.close()\n        \n    time.sleep(0.2)\n    \nserver_socket.close() # 사용했던 서버 소켓을 닫아줌 \n\n\n\nUDP 클라이언트\n# UDP 클라이언트 프로그램\nimport socket, time\n\nserver_addr = ('localhost', 43333)\nsocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n# socket.connect((server_ip, server_port))\nsocket.settimeout(0.1)\n\n# 연결 유지 변수\nconnection_retained = True\n\nwhile connection_retained :\n    msg = input('msg:') # 서버로 보낼 msg 입력\n    \n    if msg == \"-1\":\n        connection_retained = False\n    socket.sendto(msg.encode(encoding='utf-8'),server_addr)\n\n    # 서버가 에코로 되돌려 보낸 메시지를 클라이언트가 받음\n    try:\n        data, addr = socket.recvfrom(1024)\n    except TimeoutError:\n        print('TimeoutError')\n    finally:\n        msg = data.decode() # 읽은 데이터 디코딩\n        print('서버로부터 받은 메시지 :', msg)\nsocket.close()"
  },
  {
    "objectID": "src/tools/tikz/tikz_test.html",
    "href": "src/tools/tikz/tikz_test.html",
    "title": "tikz test",
    "section": "",
    "text": "코드\n```{r, engine = 'tikz'}\n#| label: fig-wavelet_resolution_2\n#| code-fold: true\n#| output: asis\n#| fig-width: 10\n#| fig-align: center\n#| fig-cap: \"DWT resolution\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}[samples = 200, scale=1.2]\n\n\\draw[-{stealth}] (0, 0) -- (8.5,0) node[right] {$t$};\n\\draw[-{stealth}] (0,0) -- (0,4) node[above] {$\\omega$};\n\n\\draw [thick] (0, 0.5) -- (8, 0.5);\n\\draw [thick] (0, 1.5) -- (8, 1.5);\n\\draw [thick] (0, 3.5) -- (8, 3.5);\n\n\n\\filldraw[black] (0, 0) circle (1pt) node [below, scale=0.7] {$n=0$};\n\\filldraw[black] (4, 0) circle (1pt) node [below, scale=0.7] {$n=1$};\n\\filldraw[black] (8, 0) circle (1pt) node [below, scale=0.7] {$n=2$};\n\\filldraw[black] (0, 0) circle (1pt) node [left, scale=0.7] {$m=0$};\n\\filldraw[black] (0, 0.5) circle (1pt) node [left, scale=0.7] {$m=-1$};\n\\filldraw[black] (0, 1.5) circle (1pt) node [left, scale=0.7] {$m=-2$};\n\\filldraw[black] (0, 3.5) circle (1pt) node [left, scale=0.7] {$m=-3$};\n\n\\foreach \\x in {0,...,4}\n{\n\\draw [thick] (2*\\x, 0) -- (2*\\x, 3.5);\n\n}\n\n\n\\foreach \\x in {0,...,8}\n{\n\\draw [thick] (\\x, 0.5) -- (\\x, 3.5);\n}\n\n\\foreach \\x in {0,...,15}\n{\n\\draw [thick] (\\x/2, 1.5) -- (\\x/2, 3.5);\n}\n\n\\draw[{stealth}-{stealth}] (7.5, 3.7) -- (8.0,3.7);\n\\node[above] at (7.75, 3.7) {$\\sigma_t$};\n\n\\draw[{stealth}-{stealth}] (8.2, 1.5) -- (8.2,3.5);\n\\node[right] at (8.2, 2.5) {$\\sigma_\\omega$};\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 1: DWT resolution",
    "crumbs": [
      "Tools",
      "tikz test"
    ]
  },
  {
    "objectID": "src/tools/tikz/tikz_image.html",
    "href": "src/tools/tikz/tikz_image.html",
    "title": "Tikz code for image in Quarto",
    "section": "",
    "text": "코드\n\\begin{tikzpicture}\n    \\draw [black, very thick, -&gt;](0, 0) -- (2, 2)  node[right] {$\\boldsymbol{v}$};\n    \\draw [red, very thick, -&gt;] (0, 0) -- (-2.646, 1 ) node[left] {$\\boldsymbol{H_v x}$};\n    \\draw [blue, very thick, -&gt;] (0, 0) -- (-0.646, 3 ) node[left] {$\\boldsymbol{x}$};\n    \\draw [green, dashed, thick] (1, -1) -- (-2, 2 ) node[left, black] {Plane normal to $\\boldsymbol{v}$};\n\\end{tikzpicture}\n\n\n\n\n\n\n\n그림 1: Householder 반사\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-tikz_first_exam\n#| code-fold: true\n#| output: asis\n#| fig-align: center\n#| fig-cap: \"tikz in Quarto 예시\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{decorations.pathreplacing}\n\n\\begin{tikzpicture}\n\\draw[step=1.0,black,thick] (-3,-3) grid (3,3);\n\\node at (-2.5, 2.5) {$x_{1}$};\n\\node at (-2.5, 1.5) {$x_{2}$};\n\\node at (-2.5, 0.5) {$x_{3}$};\n\\node at (-2.5, -0.5) {$\\vdots$};\n\\node at (-1.5, 2.5) {$\\cdots$};\n\\node at (2.5, -2.5) {$x_N$};\n\\node at (5.5, 2.5) {Detector};\n\\draw[red, thick, -{stealth}] (-4, -2) -- (5.5, 1.5);\n\n\\begin{scope}[shift={(5.7,1.55)},rotate=20.4]\n\\draw[blue, very thick] (-0.5,-0.5) -- (0.5,-0.5) -- (0.5,0.5) -- (-0.5,0.5); \n\\end{scope}\n\n\\begin{scope}[shift={(0.3, 0.2)},rotate=20.4]\n\\draw [decorate,decoration={brace,amplitude=5pt,mirror,raise=4ex}]\n  (-0.5,0) -- (0.5,0) node[midway,yshift=-3em, red]{$w_{ij}$};\n\\end{scope}\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 2: tikz in Quarto 예시",
    "crumbs": [
      "Tools",
      "Tikz code for image in Quarto"
    ]
  },
  {
    "objectID": "src/tools/tikz/tikz.html",
    "href": "src/tools/tikz/tikz.html",
    "title": "tikz in Quarto",
    "section": "",
    "text": "코드\n```{r, engine = 'tikz'}\n#| label: fig-tikz_first_exam\n#| code-fold: true\n#| output: asis\n#| fig-align: center\n#| fig-cap: \"tikz in Quarto 예시\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows.meta}\n\\usetikzlibrary{decorations.pathreplacing}\n\n\\begin{tikzpicture}\n\\draw (0,0)node(a){} -- (10,0) node (b) {} ;\n\\foreach \\x in  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10} % edit here for the vertical lines\n\\draw[shift={(\\x,0)},color=black] (0pt,3pt) -- (0pt,-3pt);\n\\foreach \\x in {0, 0.2, 0.4, 0.6, 0.8, 1} % edit here for the numbers\n\\draw[shift={(\\x*10,0)},color=black] (0pt,0pt) -- (0pt,-3pt) node[below]\n{$\\x$};\n\\node at (8, 0.5) (eq1) {$\\textcolor{red}{\\boldsymbol{SQ}}$};\n\\node at (4, 0.5) (eq2) {$\\textcolor{purple}{\\boldsymbol{G_i(0)}}$}; \n\\node at (7, 0.5) (eq2) {$\\textcolor{purple}{\\boldsymbol{G_i(1)}}$}; \n\\node at (3, 0.5) (eq3) {$\\textcolor{blue}{\\boldsymbol{P}}$};\n\\node at (0, 0.5) (eq4) {$\\textcolor{black}{\\boldsymbol{x_i}}$};\n\\draw[decorate, decoration={brace, amplitude=6pt, mirror},] ([yshift=0.5cm]4,0.5)-- node[above=0.25cm]\n{\\shortstack{Text}}([yshift=0.5cm]3,0.5);\n\\draw[decorate, decoration={brace, amplitude=6pt},] ([yshift=-1cm]7,0)-- node[below=0.25cm]\n{\\shortstack{Text}}([yshift=-1cm]3,0);\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 1: tikz in Quarto 예시",
    "crumbs": [
      "Tools",
      "tikz in Quarto"
    ]
  },
  {
    "objectID": "src/tools/tikz/tikz.html#기본-예제",
    "href": "src/tools/tikz/tikz.html#기본-예제",
    "title": "tikz in Quarto",
    "section": "1 기본 예제",
    "text": "1 기본 예제\n\n직선\n다음은 교차하는 직선과 교점을 그린 것이다.\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-tikz_2\n#| code-fold: true\n#| output: asis\n#| fig-width: 2\n#| fig-align: center\n#| fig-cap: \"tikz 2\"\n\n\\begin{tikzpicture}[scale=1.0]\n\\draw[gray] (-1,2) -- (2,-4);\n\\draw[red, thick] (-1,-1) -- (2,2);\n\\filldraw[black] (0,0) circle (2pt) node[anchor=west]{Intersection point};\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 2: tikz 2\n\n\n\n\n\n\\draw[gray](-1, 2) -- (2, -4); 는 \\((-1, 2)\\) 에서 \\((2, -4)\\) 까지 회색(gray) 의 직선을 그으라는 명령어이다.\n\\draw[red, thick] (-1,-1) -- (2,2); 는 주어진 좌표간의 빨갛고(red), 두꺼운(thick) 직선을 그으라는 의미이다.\n\\filldraw[black] (0,0) circle (2pt) node[anchor=west]{Intersection point}; 는 \\((0, 0)\\) 에 반지름 2 인 속이 꽉 찬 원을 그리며, \\((0, 0)\\) 을 서쪽으로 두는 문자열 Intersection point 를 출력하라는 의미이다.\n\n\n\n\n그리드와 직선의 두께\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-tikz_2_2\n#| code-fold: true\n#| output: asis\n#| fig-width: 2\n#| fig-align: center\n#| fig-cap: \"그리드와 직선의 두께\"\n\n\\begin{tikzpicture}\n    \\draw[gray, very thick] (0,0) grid (4,3);\n    \\draw[blue, dashed] (0,0) -- (1,2) -- (3,3) -- (4,2);\n    \\draw[red, -&gt;, thick] (2,0) -- (3.5,2.5);\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 3: 그리드와 직선의 두께\n\n\n\n\n\n\\draw[gray, very thick] (0,0) grid (4,3); 는 \\((0, 0)\\) 부터 \\((4, 3)\\) 까지 가로, 세로 1 간격의 그리드를 회색(gray) 의 두꺼운 선(very thick) 으로 그린다.\ndraw[blue, dashed] (0,0) -- (1,2) -- (3,3) -- (4,2); 는 이어지는 파선(dashed) 을 파란 색으로 그린다.\n\\draw[red, -&gt;, thick] (2,0) -- (3.5,2.5); 는 끝점에 화살표가 있는 빨간 선을 두껍게(thick) 그린다.\n\n\n\n\n닫힌 선분\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-tikz_2_3\n#| code-fold: true\n#| output: asis\n#| fig-width: 2\n#| fig-align: center\n#| fig-cap: \"닫힌 선분\"\n\n\\begin{tikzpicture}\n    \\draw[green, thick] (0,0) -- (1,2) -- (3,3) -- (3,-1)--cycle;\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 4: 닫힌 선분\n\n\n\n\n\n\\draw[green, thick] (0,0) -- (1,2) -- (3,3) -- (3,-1)--cycle; 에서 --cycle 은 이 앞의 (3, -1) 을 맨 앞의 (0, 0) 과 연결시키라는 의미이다.\n\n\n\n\n곡선\n다음은 곡선을 그린 것이다.\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-tikz_3\n#| code-fold: true\n#| output: asis\n#| fig-width: 2\n#| fig-align: center\n#| fig-cap: \"tikz 3\"\n\n\\begin{tikzpicture}[scale=1.0]\n\\draw (-2,0) -- (2,0);\n\\filldraw [blue] (0,0) circle (2pt);\n\\draw[cyan] (-2,-2) .. controls (0,0) .. (2,-2);\n\\draw[magenta] (-2,2) .. controls (-1,0) and (1,0) .. (2,2);\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 5: tikz 3\n\n\n\n\n\n\\draw[magenta] (-2,2) .. controls (-1,0) and (1,0) .. (2,2); 는 \\((-2, 2)\\) 와 \\((2, 2)\\) 를 끝점으로 하고 \\((-1, 0)\\) 과 \\((1, 0)\\) 을 제어점으로 하는 사차 베지어 곡선을 magenta 색으로 그린다.\n\\draw[cyan] (-2,-2) .. controls (0,0) .. (2,-2); 는 (\\(-2, 2)\\) 와 \\((2, 2)\\) 를 끝점으로 하고 제어점이 \\((0, 0)\\) 인 사차 베지어 곡선을 cyan 색으로 그린다. 즉 \\draw[magenta] (-2,2) .. controls (0,0) and (0,0) .. (2,2); 과 같다.\n\n\n\n\n함수\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-tikz_4\n#| code-fold: true\n#| output: asis\n#| fig-width: 4\n#| fig-align: center\n#| fig-cap: \"tikz 3\"\n\\begin{tikzpicture}[domain=0:4]\n  \\draw[very thin,color=gray] (-0.1,-1.1) grid (3.9,3.9);\n\n  \\draw[-&gt;] (-0.2,0) -- (4.2,0) node[right] {$x$};\n  \\draw[-&gt;] (0,-1.2) -- (0,4.2) node[above] {$f(x)$};\n\n  \\draw[color=red]    plot (\\x,\\x)             node[right] {$f(x) =x$};\n  % \\x r means to convert '\\x' from degrees to _r_adians:\n  \\draw[color=blue]   plot (\\x,{sin(\\x r)})    node[right] {$f(x) = \\sin x$};\n  \\draw[color=orange] plot (\\x,{0.05*exp(\\x)}) node[right] {$f(x) = \\frac{1}{20} e^x$};\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 6: tikz 3\n\n\n\n\n\n\\begin{tikzpicture}[domain=0:4] 에서 [domain=0:4] 은 함수를 사용할 때 \\([0, 4]\\) 구간을 사용한다는 의미이다.\n\\draw[color=red] plot (\\x,\\x) node[right] {$f(x) =x$}; 팔간색 선으로 \\(y=x\\) 그래프를 그리며 끝점의 오른쪽에 \\(f(x)=x\\) 라는 문자열을 넣으라는 의미.\n\n\n\n\n도형\n\nShade\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-tikz_shade\n#| code-fold: true\n#| output: asis\n#| fig-width: 6\n#| fig-align: center\n#| fig-cap: \"tikz shade\"\n\n\n\\begin{tikzpicture}[scale = 3, rounded corners,ultra thick]\n  \\shade[top color=yellow,bottom color=black] (0,0) rectangle +(2,1);\n  \\shade[left color=yellow,right color=black] (3,0) rectangle +(2,1);\n  \\shadedraw[inner color=yellow,outer color=black,draw=yellow] (6,0) rectangle +(2,1);\n  \\shade[ball color=green] (9,.5) circle (.5cm);\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 7: tikz shade\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-tikz_shade2\n#| code-fold: true\n#| output: asis\n#| fig-width: 3\n#| fig-align: center\n#| fig-cap: \"tikz shade\"\n\n\n\\begin{tikzpicture}[scale=3]\n  \\clip (-0.1,-0.2) rectangle (1.1,0.75);\n  \\draw[step=.5cm,gray,very thin] (-1.4,-1.4) grid (1.4,1.4);\n  \\draw (-1.5,0) -- (1.5,0);\n  \\draw (0,-1.5) -- (0,1.5);\n  \\draw (0,0) circle (1cm);\n  \\filldraw[fill=green!20,draw=green!50!black] (0,0) -- (3mm,0mm) arc\n  (0:30:3mm) -- cycle;\n  \\draw[red,very thick]  (30:1cm) -- +(0,-0.5);\n  \\draw[blue,very thick] (30:1cm) ++(0,-0.5) -- (0,0);\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 8: tikz shade\n\n\n\n\n\n\n\n\n좌표계\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-tikz_co_1\n#| code-fold: true\n#| output: asis\n#| fig-width: 2\n#| fig-align: center\n#| fig-cap: \"좌표계\"\n\\begin{tikzpicture}\n  \\draw [red,-&gt;](0,0) -- (xyz cs:x=2) node[right, black] {$x$};\n  \\draw [green,-&gt;](0,0) -- (xyz cs:y=2) node[right, black] {$y$};\n  \\draw [blue,-&gt;](0,0) -- (xyz cs:z=2) node[right, black] {$z$};\n\n  \\draw [red, thick, -&gt;] (0, 0) -- (xyz cs:x=2, y=2, z=1);\n  \\draw [red, dashed] (xyz cs:x=2, y=2, z=1) -- (xyz cs:x=0, y=2, z=1);\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 9: 좌표계\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-rotation_of_vector\n#| code-fold: true\n#| fig-width: 6\n#| output: asis\n#| fig-align: center\n#| fig-cap: \"두 좌표계\"\n\n\\usetikzlibrary {3d} \n\\usetikzlibrary {arrows}\n\\usetikzlibrary{shapes.geometric}\n\\begin{tikzpicture} %[=&gt;stealth]\n\\tikzset{\n    partial ellipse/.style args={#1:#2:#3}{\n        insert path={+ (#1:#3) arc (#1:#2:#3)}\n    }\n}\n  \\draw [-&gt;] (0,0) -- (xyz cs:x=3);\n  \\draw [-&gt;] (0,0) -- (xyz cs:y=4.5);\n  \\draw [-&gt;] (0,0) -- (xyz cs:z=3); \n  \\draw [dashed] (0.0,3.0) ellipse (1.5 and 0.5);\n  \\draw [thick, -{stealth}] (0, 0) -- (xyz cs:x=0.7,y=2.55);\n  \\node[below, scale=.6] at (0.3, 2.3) {$\\boldsymbol{r}_i (q_j)$};\n  \\draw [thick, -{stealth}] (0, 0) --(xyz cs:x=1.4,y=2.8);\n  \\node[scale=.6] at (1.5, 1.7) {$\\boldsymbol{r}_i (q_j+dq_j)$};\n  \\draw [red, thick, -{stealth}] (0.7, 2.55) -- (1.4, 2.8);\n  \\node[red, scale=.6] at (1.0, 2.5) {$d\\boldsymbol{r}_i$};\n  \\draw [thick, -{stealth}] (0, 3) -- (0, 3.7) node[right, scale=0.6] {$\\;\\boldsymbol{n}$};\n\n  \\draw [teal] (0, 3) -- (0.7, 2.55);\n  \\draw [teal] (0, 3) -- (1.4, 2.8);\n  \\draw[teal, -&gt;] (0, 3.0) [partial ellipse=297:340:0.6 and 0.2] node[above, scale=0.6] {$dq_j$} ;\n  \\draw[purple, -&gt;] (0, 0) [partial ellipse=90:75:1 and 1] node[above left, scale=0.6] {$\\theta$} ;\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 10: 두 좌표계\n\n\n\n\n\n\n\n신호처리 함수\n\n\n코드\n\\usetikzlibrary{arrows}\n\\begin{tikzpicture}[ &gt;=stealth]\n\n\n\\draw[-&gt;] (-2, 0) -- (2, 0) node[below, black] {$x$} ;\n\\draw[ -&gt;] (0, -0.5) -- (0, 1.5);\n\\draw[thick] (-2, 0) -- (0, 0) node[below left, black] {$0$} -- (0, 1) node[left, black] {$1$}-- (2, 1) node[above left, black] {$\\text{step}(x)$};\n\n\\draw[-&gt;] (4, 0) -- (8, 0) node[below, black] {$x$} ;\n\\draw[ -&gt;] (6, -0.5) -- (6, 1.5);\n\\draw[thick] (4, 0) -- (5.5, 0) node[below, black] {$-\\frac{1}{2}$} -- (5.5, 1) -- (6, 1)  -- (6.5, 1)-- (6.5, 0)  node[below, black] {$\\frac{1}{2}$} -- (8, 0) node[above left, black] {$\\text{rect}(x)$};\n\n\\draw[-&gt;] (-2, -3) -- (2, -3) node[below, black] {$x$} ;\n\\draw[ -&gt;] (0, -3.5) -- (0, -1.5);\n\\draw[thick] (-2, -3) -- (-0.5, -3) node[below, black] {$-\\frac{1}{2}$} -- (0, -2) -- (0.5, -3) node[below, black] {$-\\frac{1}{2}$} -- (2, -3) node[above left, black] {$\\text{tri}(x)$};\n\n\n\\draw[-&gt;] (4, -3) node[above right, black] {$\\text{sinc}(x)$} -- (8, -3) node[below, black] {$x$} ;\n\\draw[ -&gt;] (6, -3.5) -- (6, -1.5);\n\\draw[domain=4.0:8.0, smooth, variable=\\x, thick] plot ({\\x}, {0.116*sin(500* (\\x-6))/((\\x-6)) -3 });\n\\draw (6.36, -2.9) -- (6.36, -3.1) node[below, black] {$\\pi$} ; \n\n\n\\draw[-&gt;] (-2, -6) -- (2, -6) node[below, black] {$x$} ;\n\\draw[ -&gt;] (0, -6.5) -- (0, -4);\n\\draw[domain=-1.8:1.8, smooth, variable=\\x, thick] plot ({\\x}, {exp(-(\\x)^2) - 6 });\n\\node[black, right] at (0, -4.7) {$\\text{gauss}(x)$};\n%\\draw (6.36, -2.9) -- (6.36, -3.1) node[below, black] {$\\pi$} ; \n\n\n\\draw[-&gt;] (4, -6)  -- (8, -6) node[below, black] {$x$} ;\n\\draw[ -&gt;] (6, -6.5) -- (6, -4);\n\\draw[very thick] (4.2, -6) -- (6, -6) -- (6, -4) node[left, black] {$\\infty$}-- (6, -6)  -- (7.8, -6) node[above left, black] {$\\delta (x)$};\n\n\\end{tikzpicture}\n\n\n\n\n\n\n\n그림 11: 기본적인 신호들",
    "crumbs": [
      "Tools",
      "tikz in Quarto"
    ]
  },
  {
    "objectID": "src/posts/index.html",
    "href": "src/posts/index.html",
    "title": "The Notebook",
    "section": "",
    "text": "첫번째 글\n\n\n\n\n\n\n\n\n\n\n\nJulia_KAERI\n\n\n\n\n\n\n일치 없음"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Science & Programming",
    "section": "",
    "text": "Julia 프로그래밍 언어 : Julia 언어\nJulia 언어를 이용한 수치해석 : 수치해석과 이미지 처리에 대해 다룹니다."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\ndfkl"
  },
  {
    "objectID": "src/tools/Asymptote/asymptote.html",
    "href": "src/tools/Asymptote/asymptote.html",
    "title": "Asymptote",
    "section": "",
    "text": "1 Examples\nimport graph;\nimport geometry;\nimport math;\nimport settings;\nimport fontsize;\n\n\nsettings.outformat = \"pdf\";\ndefaultpen(fontsize(17pt));\ndefaultpen(1);\n\nsize(400,300,IgnoreAspect);\n\nreal a=1, b=1.5, c=2;\nreal ya=1.0, yb=2.4, yc=3.0;\nreal yb2=2.6, yb3=2.2;\nint t=2;\n\nreal f(real x) {\n    real r1=(x-b)*(x-c)/(a-b)/(a-c)*ya ;\n    r1 += (x-a)*(x-c)/(b-a)/(b-c)*yb;\n    r1 += (x-a)*(x-b)/(c-a)/(c-b)*yc;\n    return r1;\n    }\n\nreal f2(real x) {\n    real r1=(x-b)*(x-c)/(a-b)/(a-c)*ya ;\n    r1 += (x-a)*(x-c)/(b-a)/(b-c)*yb2;\n    r1 += (x-a)*(x-b)/(c-a)/(c-b)*yc;\n    return r1;\n    }\nreal f3(real x) {\n    real r1=(x-b)*(x-c)/(a-b)/(a-c)*ya ;\n    r1 += (x-a)*(x-c)/(b-a)/(b-c)*yb3;\n    r1 += (x-a)*(x-b)/(c-a)/(c-b)*yc;\n    return r1;\n    }\n\npair F(real x) {return (x,f(x));}\n\ndotfactor=7;\n\nxaxis(\"$t$\", xmin=0.5, xmax=2.5, Arrow, ticks=Ticks(DefaultFormat,\n                                        new real[] {1, 2}));\nyaxis(\"$P$\", XEquals(0.7), ymin=-0.2, ymax=4, Arrow);\n\npath g=graph(f,a,c);\npath g2=graph(f2,a,c);\npath g3=graph(f3,a,c);\n\ndraw(g,black);   \ndraw(g2,blue+dashed);  \ndraw(g3,dashed+red);  \n\nint n=2;\n\n\n\ndot(Label(\"$P_1$\",align=W), F(a));\ndot(Label(\"$P_2$\",align=E), F(c));\n\n\n\nEuler Lagrange",
    "crumbs": [
      "Tools",
      "Asymptote"
    ]
  },
  {
    "objectID": "src/tools/tikz/tikz_functions.html",
    "href": "src/tools/tikz/tikz_functions.html",
    "title": "tikz function plots in Quarto",
    "section": "",
    "text": "코드\n```{r, engine = 'tikz'}\n#| label: fig-linear_approximation\n#| code-fold: true\n#| output: asis\n#| fig-width: 3\n#| fig-align: center\n#| fig-cap: \"tikz in Quarto 예시\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{decorations.pathreplacing}\n\n\\begin{tikzpicture}\n\\draw[very thin,color=gray] (-0.1,-0.1) grid (4.2,5.2);\n\n\\draw[-&gt;] (-0.6, 0) -- (4.2,0) node[right] {$x$};\n\\draw[-&gt;] (0,-0.6) -- (0,5.2) node[above] {$y$};\n\n\\foreach \\x in {1,...,8}\n{\n  \\draw[thin] (\\x / 2, 0.05) -- (\\x /2, -0.05);\n  }\n\n\\foreach \\x in {2, 4, 6, 8}\n{\n  \\node[below]  at (\\x /2 , -0.05) {$\\x$};\n  }\n\n\\foreach \\y in {1,...,9}\n{\n  \\draw[thin] (0.05 , \\y / 2) -- (-0.05 , \\y /2);\n  }\n\n\\foreach \\y in {2, 4, 6, 8, 10}\n{\n  \\node[left]  at (-0.05, \\y / 2) {$\\y$};\n  }\n\n\\filldraw[black] (0.5,1.1 /2) circle (2pt);\n\\filldraw[black] (2/2, 1.65 /2) circle (2pt);\n\\filldraw[black] (3/2, 3.43/2) circle (2pt);\n\\filldraw[black] (4/2, 4.02/2) circle (2pt);\n\\filldraw[black] (5/2, 4.58/2) circle (2pt);\n\\filldraw[black] (6/2, 5.78/2) circle (2pt);\n\\filldraw[black] (7/2, 7.32/2) circle (2pt);\n\n\\draw[thick, dashed, red] (0, 0) -- (3.8, 3.8);\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 1: tikz in Quarto 예시\n\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-Chevyshev_polynoimal\n#| code-fold: true\n#| output: asis\n#| fig-width: 4\n#| fig-align: center\n#| fig-cap: \"Chevyshev 다항식\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{decorations.pathreplacing}\n\n\\begin{tikzpicture}[domain=-1:1, samples = 100, scale=3]\n\n\\draw[-{stealth}] (-1.2, 0) -- (1.2,0) node[right] {$x$};\n\\draw[-{stealth}] (0,-1.2) -- (0,1.2) node[above] {$y$};\n\\node[left, scale=0.8] at (0, 1) {$1$};\n\\node[left, scale=0.8] at (0, -1) {$-1$};\n\\node[below, scale=0.8] at (-1, 0) {$-1$};\n\\node[below, scale=0.8] at (1, 0) {$1$};\n\n\\foreach \\x in {-5,...,5}\n{\n  \\draw[thin] (\\x / 5, 0.02) -- (\\x /5, -0.02);\n  }\n\n\\foreach \\y in {-5,...,5}\n{\n  \\draw[thin] (0.02 , \\y / 5) -- (-0.02 , \\y /5);\n  }\n\n\\draw[color=black]   plot (\\x, \\x) ;\n\\node[above, black] at (0.7, 0.73) {$T_1(x)$};\n\\draw[color=blue]   plot (\\x, 2 * \\x * \\x - 1);\n\\node[below right, blue] at (0, -1) {$T_2(x)$};\n\\draw[color=red]   plot (\\x, 4 * \\x * \\x * \\x - 3* \\x);\n\\node[above, red] at (-0.5, 1) {$T_3(x)$};\n\\draw[color=teal]   plot (\\x, 8 * \\x * \\x * \\x * \\x - 8* \\x * \\x + 1);\n\\node[right, teal] at (0.2, 0.8) {$T_4(x)$};\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 2: Chevyshev 다항식\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-Legendre_polynoimal\n#| code-fold: true\n#| output: asis\n#| fig-width: 4\n#| fig-align: center\n#| fig-cap: \"Legendre 다항식\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{decorations.pathreplacing}\n\n\\begin{tikzpicture}[domain=-1:1, samples = 100, scale=3]\n\n\\draw[-{stealth}] (-1.2, 0) -- (1.2,0) node[right] {$x$};\n\\draw[-{stealth}] (0,-1.2) -- (0,1.2) node[above] {$y$};\n\\node[left, scale=0.8] at (0, 1) {$1$};\n\\node[left, scale=0.8] at (0, -1) {$-1$};\n\\node[below, scale=0.8] at (-1, 0) {$-1$};\n\\node[below, scale=0.8] at (1, 0) {$1$};\n\n\\foreach \\x in {-5,...,5}\n{\n  \\draw[thin] (\\x / 5, 0.02) -- (\\x /5, -0.02);\n  }\n\n\\foreach \\y in {-5,...,5}\n{\n  \\draw[thin] (0.02 , \\y / 5) -- (-0.02 , \\y /5);\n  }\n\n\\draw[color=black]   plot (\\x, 1.5 * \\x * \\x - 0.5 ) ;\n\\node[above, black] at (-0.7, 0.73) {$P_2(x)$};\n\\draw[color=blue]   plot (\\x, 2.5 * \\x * \\x * \\x - 1.5 * \\x);\n\\node[above, blue] at (-0.5, 0.4) {$P_3(x)$};\n\\draw[color=red]   plot (\\x, 35/8 * \\x * \\x * \\x *\\x - 30 / 8 * \\x *\\x + 3/8 );\n\\node[red] at (-0.5, -0.5) {$P_4(x)$};\n\\draw[color=teal]   plot (\\x, 63/8 * \\x * \\x * \\x * \\x * \\x - 70/8* \\x * \\x * \\x + 15/8 * \\x);\n\\node[right, teal] at (0.2, 0.5) {$P_5(x)$};\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 3: Legendre 다항식",
    "crumbs": [
      "Tools",
      "tikz function plots in Quarto"
    ]
  },
  {
    "objectID": "src/tools/tikz/tikz_pde.html",
    "href": "src/tools/tikz/tikz_pde.html",
    "title": "tikz in PDE",
    "section": "",
    "text": "그리드와 직선의 두께\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-pde_grid\n#| code-fold: true\n#| output: asis\n#| fig-width: 8\n#| fig-align: center\n#| fig-cap: \"2차원 그리드\"\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}\n\n\n\\draw[-{stealth}] (-1., 0) -- (8,0) node[right] {$x$};\n\\draw[-{stealth}] (0,-1) -- (0,6) node[above] {$y$};\n\n\\foreach \\x in {2,3,4,5,7} {\n  \\draw[] (\\x, 1) -- (\\x, 5); \n  \\draw[] (\\x, 0.1) -- (\\x, -0.1);\n}\n\\foreach \\y in {1,2,3,5} {\n  \\draw[] (2, \\y) -- (7, \\y);\n  \\draw[] (0.1, \\y) -- (-0.1, \\y);\n}\n\n\\node[below, scale=0.8] at (2, -0.1) {$x_0=a$};\n\\node[below, scale=0.8] at (3, -0.1) {$x_1$};\n\\node[below, scale=0.8] at (4, -0.1) {$x_2$};\n\\node[below, scale=0.8] at (5, -0.1) {$x_3$};\n\\node[below, scale=0.8] at (7, -0.1) {$x_N=b$};\n\n\\node[left, scale=0.8] at (-0.1, 1) {$y_0=c$};\n\\node[left, scale=0.8] at (-0.1, 2) {$y_1$};\n\\node[left, scale=0.8] at (-0.1, 3) {$y_2$};\n\\node[left, scale=0.8] at (-0.1, 5) {$y_M=d$};\n\n\\node[] at (6, 1.5) {$\\cdots$};\n\\node[] at (6, 2.5) {$\\cdots$};\n\\node[] at (2.5, 4) {$\\vdots$};\n\\node[] at (3.5, 4) {$\\vdots$};\n\\node[] at (4.5, 4) {$\\vdots$};\n\\node[] at (5.5, 4) {$\\vdots$};\n\\node[] at (6.5, 4) {$\\vdots$};\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 1: 2차원 그리드",
    "crumbs": [
      "Tools",
      "tikz in PDE"
    ]
  },
  {
    "objectID": "src/tools/tikz/tikz_wavelet.html",
    "href": "src/tools/tikz/tikz_wavelet.html",
    "title": "tikz Wavelet",
    "section": "",
    "text": "코드\n```{r, engine = 'tikz'}\n#| label: fig-wavelet_sharp_function_1\n#| code-fold: true\n#| output: asis\n#| fig-width: 10\n#| fig-align: center\n#| fig-cap: \"Legendre 다항식\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}[samples = 100, scale=2]\n\n\\draw[-{stealth}] (-1.5, 0) -- (1.5,0) node[right] {$t$};\n\\draw[-{stealth}] (0,0) -- (0,1.2) node[above] {$f(t)$};\n\n\\draw[color=black, thick, domain=-1:0, variable = \\t]   plot ({\\t}, {(1+\\t)});\n\\draw[color=black, thick, domain=0:1, variable = \\t]   plot ({\\t}, {(1-\\t)});\n\\draw[] (-1, 0.05) -- (-1, -0.05 ) node[below] {$-a$};\n\\draw[] (1, 0.05) -- (1, -0.05 ) node[below] {$a$};\n\n\\begin{scope}[xshift=3.5cm] \n\n\\draw[-{stealth}] (-1.5, 0) -- (1.5,0) node[right] {$\\omega$};\n\\draw[-{stealth}] (0,0) -- (0,1.2) node[above] {$\\hat{f}(\\omega)$};\n\n\\draw[color=black, thick, domain=-6:6, samples=100, variable = \\t]   plot ({\\t/5}, { (2 * sin((\\t * 180 / pi) /2)/((\\t)))^2 });\n\\draw[] (-0.2, 0.05) -- (-0.2, -0.05 ) node[below] {$-\\frac{1}{a}$};\n\\draw[] (0.2, 0.05) -- (0.2, -0.05 ) node[below] {$\\frac{1}{a}$};\n\n\\end{scope}\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 1: Legendre 다항식\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-wavelet_sharp_function_2\n#| code-fold: true\n#| output: asis\n#| fig-width: 10\n#| fig-align: center\n#| fig-cap: \"Legendre 다항식\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}[samples = 100, scale=2.5]\n\n\\draw[-{stealth}] (-1.2, 0) -- (1.22,0) node[right] {$t$};\n\\draw[-{stealth}] (0,0) -- (0,1.2) node[above] {$f(t)$};\n\n\\draw[color=black, thick, domain=-6:0, variable = \\t]   plot ({\\t/5}, {exp(\\t)});\n\\draw[color=black, thick, domain=0:6, variable = \\t]   plot ({\\t/5}, {exp(-\\t)});\n\\draw[] (-1, 0.05) -- (-1, -0.05 ) node[below] {$-5a$};\n\\draw[] (1, 0.05) -- (1, -0.05 ) node[below] {$5a$};\n\\draw[] (-0.05, 1) -- (0.05, 1 ) node[right] {$1$};\n\n\\begin{scope}[xshift=2.8cm] \n\n\\draw[-{stealth}] (-1.2, 0) -- (1.2,0) node[right] {$\\omega$};\n\\draw[-{stealth}] (0,0) -- (0,1.2) node[above] {$\\hat{f}(\\omega)$};\n\n\\draw[color=black, thick, domain=-6:6, samples=100, variable = \\t]   plot ({\\t/5}, {1/(\\t*\\t + 1)});\n\\draw[] (-0.05, 1) -- (0.05, 1 ) node[right] {$2/a$};\n\\draw[] (-0.2, 0.05) -- (-0.2, -0.05 ) node[below] {$-\\frac{1}{a}$};\n\\draw[] (0.2, 0.05) -- (0.2, -0.05 ) node[below] {$\\frac{1}{a}$};\n\n\\end{scope}\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 2: Legendre 다항식\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-wavelet_haar_wavelet\n#| code-fold: true\n#| output: asis\n#| fig-width: 10\n#| fig-align: center\n#| fig-cap: \"Haar wavelet\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}[samples = 100, scale=2.5]\n\n\\draw[-{stealth}] (-0.5, 0) -- (1.7,0) node[right] {$t$};\n\\draw[-{stealth}] (0,-1.2) -- (0,1.2) node[above] {$\\psi_H(t)$};\n\n\\draw[very thick] (-0.5, 0) -- (0, 0) -- (0, 1) -- (0.5, 1) -- (0.5, -1) -- (1, -1)-- (1, 0) -- (1.5, 0);\n\\node[] at (0, 0) [below left] {$0$};\n\\node[] at (0.5, 0) [below left] {$\\frac{1}{2}$};\n\\node[] at (1, 0) [below left] {$1$};\n\\draw[] (0.1, 1) -- (-0.1, 1) node[left] {$1$};\n\\node[] at (0, -1) [left] {$-1$};\n\n\\begin{scope}[xshift=3.3cm] \n\n\\draw[-{stealth}] (-1.2, -1) -- (1.2,-1) node[right] {$\\omega$};\n\\draw[-{stealth}] (0,-1.0) -- (0,1.2) node[above] {$|\\hat{\\psi}_H(\\omega)|$};\n\n\\draw[color=black, very thick, domain=0.01:40, samples=100, variable = \\t]   plot ({\\t/40}, {(2*(sin(\\t*180/pi/4))*(sin(\\t*180/pi/4)) / (\\t/4)-1)});\n\\draw[color=black, very thick, domain=-40:-0.01, samples=100, variable = \\t]   plot ({\\t/40}, {(-2*(sin(\\t*180/pi/4))*(sin(\\t*180/pi/4)) / (\\t/4)-1)});\n\\draw[] (0.0, -0.96) -- (0.0, -1.04 ) node[below] {$0$};\n\\draw[] (0.314, -0.96) -- (0.314, -1.04 ) node[below] {$4\\pi$};\n\\draw[] (0.628, -0.96) -- (0.628, -1.04 ) node[below] {$8\\pi$};\n\\draw[] (0.942, -0.96) -- (0.942, -1.04 ) node[below] {$12\\pi$};\n\n\\end{scope}\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 3: Haar wavelet\n\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-wavelet_convolution_of_haar_1\n#| code-fold: true\n#| output: asis\n#| fig-width: 5\n#| fig-align: center\n#| fig-cap: \"Haar wavelet\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}[samples = 100, scale=3]\n\n\\draw[-{stealth}] (-0.5, 0) -- (2.5,0) node[right] {$t$};\n\\draw[-{stealth}] (0,-0.7) -- (0,0.7) node[above] {$(\\psi_H \\ast \\phi)(t)$};\n\n\\draw[very thick] (-0.5, 0) -- (0, 0) -- (0.5, 0.5) -- (1.5, -0.5) -- (2, 0) -- (2.4, 0);\n\\node[] at (0, 0) [below left] {$0$};\n\\draw [] (0.5, 0.03) -- (0.5, -0.03) node[below] {$\\frac{1}{2}$};\n\\draw [] (1, 0.03) -- (1, -0.03) node[below] {$1$};\n\\draw [] (1.5, 0.03) -- (1.5, -0.03) node[below] {$\\frac{3}{2}$};\n\\draw [] (2, 0.03) -- (2, -0.03) node[below] {$2$};\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 4: Haar wavelet\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-wavelet_daughter_wavelet_1\n#| code-fold: true\n#| output: asis\n#| fig-width: 10\n#| fig-align: center\n#| fig-cap: \"Haar wavelet\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}[samples = 200, scale=3]\n\n\\draw[-{stealth}] (-1, 0) -- (1,0) node[right] {$t$};\n\\draw[-{stealth}] (0,-0.2) -- (0,1.2) node[above] {$\\psi_{a=1, b=0}(t)$};\n\\draw[color=black, very thick, domain=-1:1, samples=100, variable = \\t]   plot ({\\t}, {exp(-(4*\\t)^2) * cos(\\t*180/pi*10)});\n\n\n\\begin{scope}[xshift=2.3cm] \n\n\\draw[-{stealth}] (-1, 0) -- (1,0) node[right] {$t$};\n\\draw[-{stealth}] (0,-0.2) -- (0,1.2) node[above] {$\\psi_{a&gt;1, b&gt;0} (t)$};\n\n\\draw[color=black, very thick, domain=-1:1, samples=200, variable = \\t]   plot ({\\t}, {exp(-(8*(\\t-0.2))^2) * cos(2*(\\t-0.2)*180/pi*10)});\n\n\\end{scope}\n\n\\begin{scope}[xshift=4.6cm] \n\n\\draw[-{stealth}] (-1, 0) -- (1,0) node[right] {$t$};\n\\draw[-{stealth}] (0,-0.2) -- (0,1.2) node[above] {$\\psi_{a&lt;1, b&gt;0}(t)$};\n\n\\draw[color=black, very thick, domain=-1:1, samples=200, variable = \\t]   plot ({\\t}, {exp(-(2*(\\t-0.2))^2) * cos(0.5*(\\t-0.2)*180/pi*10)});\n\n\\end{scope}\n\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 5: Haar wavelet\n\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-wavelet_maxican_wavelet\n#| code-fold: true\n#| output: asis\n#| fig-width: 10\n#| fig-align: center\n#| fig-cap: \"Haar wavelet\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}[samples = 200, scale=3]\n\n\\draw[-{stealth}] (-1.1, 0) -- (1.1,0) node[right] {$t$};\n\\draw[-{stealth}] (0,-0.5) -- (0,1.2) node[above] {$\\psi_{1, 0}(t)$};\n\\draw[color=black, very thick, domain=-6:6, samples=100, variable = \\t]   plot ({\\t/6}, {(1-(\\t)^2)*exp(-\\t*\\t/2)});\n\\draw (-0.289, -0.02)-- (-0.289, 0.02) node[above, scale=0.8] {$-\\sqrt{3}$};\n\\draw (0.289, -0.02)-- (0.289, 0.02) node[above, scale=0.8] {$\\sqrt{3}$};\n\n\\begin{scope}[xshift=2.3cm] \n\n\\draw[-{stealth}] (-1.1, 0) -- (1.1,0) node[right] {$\\omega$};\n\\draw[-{stealth}] (0,-0.5) -- (0,1.2) node[above] {$\\hat{\\psi}_{1, 0} (t)$};\n\n\\draw[color=black, very thick, domain=-7:7, samples=200, variable = \\t]   plot ({\\t/7}, {\\t*\\t*exp(-\\t*\\t/2)});\n\n\\draw (-0.202, 0.02)-- (-0.202, -0.02) node[below, scale=0.8] {$-\\sqrt{2}$};\n\\draw (0.202, 0.02)-- (0.202, -0.02) node[below, scale=0.8] {$\\sqrt{2}$};\n\\end{scope}\n\n\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 6: Haar wavelet\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-wavelet_maxican_wavelet_2\n#| code-fold: true\n#| output: asis\n#| fig-width: 10\n#| fig-align: center\n#| fig-cap: \"Haar wavelet\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}[samples = 200, scale=1.2]\n\n\\draw[-{stealth}] (-6.3, 0) -- (6.3,0) node[right] {$t$};\n\\draw[-{stealth}] (0,-4) -- (0,6) node[above] {$$};\n\\draw[color=black, very thick, domain=-6:6, samples=300, variable = \\t]   plot ({\\t}, {3*(1-(\\t)^2)*exp(-\\t*\\t/2)});\n\\draw[color=red, very thick, domain=-6:6, samples=300, variable = \\t]   plot ({\\t}, { 3*sqrt(2)/sqrt(3) * (1-((\\t+2)/1.5)^2)*exp(-(((\\t+2)/1.5)^2)/2)});\n\n\\draw[color=teal, very thick, domain=-6:6, samples=300, variable = \\t]   plot ({\\t}, { 3*sqrt(4)* (1-((\\t-sqrt(2))*4)^2)*exp(-(((\\t-sqrt(2))*4)^2)/2)});\n\n\\node [left] at (-0.1, 3) {$\\psi_{1, 0}(\\omega)$};\n\\node [left, red] at (-3, 1) {$\\psi_{\\frac{3}{2}, -2}(\\omega)$};\n\\node [right, teal] at (1.5, 4) {$\\psi_{\\frac{1}{4}, -\\sqrt{2}}(\\omega)$};\n\n\\foreach \\x in {1,...,5}\n{\n  \\draw (\\x, 0.1)-- (\\x, -0.1) node[below, scale=0.8] {$\\x$};\n  \\draw (-\\x, 0.1)-- (-\\x, -0.1) node[below, scale=0.8] {$-\\x$};\n}\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 7: Haar wavelet\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-wavelet_resolution_1\n#| code-fold: true\n#| output: asis\n#| fig-width: 10\n#| fig-align: center\n#| fig-cap: \"Haar wavelet\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}[samples = 200, scale=1.2]\n\n\\draw[-{stealth}] (-0.5, 0) -- (8,0) node[right] {$t$};\n\\draw[-{stealth}] (0,-0.5) -- (0,4) node[above] {$\\omega$};\n\n\\foreach \\x in {0,...,2}\n{\n  \\draw (2*\\x +2 , 0.1)-- (2*\\x +2, 0.0) node[below, scale=0.8] {$b_\\x + a_\\x t_m$};\n  \\draw (0.1, \\x +1)-- (0.0, \\x +1) node[left, scale=0.8] {$\\omega_m/a_\\x$};\n  \\draw[dashed] (2*\\x+2, 0.0) -- (2*\\x+2, \\x+1) -- (0, \\x+1);\n}\n\n\\draw [thick, red] (1, 0.7) -- (3, 0.7) -- (3, 1.3) -- (1, 1.3) -- cycle;\n\\node [above, red, scale=0.8] at (2, 1.3) {$2a_0 \\sigma_t$};\n\\node [right, red, scale=0.8] at (3, 1.0) {$\\dfrac{2}{a_0}\\sigma_\\omega$};\n\n\\draw [thick, blue] (3.5, 1.6) -- (4.5, 1.6) -- (4.5, 2.4) -- (3.5, 2.4) -- cycle;\n\\node [above, blue, scale=0.8] at (4, 2.4) {$2a_1 \\sigma_t$};\n\\node [right, blue, scale=0.8] at (4.5, 2.0) {$\\dfrac{2}{a_1}\\sigma_\\omega$};\n\n\\draw [thick, teal] (5.8, 2) -- (5.8, 4) -- (6.2, 4) -- (6.2, 2) -- cycle;\n\\node [above, teal, scale=0.8] at (6, 4) {$2a_2 \\sigma_t$};\n\\node [right, teal, scale=0.8] at (6.2, 3.0) {$\\dfrac{2}{a_2}\\sigma_\\omega$};\n\n\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 8: Haar wavelet",
    "crumbs": [
      "Tools",
      "tikz Wavelet"
    ]
  },
  {
    "objectID": "src/topics/socket.html",
    "href": "src/topics/socket.html",
    "title": "TCP/UDP 통신",
    "section": "",
    "text": "현재의 많은 장비들은 소켓 통신을 사용하여 데이터와 정보를 주고받는다. 예전의 장비들은 RS232 나 RS485 같은 직렬 통신이나 다른 다양한 통신 방법을 사용하는 경우가 많았지만 최근의 장비들은 소켓 통신을 통해 데이터를 전송하는 경우가 많다. 여기서는 소켓 통신에 대해 짧게 알아보고 실제 구현해 보기로 하자.\n\n\n\n소켓은 같은 컴퓨터의 프로세스 사이에서, 혹은 서로 다른 컴퓨터(혹은 장비)의 프로세스 사이에서 통신을 수행할 때의 종단점 (end point)이다. 같은 컴퓨터의 프로세스 사이의 소켓에는 unix domain socket 이 있으며 다른 컴퓨터 프로세스 사이에서의 통신에는 Datagram socket 과 Streaming socket 이 있다. 각각의 네트워크 하드웨어는 사양과 내부 명령어가 다르지만 운영체제 수준에서 이를 추상화하여 서로 통신할 수 있도록 한 것이 소켓이다. 여기서는 서로 다른 컴퓨터의 프로세스간 통신에 대해서만 다루기로 한다.\n\n\n\n\n전화와 같이 믿을 수 있는 양방향 통신을 제공한다. 즉 데이터를 주고받는 소켓의 양쪽이 성립된 상태에서 한쪽(서버)에서 다른 한쪽(클라이언트)으로의 연결을 초기화하고, 연결이 생성된 후에는 어느 쪽에서든 다른 쪽으로 통신할 수 있다. 데이터를 송신하고 나서 이 데이터가 실제로 도착했는지도 즉각 확인할 수 있다. 보통 전송 제어 프로토콜(Transmission Control Protocol, TCP)이라 불리는 표준 통신 프로토콜을 사용하며 이 외에도 SCTP(Stream Control Transmission Protocol) 나 DCCP (Datagram Congestion Control Protocol) 가 사용되지만 여기서는 다루지 않기로 한다. 컴퓨터 네트워크에서 데이터는 보통 패킷이라는 단위로 전송되는데, TCP는 패킷이 오류 없이 순서대로 도착하도록 설계되었다. 웹서버, 메일서버, 각 클라이언트 애플리케이션 모두는 TCP와 스트림 소켓을 사용한다.\n\n\n\n\n데이터그램 소켓의 연결은 단방향이고 신뢰할 수 없다. IP 와 포트번호를 특정하여 보내지만 수신을 확인하지 않는다. 또한 데이터가 순서대로 전송된다고 보장할 수도 없다. 사용자 데이터그램 프로토콜(User Datagram Protocol, UDP)이라는 표준 프로토콜을 사용한다. TCP 에 비해 단순하고 간단하며 부하가 적고 빠른 방법이다. 패킷 손실이 허용되기도 하며 네트워크 게임이나 음악/동영상 스트리밍에서 자주 쓰인다. UDP 를 통해 신뢰성 있는 데이터 통신을 하고 싶다면 직접 패킷을 통해 구현해야 한다.\n\n\n\n\n여기서는 접속을 기다리는 것이 서버(server), 기다리는 서버에 접근하는 것이 클라이언트(client) 라고 한다.",
    "crumbs": [
      "TCP/UDP 통신"
    ]
  },
  {
    "objectID": "src/topics/socket.html#소켓-통신",
    "href": "src/topics/socket.html#소켓-통신",
    "title": "TCP/UDP 통신",
    "section": "",
    "text": "현재의 많은 장비들은 소켓 통신을 사용하여 데이터와 정보를 주고받는다. 예전의 장비들은 RS232 나 RS485 같은 직렬 통신이나 다른 다양한 통신 방법을 사용하는 경우가 많았지만 최근의 장비들은 소켓 통신을 통해 데이터를 전송하는 경우가 많다. 여기서는 소켓 통신에 대해 짧게 알아보고 실제 구현해 보기로 하자.\n\n\n\n소켓은 같은 컴퓨터의 프로세스 사이에서, 혹은 서로 다른 컴퓨터(혹은 장비)의 프로세스 사이에서 통신을 수행할 때의 종단점 (end point)이다. 같은 컴퓨터의 프로세스 사이의 소켓에는 unix domain socket 이 있으며 다른 컴퓨터 프로세스 사이에서의 통신에는 Datagram socket 과 Streaming socket 이 있다. 각각의 네트워크 하드웨어는 사양과 내부 명령어가 다르지만 운영체제 수준에서 이를 추상화하여 서로 통신할 수 있도록 한 것이 소켓이다. 여기서는 서로 다른 컴퓨터의 프로세스간 통신에 대해서만 다루기로 한다.\n\n\n\n\n전화와 같이 믿을 수 있는 양방향 통신을 제공한다. 즉 데이터를 주고받는 소켓의 양쪽이 성립된 상태에서 한쪽(서버)에서 다른 한쪽(클라이언트)으로의 연결을 초기화하고, 연결이 생성된 후에는 어느 쪽에서든 다른 쪽으로 통신할 수 있다. 데이터를 송신하고 나서 이 데이터가 실제로 도착했는지도 즉각 확인할 수 있다. 보통 전송 제어 프로토콜(Transmission Control Protocol, TCP)이라 불리는 표준 통신 프로토콜을 사용하며 이 외에도 SCTP(Stream Control Transmission Protocol) 나 DCCP (Datagram Congestion Control Protocol) 가 사용되지만 여기서는 다루지 않기로 한다. 컴퓨터 네트워크에서 데이터는 보통 패킷이라는 단위로 전송되는데, TCP는 패킷이 오류 없이 순서대로 도착하도록 설계되었다. 웹서버, 메일서버, 각 클라이언트 애플리케이션 모두는 TCP와 스트림 소켓을 사용한다.\n\n\n\n\n데이터그램 소켓의 연결은 단방향이고 신뢰할 수 없다. IP 와 포트번호를 특정하여 보내지만 수신을 확인하지 않는다. 또한 데이터가 순서대로 전송된다고 보장할 수도 없다. 사용자 데이터그램 프로토콜(User Datagram Protocol, UDP)이라는 표준 프로토콜을 사용한다. TCP 에 비해 단순하고 간단하며 부하가 적고 빠른 방법이다. 패킷 손실이 허용되기도 하며 네트워크 게임이나 음악/동영상 스트리밍에서 자주 쓰인다. UDP 를 통해 신뢰성 있는 데이터 통신을 하고 싶다면 직접 패킷을 통해 구현해야 한다.\n\n\n\n\n여기서는 접속을 기다리는 것이 서버(server), 기다리는 서버에 접근하는 것이 클라이언트(client) 라고 한다.",
    "crumbs": [
      "TCP/UDP 통신"
    ]
  },
  {
    "objectID": "src/topics/socket.html#tcp-와-udp-를-이용한-간단한-에코-서버와-클라이언트의-저차원-구현",
    "href": "src/topics/socket.html#tcp-와-udp-를-이용한-간단한-에코-서버와-클라이언트의-저차원-구현",
    "title": "TCP/UDP 통신",
    "section": "2 TCP 와 UDP 를 이용한 간단한 에코 서버와 클라이언트의 저차원 구현",
    "text": "2 TCP 와 UDP 를 이용한 간단한 에코 서버와 클라이언트의 저차원 구현\n여기서는 Python 으로 간단한 서버와 클라이언트를 구현한다. 가장 기본적인 저차원 구현은 C 언어를 이용한 구현이지만 여기서는 이 C 구현과 가장 비슷하며 저차원 구현을 체험해 볼 수 있는 Python 구현을 통해 TCP 와 UDP 통신을 알아보기로 하자.\n\nTCP 통신\n서버가 대기하고 클라이언트와의 접속이 성립하면 클라이언트는 사용자로부터의 입력을 서버에게 보낸다. 서버는 클라이언트로부터 받은 메시지를 출력하고 그 메시지 끝에 # 을 붙여 클라이언트에게 보낸다. 클라이언트는 # 이 붙은 메시지를 받고 출력한다. 사용자로부터 -1 을 받으면 서버는 역시 # 이 붙은 메시지 -1# 을 클리이언트로 보내고 종료하며, 클라이언트 역시 종료한다.\nPython 으로 구현하지만 여기서의 방식은 소켓 통신의 기본적인 즉 low-level 방식으로 거의 모든 언어에서 기본적으로 지원한다. 물론 실제로는 이 방식보다는 이 방식을 좀 더 쓰기 편하게 만든 방식을 쓸 수도 있지만 기본 동작을 일단 확인하기 위해 low-level 방식으로 구현해보자.\n소켓 통신을 위해서는 socket 모듈을 임포트 해야 하고 소켓 객체를 구현해야 한다. 서버에는 두개의 소켓이 필요하다. 하나는 접속을 받아들이고 연결을 위한 역할을 수행하는 소켓(이하 연결 소켓)이며 다른 하나는 클라이언트와 데이터를 주고받기 위한 소캣(이하 서버 소켓)이다. 클라이언트는 데이터를 주고받는 소켓(이하 클라이언트 소켓) 하나만 있으면 된다. 연결 소켓, 서버소켓, 클라이언트 소켓은 편의상 지은 이름이며 다른 곳에서는 다른 이름으로 사용될 수 있다.\n\nTCP 서버\n일단 서버쪽에서 연결 소켓을 성립시켜야 한다. 연결 소켓을 위해서는 서버 IP 와 포트 번호가 필요하다. IP 는 \"123.123.123.12\" 형식의 문자열이며 포트 번호는 0 부터 65535 번까지의 정수이다. IP 와 포트번호는 Internet Assigned Numbers Authority (IANA) 에서 관리하는데 포트 번호중의 일부는 특별한 용도로 지정되어 있다. 자세한 것은 List of TCP and UDP port numbers 를 참고하라. 보통 49152 에서 65535 번호는 자유롭게 사용 할 수 있다.\n\n연결 소켓은 IP 와 포트번호, 그리고 프로토콜로 구성된다. 우선\nimport socket\n을 통해 소캣 모듈을 사용할 수 있도록 한다. 이후 아래와 같이 소켓 인스턴스를 만들고 프로토콜과 옵션을 정한다.\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\nsocket.socket 의 첫번째 인자로는 다음이 사용될 수 있다.\n\nsocket.AF_INET 은 IPv4 즉 4 개의 8비트 정수로 지정된 IP 번호를 사용한는 것을 의미한다. 보퉁 많이 사용하는 123.123.123.12 형식이다.\nsocket.AF_INET6 는 IPv6 주소체계를 사용한다는 것을 의미하며 16비트 정수 4개를 사용한다.\nsocket.AF_UNIX 는 네트웍 통신이 아닌 프로세스간의 통신에 대해 사용한다.\n\nsocket.socket 의 두번째 인자로는 다음이 사용될 수 있다.\n\nsocket.SOCK_STREAM 은 TCP 통신 규약을 사용한다는 것을 의미한다.\nsocket.SOCK_DGRAM 은 UDP 통신 규약을 사용한다는 것을 의미한다.\n\n\nsocket.setsockopt 함수는 소켓의 옵션을 지정한다. 첫번째 인자는 프로토콜 레벨이며 두번째 인자는 프로토콜 레벨에서의 옵션 이름, 세번째 인자부터는 앞의 두 인자에 따른 설정값 등이 온다. 자세한 내용은 setsockopt 서브루틴 을 참고하라. 여기서 socket.SO_REUSEADDR 옵션의 옵션값을 1 로 설정하면 클라이언트 소켓을 닫은 후 같은 IP 와 포트번호로 연결할 수 있다.\n\nserver_socket.bind((host, port))\nserver_socket.listen(0)\nclient_soc, addr = server_socket.accept()\nbind((host, port)) 는 연결 소켓에 IP 번호(host) 와 포트(port) 를 지정한다. 이제 listen() 을 통해 클라이언트로부터 접속 요청 대기를 시작한다. listen 함수는 최대 대기 큐의 갯수를 인자로 받을 수 있며, 인자가 없을 경우 자동으로 할당된다.\naccept() 함수는 연결을 시도한 클라이언트와 통신 할 수 있는 소켓(client_soc), 즉 서버 소켓과 연결된 클라이언트의 (IP 주소, 포트) 튜플을 반환한다. 이 서버 소켓을 통해 클라이언트와 통신한다. 이제 서버의 코드를 보자.\n# TCP 서버 프로그램 \nimport socket, time\n\nhost, port = 'localhost', 43333\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\nserver_socket.bind((host, port))\nserver_socket.listen()\n\nprint('TCP 서버 시작')\n\nclient_soc, addr = server_socket.accept()\n\nprint('연결된 client (IP, port):', addr)\n\n# 접속 유지 변수\nconnection_retained = True\n\nwhile connection_retained :\n    try:\n        data = client_soc.recv(1024)\n    except ConnectionResetError:\n        print('ConnectionResetError')\n        connection_retained = False\n    finally:    \n        msg = data.decode() # 읽은 데이터 디코딩\n        print('받은 메시지 :', msg)\n        client_soc.sendall((msg+\"#\").encode(encoding='utf-8')) # 에코메세지 클라이언트로 보냄\n\n        # 클라이언트로부터 받은 메시지가 \"-1\" 이면 접속을 종료시킨다.\n        if msg == \"-1\":\n            connection_retained = False\n            print(\"to be closed\")        \n            client_soc.close()\n        \n    time.sleep(0.2)\n    \nserver_socket.close() # 사용했던 서버 소켓을 닫아줌 \n앞서 말했듯이 클라이언트로부터 -1 메시지를 받기 전까지는 계속 클라이언트와 통신해야 한다. 이를 위해 일단 connection_retianed = True 로 두고 이 변수값이 True 인 상황에서는 계속 주고 받도록 한다. 그러나 클라이언트로부터 -1 을 받으면 connection_refused = False 가 되며 while 루프를 벗어나고 소켓이 종료되고 (server_socket.close()) 프로그램도 종료한다.\n\n\n\nTCP 클라이언트\n클라이언트는 서버보다 간단한다.\nimport socket\nserver_ip, server_port = 'localhost', 43333\nsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n서버에 접속하기 위해서는 서버의 IP 와 포트 번호를 알야야 한다(server_ip, server_port). TCP 통신이므로 소켓은 server 의 연결소켓과 같이 설정한다. 이제 연결을 시도한다\nsocket.connect((server_ip, server_port))\n서버와 마찬가지로 연결 유지를 확인하기 위한 변수 connetion_retained 가 존재한다. 코드는 아래와 같다.\n# TCP 클라이언트 프로그램\nimport socket, time\n\nserver_ip, server_port = 'localhost', 43333\nsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsocket.connect((server_ip, server_port))\nsocket.settimeout(0.1)\n\n# 연결 유지 변수\nconnection_retained = True\n\nwhile connection_retained :\n    msg = input('msg:') # 서버로 보낼 msg 입력\n    \n    if msg == \"-1\":\n        connection_retained = False\n    socket.sendall(msg.encode(encoding='utf-8'))\n\n    # 서버가 에코로 되돌려 보낸 메시지를 클라이언트가 받음\n    try:\n        data = socket.recv(1024)\n    except TimeoutError:\n        print('TimeoutError')\n    finally:\n        msg = data.decode() # 읽은 데이터 디코딩\n        print('서버로부터 받은 메시지 :', msg)\nsocket.close()\nsocket.recv(1024) 는 서버로부터 최대 1024 바이트를 는다는 의미이다. 그러나 이 함수 실행 후 지정된 시간동안 응답이 없을 경우 TimeoutError 가 발생하며 소캣이 종료된다. 응답대기시간은 socket.settimeout() 함수를 통해 지정하며 인자로 초 단위의 시간을 입력한다. 인자가 없으면 무한정 기다린다.\n여기서는 응답 대기 시간이 길더라도 문제가 없지만 예를 들어 여러 서버로부터 데이터를 받는 경우를 생각해보자. 여기서 응답을 대기한다면 다른 작업을 수행 할 수가 없으며, 이를 위해 응답 대기시간을 짧게 잡고 다른 작업을 수행한 후 다시 메시지를 기다리는 것이 좋다.\n\n\n\n\nUDP 통신\nUDP 통신과 TCP 통신의 차이는 다음과 같다.\n\n소켓 타입이 socket.SOCK_STREAM 이 아닌 socket.SOCK_DGRAM 이다.\n연결 소켓이 없으며 서버소켓이 직접 bind 된다.\nTCP 에서는 recv, send 를 통해 데이터를 주고받지만 UDP 에서는 recvfrom, sendto 함수를 사용한다. 앞서 사용한 sendall 함수는 기본 함수인 send 를 python socket 모듈에서 확장한 것이다.\nrecvfrom 함수를 통해 데이터와 데이터를 보낸 주소를 얻으며, 이 주소가 원하는 주소가 않을 경우 무시한다.\nsendto 함수의 인자로는 데이터와 데이터를 받을 IP, 포트번호의 튜플을 전달한다.\n\n\n소스코드를 보라.\n\n\nUDP 서버\n# UDP 서버 프로그램\nimport socket, time\n\nhost, port = 'localhost', 43333\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nserver_socket.bind((host, port))\n# server_socket.listen()\n\nprint('UDP 서버 시작')\n\n#client_soc, addr = server_socket.accept()\naddr = (None, None)\n\nprint('연결된 client (IP, port):', addr)\n\n# 접속 유지 변수\nconnection_retained = True\n\nwhile connection_retained :\n    try:\n        data, addr = server_socket.recvfrom(1024)\n    except ConnectionResetError:\n        print('ConnectionResetError')\n        connection_retained = False\n    finally:    \n        msg = data.decode() # 읽은 데이터 디코딩\n        print(addr, '받은 메시지 :', msg)\n        server_socket.sendto((msg+\"#\").encode(encoding='utf-8'), addr) # 에코메세지 클라이언트로 보냄\n\n        # 클라이언트로부터 받은 메시지가 \"-1\" 이면 접속을 종료시킨다.\n        if msg == \"-1\":\n            connection_retained = False\n            print(\"to be closed\")        \n            # client_soc.close()\n        \n    time.sleep(0.2)\n    \nserver_socket.close() # 사용했던 서버 소켓을 닫아줌 \n\n\n\nUDP 클라이언트\n# UDP 클라이언트 프로그램\nimport socket, time\n\nserver_addr = ('localhost', 43333)\nsocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n# socket.connect((server_ip, server_port))\nsocket.settimeout(0.1)\n\n# 연결 유지 변수\nconnection_retained = True\n\nwhile connection_retained :\n    msg = input('msg:') # 서버로 보낼 msg 입력\n    \n    if msg == \"-1\":\n        connection_retained = False\n    socket.sendto(msg.encode(encoding='utf-8'),server_addr)\n\n    # 서버가 에코로 되돌려 보낸 메시지를 클라이언트가 받음\n    try:\n        data, addr = socket.recvfrom(1024)\n    except TimeoutError:\n        print('TimeoutError')\n    finally:\n        msg = data.decode() # 읽은 데이터 디코딩\n        print('서버로부터 받은 메시지 :', msg)\nsocket.close()",
    "crumbs": [
      "TCP/UDP 통신"
    ]
  }
]