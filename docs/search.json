[
  {
    "objectID": "src/tools/tikz/tikz_test.html",
    "href": "src/tools/tikz/tikz_test.html",
    "title": "tikz test",
    "section": "",
    "text": "코드\n```{r, engine = 'tikz'}\n#| label: fig-wavelet_resolution_2\n#| code-fold: true\n#| output: asis\n#| fig-width: 10\n#| fig-align: center\n#| fig-cap: \"DWT resolution\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}[samples = 200, scale=1.2]\n\n\\draw[-{stealth}] (0, 0) -- (8.5,0) node[right] {$t$};\n\\draw[-{stealth}] (0,0) -- (0,4) node[above] {$\\omega$};\n\n\\draw [thick] (0, 0.5) -- (8, 0.5);\n\\draw [thick] (0, 1.5) -- (8, 1.5);\n\\draw [thick] (0, 3.5) -- (8, 3.5);\n\n\n\\filldraw[black] (0, 0) circle (1pt) node [below, scale=0.7] {$n=0$};\n\\filldraw[black] (4, 0) circle (1pt) node [below, scale=0.7] {$n=1$};\n\\filldraw[black] (8, 0) circle (1pt) node [below, scale=0.7] {$n=2$};\n\\filldraw[black] (0, 0) circle (1pt) node [left, scale=0.7] {$m=0$};\n\\filldraw[black] (0, 0.5) circle (1pt) node [left, scale=0.7] {$m=-1$};\n\\filldraw[black] (0, 1.5) circle (1pt) node [left, scale=0.7] {$m=-2$};\n\\filldraw[black] (0, 3.5) circle (1pt) node [left, scale=0.7] {$m=-3$};\n\n\\foreach \\x in {0,...,4}\n{\n\\draw [thick] (2*\\x, 0) -- (2*\\x, 3.5);\n\n}\n\n\n\\foreach \\x in {0,...,8}\n{\n\\draw [thick] (\\x, 0.5) -- (\\x, 3.5);\n}\n\n\\foreach \\x in {0,...,15}\n{\n\\draw [thick] (\\x/2, 1.5) -- (\\x/2, 3.5);\n}\n\n\\draw[{stealth}-{stealth}] (7.5, 3.7) -- (8.0,3.7);\n\\node[above] at (7.75, 3.7) {$\\sigma_t$};\n\n\\draw[{stealth}-{stealth}] (8.2, 1.5) -- (8.2,3.5);\n\\node[right] at (8.2, 2.5) {$\\sigma_\\omega$};\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 1: DWT resolution",
    "crumbs": [
      "Tools",
      "tikz test"
    ]
  },
  {
    "objectID": "src/tools/tikz/tikz_image.html",
    "href": "src/tools/tikz/tikz_image.html",
    "title": "Tikz code for image in Quarto",
    "section": "",
    "text": "코드\n\\begin{tikzpicture}\n    \\draw [black, very thick, -&gt;](0, 0) -- (2, 2)  node[right] {$\\boldsymbol{v}$};\n    \\draw [red, very thick, -&gt;] (0, 0) -- (-2.646, 1 ) node[left] {$\\boldsymbol{H_v x}$};\n    \\draw [blue, very thick, -&gt;] (0, 0) -- (-0.646, 3 ) node[left] {$\\boldsymbol{x}$};\n    \\draw [green, dashed, thick] (1, -1) -- (-2, 2 ) node[left, black] {Plane normal to $\\boldsymbol{v}$};\n\\end{tikzpicture}\n\n\n\n\n\n\n\n그림 1: Householder 반사\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-tikz_first_exam\n#| code-fold: true\n#| output: asis\n#| fig-align: center\n#| fig-cap: \"tikz in Quarto 예시\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{decorations.pathreplacing}\n\n\\begin{tikzpicture}\n\\draw[step=1.0,black,thick] (-3,-3) grid (3,3);\n\\node at (-2.5, 2.5) {$x_{1}$};\n\\node at (-2.5, 1.5) {$x_{2}$};\n\\node at (-2.5, 0.5) {$x_{3}$};\n\\node at (-2.5, -0.5) {$\\vdots$};\n\\node at (-1.5, 2.5) {$\\cdots$};\n\\node at (2.5, -2.5) {$x_N$};\n\\node at (5.5, 2.5) {Detector};\n\\draw[red, thick, -{stealth}] (-4, -2) -- (5.5, 1.5);\n\n\\begin{scope}[shift={(5.7,1.55)},rotate=20.4]\n\\draw[blue, very thick] (-0.5,-0.5) -- (0.5,-0.5) -- (0.5,0.5) -- (-0.5,0.5); \n\\end{scope}\n\n\\begin{scope}[shift={(0.3, 0.2)},rotate=20.4]\n\\draw [decorate,decoration={brace,amplitude=5pt,mirror,raise=4ex}]\n  (-0.5,0) -- (0.5,0) node[midway,yshift=-3em, red]{$w_{ij}$};\n\\end{scope}\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 2: tikz in Quarto 예시",
    "crumbs": [
      "Tools",
      "Tikz code for image in Quarto"
    ]
  },
  {
    "objectID": "src/tools/tikz/tikz.html",
    "href": "src/tools/tikz/tikz.html",
    "title": "tikz in Quarto",
    "section": "",
    "text": "코드\n```{r, engine = 'tikz'}\n#| label: fig-tikz_first_exam\n#| code-fold: true\n#| output: asis\n#| fig-align: center\n#| fig-cap: \"tikz in Quarto 예시\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows.meta}\n\\usetikzlibrary{decorations.pathreplacing}\n\n\\begin{tikzpicture}\n\\draw (0,0)node(a){} -- (10,0) node (b) {} ;\n\\foreach \\x in  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10} % edit here for the vertical lines\n\\draw[shift={(\\x,0)},color=black] (0pt,3pt) -- (0pt,-3pt);\n\\foreach \\x in {0, 0.2, 0.4, 0.6, 0.8, 1} % edit here for the numbers\n\\draw[shift={(\\x*10,0)},color=black] (0pt,0pt) -- (0pt,-3pt) node[below]\n{$\\x$};\n\\node at (8, 0.5) (eq1) {$\\textcolor{red}{\\boldsymbol{SQ}}$};\n\\node at (4, 0.5) (eq2) {$\\textcolor{purple}{\\boldsymbol{G_i(0)}}$}; \n\\node at (7, 0.5) (eq2) {$\\textcolor{purple}{\\boldsymbol{G_i(1)}}$}; \n\\node at (3, 0.5) (eq3) {$\\textcolor{blue}{\\boldsymbol{P}}$};\n\\node at (0, 0.5) (eq4) {$\\textcolor{black}{\\boldsymbol{x_i}}$};\n\\draw[decorate, decoration={brace, amplitude=6pt, mirror},] ([yshift=0.5cm]4,0.5)-- node[above=0.25cm]\n{\\shortstack{Text}}([yshift=0.5cm]3,0.5);\n\\draw[decorate, decoration={brace, amplitude=6pt},] ([yshift=-1cm]7,0)-- node[below=0.25cm]\n{\\shortstack{Text}}([yshift=-1cm]3,0);\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 1: tikz in Quarto 예시",
    "crumbs": [
      "Tools",
      "tikz in Quarto"
    ]
  },
  {
    "objectID": "src/tools/tikz/tikz.html#기본-예제",
    "href": "src/tools/tikz/tikz.html#기본-예제",
    "title": "tikz in Quarto",
    "section": "1 기본 예제",
    "text": "1 기본 예제\n\n직선\n다음은 교차하는 직선과 교점을 그린 것이다.\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-tikz_2\n#| code-fold: true\n#| output: asis\n#| fig-width: 2\n#| fig-align: center\n#| fig-cap: \"tikz 2\"\n\n\\begin{tikzpicture}[scale=1.0]\n\\draw[gray] (-1,2) -- (2,-4);\n\\draw[red, thick] (-1,-1) -- (2,2);\n\\filldraw[black] (0,0) circle (2pt) node[anchor=west]{Intersection point};\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 2: tikz 2\n\n\n\n\n\n\\draw[gray](-1, 2) -- (2, -4); 는 \\((-1, 2)\\) 에서 \\((2, -4)\\) 까지 회색(gray) 의 직선을 그으라는 명령어이다.\n\\draw[red, thick] (-1,-1) -- (2,2); 는 주어진 좌표간의 빨갛고(red), 두꺼운(thick) 직선을 그으라는 의미이다.\n\\filldraw[black] (0,0) circle (2pt) node[anchor=west]{Intersection point}; 는 \\((0, 0)\\) 에 반지름 2 인 속이 꽉 찬 원을 그리며, \\((0, 0)\\) 을 서쪽으로 두는 문자열 Intersection point 를 출력하라는 의미이다.\n\n\n\n\n그리드와 직선의 두께\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-tikz_2_2\n#| code-fold: true\n#| output: asis\n#| fig-width: 2\n#| fig-align: center\n#| fig-cap: \"그리드와 직선의 두께\"\n\n\\begin{tikzpicture}\n    \\draw[gray, very thick] (0,0) grid (4,3);\n    \\draw[blue, dashed] (0,0) -- (1,2) -- (3,3) -- (4,2);\n    \\draw[red, -&gt;, thick] (2,0) -- (3.5,2.5);\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 3: 그리드와 직선의 두께\n\n\n\n\n\n\\draw[gray, very thick] (0,0) grid (4,3); 는 \\((0, 0)\\) 부터 \\((4, 3)\\) 까지 가로, 세로 1 간격의 그리드를 회색(gray) 의 두꺼운 선(very thick) 으로 그린다.\ndraw[blue, dashed] (0,0) -- (1,2) -- (3,3) -- (4,2); 는 이어지는 파선(dashed) 을 파란 색으로 그린다.\n\\draw[red, -&gt;, thick] (2,0) -- (3.5,2.5); 는 끝점에 화살표가 있는 빨간 선을 두껍게(thick) 그린다.\n\n\n\n\n닫힌 선분\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-tikz_2_3\n#| code-fold: true\n#| output: asis\n#| fig-width: 2\n#| fig-align: center\n#| fig-cap: \"닫힌 선분\"\n\n\\begin{tikzpicture}\n    \\draw[green, thick] (0,0) -- (1,2) -- (3,3) -- (3,-1)--cycle;\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 4: 닫힌 선분\n\n\n\n\n\n\\draw[green, thick] (0,0) -- (1,2) -- (3,3) -- (3,-1)--cycle; 에서 --cycle 은 이 앞의 (3, -1) 을 맨 앞의 (0, 0) 과 연결시키라는 의미이다.\n\n\n\n\n곡선\n다음은 곡선을 그린 것이다.\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-tikz_3\n#| code-fold: true\n#| output: asis\n#| fig-width: 2\n#| fig-align: center\n#| fig-cap: \"tikz 3\"\n\n\\begin{tikzpicture}[scale=1.0]\n\\draw (-2,0) -- (2,0);\n\\filldraw [blue] (0,0) circle (2pt);\n\\draw[cyan] (-2,-2) .. controls (0,0) .. (2,-2);\n\\draw[magenta] (-2,2) .. controls (-1,0) and (1,0) .. (2,2);\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 5: tikz 3\n\n\n\n\n\n\\draw[magenta] (-2,2) .. controls (-1,0) and (1,0) .. (2,2); 는 \\((-2, 2)\\) 와 \\((2, 2)\\) 를 끝점으로 하고 \\((-1, 0)\\) 과 \\((1, 0)\\) 을 제어점으로 하는 사차 베지어 곡선을 magenta 색으로 그린다.\n\\draw[cyan] (-2,-2) .. controls (0,0) .. (2,-2); 는 (\\(-2, 2)\\) 와 \\((2, 2)\\) 를 끝점으로 하고 제어점이 \\((0, 0)\\) 인 사차 베지어 곡선을 cyan 색으로 그린다. 즉 \\draw[magenta] (-2,2) .. controls (0,0) and (0,0) .. (2,2); 과 같다.\n\n\n\n\n함수\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-tikz_4\n#| code-fold: true\n#| output: asis\n#| fig-width: 4\n#| fig-align: center\n#| fig-cap: \"tikz 3\"\n\\begin{tikzpicture}[domain=0:4]\n  \\draw[very thin,color=gray] (-0.1,-1.1) grid (3.9,3.9);\n\n  \\draw[-&gt;] (-0.2,0) -- (4.2,0) node[right] {$x$};\n  \\draw[-&gt;] (0,-1.2) -- (0,4.2) node[above] {$f(x)$};\n\n  \\draw[color=red]    plot (\\x,\\x)             node[right] {$f(x) =x$};\n  % \\x r means to convert '\\x' from degrees to _r_adians:\n  \\draw[color=blue]   plot (\\x,{sin(\\x r)})    node[right] {$f(x) = \\sin x$};\n  \\draw[color=orange] plot (\\x,{0.05*exp(\\x)}) node[right] {$f(x) = \\frac{1}{20} e^x$};\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 6: tikz 3\n\n\n\n\n\n\\begin{tikzpicture}[domain=0:4] 에서 [domain=0:4] 은 함수를 사용할 때 \\([0, 4]\\) 구간을 사용한다는 의미이다.\n\\draw[color=red] plot (\\x,\\x) node[right] {$f(x) =x$}; 팔간색 선으로 \\(y=x\\) 그래프를 그리며 끝점의 오른쪽에 \\(f(x)=x\\) 라는 문자열을 넣으라는 의미.\n\n\n\n\n도형\n\nShade\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-tikz_shade\n#| code-fold: true\n#| output: asis\n#| fig-width: 6\n#| fig-align: center\n#| fig-cap: \"tikz shade\"\n\n\n\\begin{tikzpicture}[scale = 3, rounded corners,ultra thick]\n  \\shade[top color=yellow,bottom color=black] (0,0) rectangle +(2,1);\n  \\shade[left color=yellow,right color=black] (3,0) rectangle +(2,1);\n  \\shadedraw[inner color=yellow,outer color=black,draw=yellow] (6,0) rectangle +(2,1);\n  \\shade[ball color=green] (9,.5) circle (.5cm);\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 7: tikz shade\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-tikz_shade2\n#| code-fold: true\n#| output: asis\n#| fig-width: 3\n#| fig-align: center\n#| fig-cap: \"tikz shade\"\n\n\n\\begin{tikzpicture}[scale=3]\n  \\clip (-0.1,-0.2) rectangle (1.1,0.75);\n  \\draw[step=.5cm,gray,very thin] (-1.4,-1.4) grid (1.4,1.4);\n  \\draw (-1.5,0) -- (1.5,0);\n  \\draw (0,-1.5) -- (0,1.5);\n  \\draw (0,0) circle (1cm);\n  \\filldraw[fill=green!20,draw=green!50!black] (0,0) -- (3mm,0mm) arc\n  (0:30:3mm) -- cycle;\n  \\draw[red,very thick]  (30:1cm) -- +(0,-0.5);\n  \\draw[blue,very thick] (30:1cm) ++(0,-0.5) -- (0,0);\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 8: tikz shade\n\n\n\n\n\n\n\n\n좌표계\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-tikz_co_1\n#| code-fold: true\n#| output: asis\n#| fig-width: 2\n#| fig-align: center\n#| fig-cap: \"좌표계\"\n\\begin{tikzpicture}\n  \\draw [red,-&gt;](0,0) -- (xyz cs:x=2) node[right, black] {$x$};\n  \\draw [green,-&gt;](0,0) -- (xyz cs:y=2) node[right, black] {$y$};\n  \\draw [blue,-&gt;](0,0) -- (xyz cs:z=2) node[right, black] {$z$};\n\n  \\draw [red, thick, -&gt;] (0, 0) -- (xyz cs:x=2, y=2, z=1);\n  \\draw [red, dashed] (xyz cs:x=2, y=2, z=1) -- (xyz cs:x=0, y=2, z=1);\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 9: 좌표계\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-rotation_of_vector\n#| code-fold: true\n#| fig-width: 6\n#| output: asis\n#| fig-align: center\n#| fig-cap: \"두 좌표계\"\n\n\\usetikzlibrary {3d} \n\\usetikzlibrary {arrows}\n\\usetikzlibrary{shapes.geometric}\n\\begin{tikzpicture} %[=&gt;stealth]\n\\tikzset{\n    partial ellipse/.style args={#1:#2:#3}{\n        insert path={+ (#1:#3) arc (#1:#2:#3)}\n    }\n}\n  \\draw [-&gt;] (0,0) -- (xyz cs:x=3);\n  \\draw [-&gt;] (0,0) -- (xyz cs:y=4.5);\n  \\draw [-&gt;] (0,0) -- (xyz cs:z=3); \n  \\draw [dashed] (0.0,3.0) ellipse (1.5 and 0.5);\n  \\draw [thick, -{stealth}] (0, 0) -- (xyz cs:x=0.7,y=2.55);\n  \\node[below, scale=.6] at (0.3, 2.3) {$\\boldsymbol{r}_i (q_j)$};\n  \\draw [thick, -{stealth}] (0, 0) --(xyz cs:x=1.4,y=2.8);\n  \\node[scale=.6] at (1.5, 1.7) {$\\boldsymbol{r}_i (q_j+dq_j)$};\n  \\draw [red, thick, -{stealth}] (0.7, 2.55) -- (1.4, 2.8);\n  \\node[red, scale=.6] at (1.0, 2.5) {$d\\boldsymbol{r}_i$};\n  \\draw [thick, -{stealth}] (0, 3) -- (0, 3.7) node[right, scale=0.6] {$\\;\\boldsymbol{n}$};\n\n  \\draw [teal] (0, 3) -- (0.7, 2.55);\n  \\draw [teal] (0, 3) -- (1.4, 2.8);\n  \\draw[teal, -&gt;] (0, 3.0) [partial ellipse=297:340:0.6 and 0.2] node[above, scale=0.6] {$dq_j$} ;\n  \\draw[purple, -&gt;] (0, 0) [partial ellipse=90:75:1 and 1] node[above left, scale=0.6] {$\\theta$} ;\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 10: 두 좌표계\n\n\n\n\n\n\n\n신호처리 함수\n\n\n코드\n\\usetikzlibrary{arrows}\n\\begin{tikzpicture}[ &gt;=stealth]\n\n\n\\draw[-&gt;] (-2, 0) -- (2, 0) node[below, black] {$x$} ;\n\\draw[ -&gt;] (0, -0.5) -- (0, 1.5);\n\\draw[thick] (-2, 0) -- (0, 0) node[below left, black] {$0$} -- (0, 1) node[left, black] {$1$}-- (2, 1) node[above left, black] {$\\text{step}(x)$};\n\n\\draw[-&gt;] (4, 0) -- (8, 0) node[below, black] {$x$} ;\n\\draw[ -&gt;] (6, -0.5) -- (6, 1.5);\n\\draw[thick] (4, 0) -- (5.5, 0) node[below, black] {$-\\frac{1}{2}$} -- (5.5, 1) -- (6, 1)  -- (6.5, 1)-- (6.5, 0)  node[below, black] {$\\frac{1}{2}$} -- (8, 0) node[above left, black] {$\\text{rect}(x)$};\n\n\\draw[-&gt;] (-2, -3) -- (2, -3) node[below, black] {$x$} ;\n\\draw[ -&gt;] (0, -3.5) -- (0, -1.5);\n\\draw[thick] (-2, -3) -- (-0.5, -3) node[below, black] {$-\\frac{1}{2}$} -- (0, -2) -- (0.5, -3) node[below, black] {$-\\frac{1}{2}$} -- (2, -3) node[above left, black] {$\\text{tri}(x)$};\n\n\n\\draw[-&gt;] (4, -3) node[above right, black] {$\\text{sinc}(x)$} -- (8, -3) node[below, black] {$x$} ;\n\\draw[ -&gt;] (6, -3.5) -- (6, -1.5);\n\\draw[domain=4.0:8.0, smooth, variable=\\x, thick] plot ({\\x}, {0.116*sin(500* (\\x-6))/((\\x-6)) -3 });\n\\draw (6.36, -2.9) -- (6.36, -3.1) node[below, black] {$\\pi$} ; \n\n\n\\draw[-&gt;] (-2, -6) -- (2, -6) node[below, black] {$x$} ;\n\\draw[ -&gt;] (0, -6.5) -- (0, -4);\n\\draw[domain=-1.8:1.8, smooth, variable=\\x, thick] plot ({\\x}, {exp(-(\\x)^2) - 6 });\n\\node[black, right] at (0, -4.7) {$\\text{gauss}(x)$};\n%\\draw (6.36, -2.9) -- (6.36, -3.1) node[below, black] {$\\pi$} ; \n\n\n\\draw[-&gt;] (4, -6)  -- (8, -6) node[below, black] {$x$} ;\n\\draw[ -&gt;] (6, -6.5) -- (6, -4);\n\\draw[very thick] (4.2, -6) -- (6, -6) -- (6, -4) node[left, black] {$\\infty$}-- (6, -6)  -- (7.8, -6) node[above left, black] {$\\delta (x)$};\n\n\\end{tikzpicture}\n\n\n\n\n\n\n\n그림 11: 기본적인 신호들",
    "crumbs": [
      "Tools",
      "tikz in Quarto"
    ]
  },
  {
    "objectID": "src/posts/index.html",
    "href": "src/posts/index.html",
    "title": "The Notebook",
    "section": "",
    "text": "첫번째 글\n\n\n\n\n\n\n\n\n\n\n\nJulia_KAERI\n\n\n\n\n\n\n일치 없음"
  },
  {
    "objectID": "src/gpu/cuda_jl_kernel_programming.html",
    "href": "src/gpu/cuda_jl_kernel_programming.html",
    "title": "CUDA.jl 커널 프로그래밍",
    "section": "",
    "text": "CPU 에서 호출하고 GPU 에서 실행되는 함수를 커널(kernel) 이라고 한다. 커널은 보통의 julia 함수처럼 정의한다.\nfunction my_kernel()\n    return\nend\n커널을 실행하기 위해서는 @cuda 매크로를 사용한다.\n@cuda my_kernel\n위의 명령을 실행하면 my_kernel 함수가 컴파일되며 현재의 GPU 에서 실행된다.\n\n@cuda 매크로에 launch=false 인자를 전달하면 컴파일만 되고 실행하지 않으며 호출 가능한 객체를 리턴한다.\njulia&gt; k = @cuda launch=false my_kernel()\nCUDA.HostKernel for my_kernel()\n\njulia&gt; CUDA.registers(k)\n4\n\njulia&gt; k()",
    "crumbs": [
      "GPU & CUDA",
      "CUDA.jl",
      "CUDA.jl 커널 프로그래밍"
    ]
  },
  {
    "objectID": "src/gpu/cuda_jl_kernel_programming.html#커널",
    "href": "src/gpu/cuda_jl_kernel_programming.html#커널",
    "title": "CUDA.jl 커널 프로그래밍",
    "section": "",
    "text": "CPU 에서 호출하고 GPU 에서 실행되는 함수를 커널(kernel) 이라고 한다. 커널은 보통의 julia 함수처럼 정의한다.\nfunction my_kernel()\n    return\nend\n커널을 실행하기 위해서는 @cuda 매크로를 사용한다.\n@cuda my_kernel\n위의 명령을 실행하면 my_kernel 함수가 컴파일되며 현재의 GPU 에서 실행된다.\n\n@cuda 매크로에 launch=false 인자를 전달하면 컴파일만 되고 실행하지 않으며 호출 가능한 객체를 리턴한다.\njulia&gt; k = @cuda launch=false my_kernel()\nCUDA.HostKernel for my_kernel()\n\njulia&gt; CUDA.registers(k)\n4\n\njulia&gt; k()",
    "crumbs": [
      "GPU & CUDA",
      "CUDA.jl",
      "CUDA.jl 커널 프로그래밍"
    ]
  },
  {
    "objectID": "src/gpu/cuda_jl_kernel_programming.html#커널-입력과-출력",
    "href": "src/gpu/cuda_jl_kernel_programming.html#커널-입력과-출력",
    "title": "CUDA.jl 커널 프로그래밍",
    "section": "2 커널 입력과 출력",
    "text": "2 커널 입력과 출력\nGPU 커널은 반환값을 가질 수 없다. 즉 항상 return 이거나 return nothing 이어야 한다. 커널과 통신하는 유일한 방법은 CuArray 를 쓰는 것 뿐이다.\nfunction my_kernel(a)\n    a[1] = 42\n    return\nend\n\na = CuArray{Int}(undef, 1);\n@cuda my_kernel(a);\na\n42",
    "crumbs": [
      "GPU & CUDA",
      "CUDA.jl",
      "CUDA.jl 커널 프로그래밍"
    ]
  },
  {
    "objectID": "src/gpu/cuda_jl_kernel_programming.html#커널-구동-설정과-인덱싱",
    "href": "src/gpu/cuda_jl_kernel_programming.html#커널-구동-설정과-인덱싱",
    "title": "CUDA.jl 커널 프로그래밍",
    "section": "3 커널 구동 설정과 인덱싱",
    "text": "3 커널 구동 설정과 인덱싱\n@cuda 를 통해 커널을 구동하면 단일 스레드만 시작되므로 그다지 유용하지 않다. (cuda?) 에 대한 threads 및 blocks 키워드 인수를 사용하면 다수의 스레드를 구동할 수 있으며, 커널 내에서는 인덱싱 내장 함수를 사용하여 각 스레드의 계산을 차별화 할 수 있다.\nfunction my_kernel(a)\n    i = threadIdx().x\n    a[i] = 42\n    return\nend\n\na = CuArray{Int}(undef, 5);\n@cuda threads=length(a) my_kernel(a);\na\n5-element CuArray{Int64, 1, CUDA.DeviceMemory}:\n 42\n 42\n 42\n 42\n 42\n위에 표시된 대로, CUDA C 의 threadIdx 등의 값은 x, y, z 필드가 있는 NamedTuple 을 반환하는 함수로 사용할 수 있다. 이런 내장 함수는 1 부터 시작하는 인덱스를 반환한다.",
    "crumbs": [
      "GPU & CUDA",
      "CUDA.jl",
      "CUDA.jl 커널 프로그래밍"
    ]
  },
  {
    "objectID": "src/gpu/cuda_jl_kernel_programming.html#커널-컴파일-요건",
    "href": "src/gpu/cuda_jl_kernel_programming.html#커널-컴파일-요건",
    "title": "CUDA.jl 커널 프로그래밍",
    "section": "4 커널 컴파일 요건",
    "text": "4 커널 컴파일 요건\n사용자 정의 커널이 작동하기 위해서는 어떤 요건을 충족해야 한다.\n\n메모리는 GPU에서 접근 가능해야 한다. 이는 CuArray 등을 사용하여 강제할 수 있다. 사용자 지정 구조체는 해당 튜토리얼에서 설명한 대로 이식할 수 있다.\n런타임 디스패치는 불가하며 모든 함수 호출은 컴파일 타임에 결정되어야 합니다. 여기서 런타임 디스패치는 완전히 특정되지 않은 함수에 의해 도입될 수도 있다는 점에 유의해야 한다. Julia 매뉴얼 을 참고하고 다음 예를 보자.\n\nfunction my_inner_kernel!(f, t) # does not specialize\n    t .= f.(t)\nend\n\nfunction my_outer_kernel(f, a)\n    i = threadIdx().x\n    my_inner_kernel!(f, @view a[i, :])\n    return nothing\nend\n\na = CUDA.rand(Int, (2,2))\nid(x) = x\n\n@cuda threads=size(a, 1) my_outer_kernel(id, a)\n마지막 줄 실행에서 에러가 발생하는데 이는 아래와 같이 회피 할 수 있다.\nfunction my_inner_kernel!(f::F, t::T) where {F,T}\n    t .= f.(t)\nend\n\nfunction my_outer_kernel(f, a)\n    i = threadIdx().x\n    my_inner_kernel!(f, @view a[i, :])\n    return nothing\nend\n\na = CUDA.rand(Int, (2,2))\n\nid(x) = x\n\n@cuda threads=size(a, 1) my_outer_kernel(id, a)\n단지 첫번째 함수 my_inner_kernel! 의 인자의 함수가 파라미터로 특정되었을 뿐이다.",
    "crumbs": [
      "GPU & CUDA",
      "CUDA.jl",
      "CUDA.jl 커널 프로그래밍"
    ]
  },
  {
    "objectID": "src/gpu/cuda_jl_kernel_programming.html#동기화-synchronization",
    "href": "src/gpu/cuda_jl_kernel_programming.html#동기화-synchronization",
    "title": "CUDA.jl 커널 프로그래밍",
    "section": "5 동기화 (Synchronization)",
    "text": "5 동기화 (Synchronization)\n블록에서 스레드를 동기화하려면 sync_threads() 함수를 사용한다. predicate 를 취하는 보다 고급 변형도 사용 가능하다.\n\nsync_threads_count(pred) : pred 가 true 인 스레드의 갯수를 반환한다.\nsync_threads_and(pred) : 모든 스레드에서 pred 가 참이면 true 를 반환한다.\nsync_threads_or(pred) : 어떤 스레드에서 pred 가 참이면 true 를 반환한다.\n\n여러 스레드 동기화 장벽을 유지하려면 장벽을 식별하는 정수 인수를 취하는 barrier_sync 함수를 사용한다.\n워프에서 레인을 동기화하려면 sync_warp() 함수를 사용합니다. 이 함수는 참여할 레인을 선택하는 마스크를 취합니다(기본값은 FULL_MASK).\n실행 장벽이 아닌 메모리 장벽만 필요한 경우 펜스 내장 함수를 사용합니다.\n\nthreadfence_block : 블럭 내의 모든 쓰레드에서 메모리 정렬을 보장한다.\nthreadfence : 디바이스 내의 모든 쓰레드에서 메모리 정렬을 보장한다.\nthreadfence_system : 호스트 스레드와 peer 디바이스를 포함한 모든 스레드에서 메모리 정렬을 보장한다.\n\n\n\n공유 메모리 (Shared memory)\n스레드 간 통신을 위해 공유 메모리로 백업된 디바이스 배열은 CuStaticSharedArray 함수를 통해 할당될 수 있다. 다음은 배열의 순서를 바꾸는 커널이다. 커널 내의 b 가 스레드간 통신을 위해 공유 메모리로 백업된 배열이다.\nfunction reverse_kernel(a::CuDeviceArray{T}) where T\n    i = threadIdx().x\n    b = CuStaticSharedArray(T, 2)\n    b[2-i+1] = a[i]\n    sync_threads()\n    a[i] = b[i]\n    return\nend\n\na = cu([1,2])\n@cuda threads = 2 reverse_kernel(a)\n결과를 출력해보면 a 의 순서가 바뀌었음을 알 수 있다.\n\n공유 메모리의 크기를 미리 알 수 없고 각 크기에 대해 커널을 다시 컴파일하고 싶지 않은 경우 대신 CuDynamicSharedArray 타입을 사용할 수 있다. 이를 위해서는 공유 메모리의 크기(바이트)를 커널에 인수로 전달해야 한다.\nfunction reverse_kernel(a::CuDeviceArray{T}) where T\n    i = threadIdx().x\n    b = CuDynamicSharedArray(T, length(a))\n    b[length(a)-i+1] = a[i]\n    sync_threads()\n    a[i] = b[i]\n    return\nend\n\na = cu([1,2,3])\n@cuda threads=length(a) shmem=sizeof(a) reverse_kernel(a)\n동적 공유 메모리를 사용하는 다수의 배열이 필요한 경우 후속 CuDynamicSharedArray 생성자에 공유 메모리 시작부터 바이트 단위의 오프셋을 나타내는 오프셋 매개변수를 전달한다. @cuda 에 대한 shmem 키워드는 모든 배열에서 사용하는 총 공유 메모리 양이어야 합니다.\n\n\n\n경계 확인\n기본적으로 CuDeviceArray 를 인덱싱하면 경계 검사를 수행하고 인덱스가 경계를 벗어나면 오류를 발생시키는데 이는 비용이 많이 드는 작업이므로 인덱스가 경계 내에 있다는 것이 확실하다면 일반적인 배열과 마찬가지로 @inbounds 를 사용 할 수 있다.",
    "crumbs": [
      "GPU & CUDA",
      "CUDA.jl",
      "CUDA.jl 커널 프로그래밍"
    ]
  },
  {
    "objectID": "src/gpu/cuda_jl_kernel_programming.html#표준-출력",
    "href": "src/gpu/cuda_jl_kernel_programming.html#표준-출력",
    "title": "CUDA.jl 커널 프로그래밍",
    "section": "6 표준 출력",
    "text": "6 표준 출력\nCUDA.jl 커널은 아직 Julia의 표준 입출력과 통합되지 않았지만 커널에서 표준 출력으로 인쇄하기 위한 몇 가지 기본 기능을 제공한다.\n\n@cuprintf: 표준 출력으로 형식화된 출력을 내보낸다.\n@cuprint 와 @cuprintln : 문자를 포함한 값을 표준 출력으로 내보낸다.\n@cushow : 객체의 이름과 값을 출력한다.\n\n@cuprintf 매크로는 모든 형식 옵션을 지원하지 않는다. 자세한 내용은 printf 에 대한 NVIDIA 설명서를 참조하라. @cuprintln 과 CUDA.jl 을 통해 모든 값을 적절한 문자열 표현으로 변환하는 것이 더 편리한 경우가 많다.\njulia&gt; @cuda threads=2 (()-&gt;(@cuprintln(\"Hello, I'm thread $(threadIdx().x)!\"); return))()\nHello, I'm thread 1!\nHello, I'm thread 2!\n 단순히 값만 출력하길 원한다면, which can be useful during debugging, @cushow 를 사용하라.\njulia&gt; @cuda threads=2 (()-&gt;(@cushow threadIdx().x; return))()\n(threadIdx()).x = 1\n(threadIdx()).x = 2\n이것들은 매우 제한된 수의 유형만 지원한다는 점에 유의하라. 따라서 디버깅 목적으로만 사용하는 것이 좋다.",
    "crumbs": [
      "GPU & CUDA",
      "CUDA.jl",
      "CUDA.jl 커널 프로그래밍"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Science & Programming",
    "section": "",
    "text": "Julia 프로그래밍 언어 : Julia 언어\nJulia 언어를 이용한 수치해석 : 수치해석과 이미지 처리에 대해 다룹니다."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\ndfkl"
  },
  {
    "objectID": "src/gpu/cuda_jl_array_programming.html",
    "href": "src/gpu/cuda_jl_array_programming.html",
    "title": "CUDA.jl 배열 처리",
    "section": "",
    "text": "필요한 패키지는 다음과 같다.",
    "crumbs": [
      "GPU & CUDA",
      "CUDA.jl",
      "CUDA.jl 배열 처리"
    ]
  },
  {
    "objectID": "src/gpu/cuda_jl_array_programming.html#cuarray-타입",
    "href": "src/gpu/cuda_jl_array_programming.html#cuarray-타입",
    "title": "CUDA.jl 배열 처리",
    "section": "1 CuArray 타입",
    "text": "1 CuArray 타입\n\n기본 연산\nCUDA.jl 의 기본적인 타입은 CuArray 타입으로 Array 타입과 많은 부분에서 비슷하다. 우선 CPU 에서 만든 배열을 GPU 의 CuArray 타입으로 전환시켜 보자.\ncarr0 = CuArray(rand(Float32, 128, 128))\n결과는 다음과 같다. CPU 에서 128 x 128 랜덤 배열을 만든 후 GPU 에서의 CuArray 타입으로 변환시켰다. 아래로의 많은 줄이 생략되었다.\n128×128 CuArray{Float32, 2, CUDA.DeviceMemory}:\n 0.614408   0.545875   0.716857   …  0.25018    0.304857   0.99422\n 0.432157   0.148661   0.060947      0.0701835  0.15738    0.26359\n\n기본적인 사용법도 눈여겨보라.\ncarr1 = CuArray{Float32}(undef,  1024)\ncarr2 = fill!(copy(carr1), 0f0)\n@test carr2 == CUDA.zeros(Float32, 1024)\n\nCuArray 에 많은 배열 연산을 수행 할 수 있다.\ncarr3 = carr1.^2 + carr2.^2\ncarr4 = map(cos, carr1)\ncarr5 = reduce(+, carr1)\n\nArray 와 같이 논리 연산을 통해 성분을 선택 할 수 있다.\nc1 = CuArray([1,2,3,4,5])\nc2 = c1[[true, false, false, true, true]]\n3-element CuArray{Int64, 1, CUDA.DeviceMemory}:\n 1\n 4\n 5\n\n이 외의 중요한 연산을 수행해보자. 모두 Array 에서와 같이 작동한다.\nfindall(isodd, c1)\nfindfirst(isodd, c1)\nfindmin(c1)\n\nreshape, view 와 같은 것도 Array 와 똑같이 동작한다.\nc2 = CuArray{Int32}(collect(1:6))\nc3 = reshape(c2, 2, 3)\nc4 = view(c2, 2:4)\n\n\n\n스칼라 인덱싱\n다음은 Array 에서와 달리 경고를 발생시킨다.\na = CuArray([1])\na[1]+=1\n┌ Warning: Performing scalar indexing on task Task (runnable, started) @0x000075014b772400.\n│ Invocation of getindex resulted in scalar indexing of a GPU array.\n│ This is typically caused by calling an iterating implementation of a method.\n│ Such implementations *do not* execute on the GPU, but very slowly on the CPU,\n│ and therefore should be avoided.\n│ \n│ If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`\n│ to enable scalar iteration globally or for the operations in question.\n└ @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:149\n배열의 개별 원소에 인덱스를 이용하여 접근하는 것을 스칼라 인덱싱이라고 한다. Array 에서의 경우는 아무 문제가 없지만 CuArray 의 경우는 위의 경고 메시지에서 나오듯이 큰 성능 하락을 불러일으킬 수 있다. Julia REPL 이나 jupyter 와 같은 상호작용 세션에서는 한번 경고를 발생시키고 수행하며, 이후에는 경고도 없이 수행하지만 실행 프로그램 상에서라면 에러를 발생시킨다. 아래의 코드를 파일로 저장하고 실행시켜보라.\n#! /usr/bin/env julia\nusing CUDA\n\na = CuArray([1])\na[1]=3\n아래와 같은 에러메시지가 출력된다.\nERROR: LoadError: Scalar indexing is disallowed.\nInvocation of setindex! resulted in scalar indexing of a GPU array.\n...\n스칼라 인덱싱을 허용하려면 @arrowscalar 매크롤르 사용한다.\nCUDA.@allowscalar a[1] += 1",
    "crumbs": [
      "GPU & CUDA",
      "CUDA.jl",
      "CUDA.jl 배열 처리"
    ]
  },
  {
    "objectID": "src/gpu/cuda_jl_array_programming.html#고급-기능",
    "href": "src/gpu/cuda_jl_array_programming.html#고급-기능",
    "title": "CUDA.jl 배열 처리",
    "section": "2 고급 기능",
    "text": "2 고급 기능\n\n난수 발생\nCUDA 에서 제공하는 난수발생기를 사용 할 수 있다.\nCUDA.randn(Float64, 2, 1)\nCUDA 는 난수발생 모듈인 CURAND 를 포함하며 CURAND 는 lognormal 분포나 푸아송 분포에 대한 난수발생을 제공한다.\nCUDA.rand_logn(Float32, 1, 5; mean=2, stddev=20)\nCUDA.rand_poisson(UInt32, 1, 10; lambda=100)\n\n\n\n선형 대수\nCUDA 에는 자체 선형 대수 모듈인 CUBLAS 가 포함되어 있고 관련 함수들이 Julia 의 표준 선형 대수 모듈인 LinearAlgebra 에 포함되어 있다. 즉 LinearAlgebra 모듈을 통해 CuArray 에 대한 선형 대수 계산을 GPU 에서 수행 할 수 있다.\nC1= CuArray{Float32}([5 -1; -1 4]);\nlu(C1)\nLU{Float32, CuArray{Float32, 2, CUDA.DeviceMemory}, CuArray{Int32, 1, CUDA.DeviceMemory}}\nL factor:\n2×2 CuArray{Float32, 2, CUDA.DeviceMemory}:\n  1.0  0.0\n -0.2  1.0\nU factor:\n2×2 CuArray{Float32, 2, CUDA.DeviceMemory}:\n 5.0  -1.0\n 0.0   3.8\n CUBLAS에 존재하지만 (아직) LinearAlgebra 표준 라이브러리의 고수준 constructs 에 포함되지 않은 연산은 CUBLAS 서브모듈로 직접 접근 할 수 있다. 많은 연산이(예: cublasDdot) 더 상위 수준의 wrapper (예: dot) 를 사용할 수 있으므로 C 래퍼를 직접 호출할 필요가 없다.\nc1 = CuArray{Float32}([1, 2])\nCUBLAS.dot(2, c1, c1)\n5.0f0\n\n\n\nSolver\n선형 시스템의 해를 구하는 LAPACK 유사 기능은 CUDA 에 포함된 CUSOLVER 에 포함되어 있으며 LinearAlgebra 표준 라이브러리의 메서드를 통해서 접근 할 수 있다.\nA = CUDA.rand(3, 3)\nA = A * A'\ncholesky(A)\nCholesky{Float32, CuArray{Float32, 2, CUDA.DeviceMemory}}\nU factor:\n3×3 UpperTriangular{Float32, CuArray{Float32, 2, CUDA.DeviceMemory}}:\n 0.685254  0.386212  0.527034\n  ⋅        0.977934  0.542067\n  ⋅         ⋅        0.182822\n\nA = CUDA.rand(3, 3)\nb = CUDA.rand(3)\nx=A\\b\n3-element CuArray{Float32, 1, CUDA.DeviceMemory}:\n  1.9668096\n  4.2866626\n -1.7602696\nA*x-b\n3-element CuArray{Float32, 1, CUDA.DeviceMemory}:\n  2.9802322f-8\n -2.2351742f-8\n -2.7939677f-9\n\n\n\n희소 행렬\nCUDA 에 포함된 CUSPARSE 라이브러리를 통해 희소행렬을 다룰 수 있다. CUSPARSE 에서 희소행렬은 주로 CuSparseArray 객체를 사용하며 이 객체의 기능은 SparseArrays 패키지를 통해서도 접근 할 수 있다.\nsp1=sprand(10, 0.2)\ncsp1 = CuSparseVector(sp1)\n10-element CuSparseVector{Float64, Int32} with 2 stored entries:\nsparsevec(Int32[1, 2], [0.12468759985600719, 0.5027074361089312], 10)\n\n\n\nFFT\nCUDA 에는 고속 이산 푸리에 변환(FFT) 를 수행하는 CUFFT 가 포함되어 있으며 CUFFT 서브모듈로 접근한다. 사용법은 다음 절의 벤치마크 를 참고하라.\n\n\n\n벤치마크\n2차원 푸리에 변환에 대한 수행 시간을 확인해 보자.\nd1 = rand(Float32, 2048, 2048);\nc1 = CuArray(d1);\n@benchmark fft(d1)\nBenchmarkTools.Trial: 26 samples with 1 evaluation.\n Range (min … max):  115.318 ms … 233.668 ms  ┊ GC (min … max): 0.00% … 1.47%\n Time  (median):     187.126 ms               ┊ GC (median):    1.84%\n Time  (mean ± σ):   195.700 ms ±  36.154 ms  ┊ GC (mean ± σ):  1.59% ± 0.57%\n\n@benchmark CUDA.@sync fft($c1)\nBenchmarkTools.Trial: 6485 samples with 1 evaluation.\n Range (min … max):  433.504 μs …  11.076 ms  ┊ GC (min … max): 0.00% … 18.69%\n Time  (median):     741.453 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   765.796 μs ± 767.649 μs  ┊ GC (mean ± σ):  1.96% ±  1.84%",
    "crumbs": [
      "GPU & CUDA",
      "CUDA.jl",
      "CUDA.jl 배열 처리"
    ]
  },
  {
    "objectID": "src/gpu/cuda_jl_array_programming.html#메모리-관리",
    "href": "src/gpu/cuda_jl_array_programming.html#메모리-관리",
    "title": "CUDA.jl 배열 처리",
    "section": "3 메모리 관리",
    "text": "3 메모리 관리\n다음을 보자\na1 = [1.0, 2.0, 3.0]\nca1 = CuArray{Float32}(a1)\na1 은 메모리상의 배열로, a1 에 대한 처리는 CPU 가 담당한다. 우리는 관례를 따라 앞으로 CPU 와 메인 메모리를 합쳐 host 라고 부르기로 하자. ca1 = CuArray{Float32}(a1) 은 a1 의 배열을 Float32 로 바꾸어 GPU 의 메모리로 옮긴다. GPU 와 GPU 의 메모리 등을 합쳐 device 라고 부르자. 굳이 Float32 타입으로 바꾸는 이유는 GPU 에서는 Float32 형식의 부동소수 연산이 Float64 보다 훨씬 빠르기 때문이다. Float64 타입이 무조건 필요한 경우가 아니라면 보통 Float32 를 사용한다. 이렇게 host 에서 device 로 데이터를 옮기는 것을 upload, device 에서 host 로 옮기는 것을 download 라고 하자.\n\n\n타입 보존 upload\nharr = Diagonal([1.0,2,3])\n여기서 harr 은 host 의 Float64 타입 희소행렬이다. 이것을 GPU 로 업로드 할 때\nCuArray(harr)\n라고 하면 CuArray{Float64} 타입 배열이 된다. Float32 타입으로 바꾸기 위해\nCuArray{Float64}(harr)\n라고 해도 되고 CUDA.jl 의 cu 함수를 이용해도 된다.\ncu(harr)\n\n\n\n통합 메모리\nCuArray 생성자와 cu 함수는 기본적으로 GPU에서만 액세스할 수 있는 장치 메모리를 할당한다. CPU 와 GPU 모두 접근할 수 있는 통합 메모리(Unified memory) 가 있으며 장치 드라이버가 데이터의 이동을 관장한다. 즉 필요에 따리 CPU 와 GPU 메모리에 존재하며 전송된다. 1 차원 배열에 대한 통합메모리는 다음과 같이 사용 할 수 있다. 아래에서 carr1, carr2, carr3 는 모두 같다.\narr1 = [1, 2, 3]\ncarr1 = CuArray{Float32, 1, CUDA.UnifiedMemory}(arr1)\ncarr2 = CuVector{Float32, CUDA.UnifiedMemory}(arr1)\ncarr3 = cu(arr1; unified=true)\n2차원 베열에 대한 통합메모리는 다음과 같이 사용 할 수 있다. 역시 cmat1, cmat2, cmat3 는 모두 같다.\nmat1 = [1 2; 3 4]\ncmat1 = CuMatrix{Float32, CUDA.UnifiedMemory}(mat1)\ncmat2 = CuArray{Float32, 2, CUDA.UnifiedMemory}(mat1)\ncmat3 = cu(mat1, unified=true)\n이렇게 하면 CPU 코드를 실행하거나 AbstractArray 로의 폴백(fallback)을 트리거하는 것에 대해 걱정할 필요 없이 애플리케이션의 일부를 점진적으로 포팅할 수 있으므로 코드를 GPU로 포팅하는 것이 상당히 쉬워질 수 있다. 그러나 통합 메모리는 GPU 메모리에서 페이지 인 혹은 페이지 아웃 을 해야 하며 비동기적으로 할당할 수 없으므로 이에 대한 비용이 발생할 수 있다. 이 비용을 줄이기 위해 CUDA.jl 은 커널에 전달할 때 통합 메모리를 prefetch 한다.\n최신 시스템(오픈소스 NVIDIA 드라이버가 있는 CUDA 12.2)에서는 CuArray 생성자나 cu 함수를 사용하여 통합 메모리를 명시적으로 할당하지 않고도 GPU에서 CPU 메모리에 액세스하여 그 반대의 작업도 가능하다.\njulia&gt; cpu = [1,2];\n\njulia&gt; gpu = unsafe_wrap(CuArray, cpu)\n2-element CuArray{Int64, 1, CUDA.UnifiedMemory}:\n 1\n 2\n\njulia&gt; gpu .+= 1;\n\njulia&gt; cpu\n2-element Vector{Int64}:\n 2\n 3\n현재 CUDA.jl은 여전히 ​​장치 메모리를 할당하는 것을 기본으로 하지만, 이는 향후 변경될 수 있습니다. 기본 동작을 변경하려면 default_memory 기본 설정을 device 대신 unified 또는 host로 설정할 수 있습니다.",
    "crumbs": [
      "GPU & CUDA",
      "CUDA.jl",
      "CUDA.jl 배열 처리"
    ]
  },
  {
    "objectID": "src/gpu/cuda_jl_performance_tips.html",
    "href": "src/gpu/cuda_jl_performance_tips.html",
    "title": "CUDA.jl 성능 팁",
    "section": "",
    "text": "CUDA.jl 의 Performance Tips 을 요약 & 번역한 것이다.",
    "crumbs": [
      "GPU & CUDA",
      "CUDA.jl",
      "CUDA.jl 성능 팁"
    ]
  },
  {
    "objectID": "src/gpu/cuda_jl_performance_tips.html#일반적인-팁",
    "href": "src/gpu/cuda_jl_performance_tips.html#일반적인-팁",
    "title": "CUDA.jl 성능 팁",
    "section": "1 일반적인 팁",
    "text": "1 일반적인 팁\n항상 코드 프로파일링부터 시작한다(자세한 내용은 profiling 페이지 참조). 먼저 CUDA.@profile 또는 NSight Systems 를 사용하여 프로그램 전체를 분석하고 핫스팟과 병목지점을 파악해야 한다. 여기에 집중하면서 다음을 수행한다.\n\nCPU와 GPU 간의 데이터 전송을 최소할 것. 불필요한 메모리 사본을 제거하고 다수의 적은 전송을 일괄적인 큰 전송으로 한다.\n문제가 있는 커널 호출을 식별한다. 단일 호출로 처리할 수 있는 수천 개의 커널을 동작시킬 수 있다.\nCPU가 GPU를 바쁘게 유지할 만큼 빠르게 작업을 제출하지 않는 스톨을 찾습니다.\n\n이것으로 충분하지 않고 느리게 실행되는 커널을 식별한 경우 NSight Compute를 사용하여 해당 커널을 자세히 분석해 볼 수 있다. 중요도 순으로 시도해야 할 몇 가지 사항은 다음과 같다.\n\n메모리 액세스를 최적한다. 예를 들어 불필요한 전역 접근(대신 공유 메모리에서 버퍼링)을 피하거나 접근을 병합한다.\n각 스트리밍 멀티프로세서(SM)에서 더 많은 스레드를 실행한다. 이는 레지스터 압력을 낮추거나 공유 메모리 사용을 줄임으로써 달성할 수 있다. 아래 팁은 레지스터 압력을 줄일 수 있는 다양한 방법을 설명한다.\nFloat64 및 Int/Int64 와 같은 64비트 유형 대신 Float32 및 Int32 와 같은 32비트 타입을 사용한다.\n같은 워프의 스레드가 갈라지는 원인이 되는 제어 흐름 사용을 피하세요. 즉, while 또는 for 루프가 전체 워프에서 동일하게 동작하도록 하고, 워프 내에서 갈라지는 if 를 if else 로 바꾼다.\nGPU가 메모리 액세스의 지연 시간을 숨길 수 있도록 계산 강도를 높인다.\n\n\n\nInlining\nInlining 은 레지스터 사용을 줄여 커널 속도를 높일 수 있다. 모든 함수의 인라인을 강제로 실행하려면 @cuda always_inline=true 를 사용하면 된다.\n\n\n\n쓰레드 당 최대 레지스터 개수를 제한한다.\n시작할 수 있는 스레드 수는 부분적으로 커널이 사용하는 레지스터 수에 의해 결정된다. 이는 멀티프로세서의 모든 스레드에서 레지스터가 공유되기 때문이다. 스레드당 최대 레지스터 수를 설정하면 사용되는 레지스터가 줄어들어 스레드 수가 늘어나고 레지스터를 로컬 메모리에 분산시키는 댓가로 성능이 향상될 수 있다. 최대 레지스터 수를 32로 설정하려면 @cuda maxregs=32 라고 한다.\n\n\nFastMath\n일반적인 산술 함수의 고속 버젼을 사용하는 @fastmath 매크로를 사용할 수 있다. 다음의 매크로를 사용하라. @cuda fastmath=true",
    "crumbs": [
      "GPU & CUDA",
      "CUDA.jl",
      "CUDA.jl 성능 팁"
    ]
  },
  {
    "objectID": "src/gpu/cuda_jl_performance_tips.html#julia-전용-팁",
    "href": "src/gpu/cuda_jl_performance_tips.html#julia-전용-팁",
    "title": "CUDA.jl 성능 팁",
    "section": "2 Julia 전용 팁",
    "text": "2 Julia 전용 팁\n\n런타임 예외를 최소화한다\nJulia 에서 많은 일반적인 연산은 런타임에 Error 를 발생시킬 수 있으며, Error 는 종종 분기를 만들고 해당 분기에서 함수를 호출하는데, 이 둘 다 GPU 에서는 느리다. 배열을 인덱싱할 때 (inbounds를?) 사용하면 경계 검사로 인한 예외가 제거된다. --check-bounds=yes (Pkg.test의 기본값) 로 코드를 실행하면 항상 경계 검사가 발생한다. LLVM.jl 패키지의 assume 을 사용하여 예외를 제거할 수도 있다. 다음을 보라.\nusing LLVM.Interop\n\nfunction test(x, y)\n    assume(x &gt; 0)\n    div(y, x)\nend\nassume(x &gt; 0) 은 컴파일러에게 0 으로 나누는 에러가 발생하지 않을 것임을 말해준다.\n\n\n\n32 비트 정수\n가능하면 32비트 정수를 하용한다. 레지스터 압력의 일반적인 원인은 32비트만 필요한데 64비트 정수를 사용하는 것이다. 예를 들어, 하드웨어의 인덱스는 32비트 정수이지만 Julia의 리터럴은 Int64 로, blockIdx().x-1 과 같은 표현식은 64비트 정수로 승격된다. 32비트 정수를 사용하려면 1 을 Int32(1) 로 대체하거나 CUDA를 사용하여 실행하는 경우 더 간결하게 1i32 로 대체할 수 있다.\n이것이 얼마나 큰 차이를 만드는지 확인하기 위해 소개 튜토리얼에서 소개한 커널을 사용해 보자.\nusing CUDA, BenchmarkTools\n\nfunction gpu_add3!(y, x)\n    index = (blockIdx().x - 1) * blockDim().x + threadIdx().x\n    stride = gridDim().x * blockDim().x\n    for i = index:stride:length(y)\n        @inbounds y[i] += x[i]\n    end\n    return\nend\ngpu_add3! (generic function with 1 method)\n몇개의 레지스터가 사용되었는지 확인해보자.\nx_d = CUDA.fill(1.0f0, 2^28)\ny_d = CUDA.fill(2.0f0, 2^28)\n\nCUDA.registers(@cuda gpu_add3!(y_d, x_d))\n29\n위의 결과는 기기마다 다를 수 있다. 이제 32 비트 정수를 사용하는 커널은 아래와 같다.\nfunction gpu_add4!(y, x)\n    index = (blockIdx().x - Int32(1)) * blockDim().x + threadIdx().x\n    stride = gridDim().x * blockDim().x\n    for i = index:stride:length(y)\n        @inbounds y[i] += x[i]\n    end\n    return\nend\ngpu_add4! (generic function with 1 method)\nCUDA.registers(@cuda gpu_add4!(y_d, x_d))\n28\n따라서 32비트 정수로 전환하여 레지스터 하나를 덜 사용하게 되고, 64비트 정수를 더 많이 사용하는 커널에서는 레지스터 수가 더 크게 감소할 것으로 예상된다.\n\n\n\nStepRange 사용을 피하라\nfor 루프의 이전 커널에서 StepRange 인 index:stride:length(y) 를 순회했다. 안타깝게도 StepRange 를 구성하는 것은 오류가 발생할 수 있고, 단순히 반복하고 싶을 경우에는 불필요한 계산을 포함하기 때문에 느립니다. 대신 다음과 같이 while 루프를 사용하는 것이 더 빠르다.\nfunction gpu_add5!(y, x)\n    index = (blockIdx().x - Int32(1)) * blockDim().x + threadIdx().x\n    stride = gridDim().x * blockDim().x\n\n    i = index\n    while i &lt;= length(y)\n        @inbounds y[i] += x[i]\n        i += stride\n    end\n    return\nend\ngpu_add5! (generic function with 1 method)\n벤치마크는\nfunction bench_gpu4!(y, x)\n    kernel = @cuda launch=false gpu_add4!(y, x)\n    config = launch_configuration(kernel.fun)\n    threads = min(length(y), config.threads)\n    blocks = cld(length(y), threads)\n\n    CUDA.@sync kernel(y, x; threads, blocks)\nend\n\nfunction bench_gpu5!(y, x)\n    kernel = @cuda launch=false gpu_add5!(y, x)\n    config = launch_configuration(kernel.fun)\n    threads = min(length(y), config.threads)\n    blocks = cld(length(y), threads)\n\n    CUDA.@sync kernel(y, x; threads, blocks)\nend\nbench_gpu5! (generic function with 1 method)\n@btime bench_gpu4!($y_d, $x_d)\n  76.149 ms (57 allocations: 3.70 KiB)\n@btime bench_gpu5!($y_d, $x_d)\n  75.732 ms (58 allocations: 3.73 KiB)\n이 벤치마크는 이 커널에 대한 성능 이점에서는 미미하지만 StepRange 를 사용할 때 28개의 레지스터가 사용되었다는 점을 상기하면 사용된 레지스터의 양에 큰 차이가 있음을 확인 할 수 있다.\nCUDA.registers(@cuda gpu_add5!(y_d, x_d))\n12",
    "crumbs": [
      "GPU & CUDA",
      "CUDA.jl",
      "CUDA.jl 성능 팁"
    ]
  },
  {
    "objectID": "src/tools/Asymptote/asymptote.html",
    "href": "src/tools/Asymptote/asymptote.html",
    "title": "Asymptote",
    "section": "",
    "text": "1 Examples\nimport graph;\nimport geometry;\nimport math;\nimport settings;\nimport fontsize;\n\n\nsettings.outformat = \"pdf\";\ndefaultpen(fontsize(17pt));\ndefaultpen(1);\n\nsize(400,300,IgnoreAspect);\n\nreal a=1, b=1.5, c=2;\nreal ya=1.0, yb=2.4, yc=3.0;\nreal yb2=2.6, yb3=2.2;\nint t=2;\n\nreal f(real x) {\n    real r1=(x-b)*(x-c)/(a-b)/(a-c)*ya ;\n    r1 += (x-a)*(x-c)/(b-a)/(b-c)*yb;\n    r1 += (x-a)*(x-b)/(c-a)/(c-b)*yc;\n    return r1;\n    }\n\nreal f2(real x) {\n    real r1=(x-b)*(x-c)/(a-b)/(a-c)*ya ;\n    r1 += (x-a)*(x-c)/(b-a)/(b-c)*yb2;\n    r1 += (x-a)*(x-b)/(c-a)/(c-b)*yc;\n    return r1;\n    }\nreal f3(real x) {\n    real r1=(x-b)*(x-c)/(a-b)/(a-c)*ya ;\n    r1 += (x-a)*(x-c)/(b-a)/(b-c)*yb3;\n    r1 += (x-a)*(x-b)/(c-a)/(c-b)*yc;\n    return r1;\n    }\n\npair F(real x) {return (x,f(x));}\n\ndotfactor=7;\n\nxaxis(\"$t$\", xmin=0.5, xmax=2.5, Arrow, ticks=Ticks(DefaultFormat,\n                                        new real[] {1, 2}));\nyaxis(\"$P$\", XEquals(0.7), ymin=-0.2, ymax=4, Arrow);\n\npath g=graph(f,a,c);\npath g2=graph(f2,a,c);\npath g3=graph(f3,a,c);\n\ndraw(g,black);   \ndraw(g2,blue+dashed);  \ndraw(g3,dashed+red);  \n\nint n=2;\n\n\n\ndot(Label(\"$P_1$\",align=W), F(a));\ndot(Label(\"$P_2$\",align=E), F(c));\n\n\n\nEuler Lagrange",
    "crumbs": [
      "Tools",
      "Asymptote"
    ]
  },
  {
    "objectID": "src/tools/tikz/tikz_functions.html",
    "href": "src/tools/tikz/tikz_functions.html",
    "title": "tikz function plots in Quarto",
    "section": "",
    "text": "코드\n```{r, engine = 'tikz'}\n#| label: fig-linear_approximation\n#| code-fold: true\n#| output: asis\n#| fig-width: 3\n#| fig-align: center\n#| fig-cap: \"tikz in Quarto 예시\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{decorations.pathreplacing}\n\n\\begin{tikzpicture}\n\\draw[very thin,color=gray] (-0.1,-0.1) grid (4.2,5.2);\n\n\\draw[-&gt;] (-0.6, 0) -- (4.2,0) node[right] {$x$};\n\\draw[-&gt;] (0,-0.6) -- (0,5.2) node[above] {$y$};\n\n\\foreach \\x in {1,...,8}\n{\n  \\draw[thin] (\\x / 2, 0.05) -- (\\x /2, -0.05);\n  }\n\n\\foreach \\x in {2, 4, 6, 8}\n{\n  \\node[below]  at (\\x /2 , -0.05) {$\\x$};\n  }\n\n\\foreach \\y in {1,...,9}\n{\n  \\draw[thin] (0.05 , \\y / 2) -- (-0.05 , \\y /2);\n  }\n\n\\foreach \\y in {2, 4, 6, 8, 10}\n{\n  \\node[left]  at (-0.05, \\y / 2) {$\\y$};\n  }\n\n\\filldraw[black] (0.5,1.1 /2) circle (2pt);\n\\filldraw[black] (2/2, 1.65 /2) circle (2pt);\n\\filldraw[black] (3/2, 3.43/2) circle (2pt);\n\\filldraw[black] (4/2, 4.02/2) circle (2pt);\n\\filldraw[black] (5/2, 4.58/2) circle (2pt);\n\\filldraw[black] (6/2, 5.78/2) circle (2pt);\n\\filldraw[black] (7/2, 7.32/2) circle (2pt);\n\n\\draw[thick, dashed, red] (0, 0) -- (3.8, 3.8);\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 1: tikz in Quarto 예시\n\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-Chevyshev_polynoimal\n#| code-fold: true\n#| output: asis\n#| fig-width: 4\n#| fig-align: center\n#| fig-cap: \"Chevyshev 다항식\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{decorations.pathreplacing}\n\n\\begin{tikzpicture}[domain=-1:1, samples = 100, scale=3]\n\n\\draw[-{stealth}] (-1.2, 0) -- (1.2,0) node[right] {$x$};\n\\draw[-{stealth}] (0,-1.2) -- (0,1.2) node[above] {$y$};\n\\node[left, scale=0.8] at (0, 1) {$1$};\n\\node[left, scale=0.8] at (0, -1) {$-1$};\n\\node[below, scale=0.8] at (-1, 0) {$-1$};\n\\node[below, scale=0.8] at (1, 0) {$1$};\n\n\\foreach \\x in {-5,...,5}\n{\n  \\draw[thin] (\\x / 5, 0.02) -- (\\x /5, -0.02);\n  }\n\n\\foreach \\y in {-5,...,5}\n{\n  \\draw[thin] (0.02 , \\y / 5) -- (-0.02 , \\y /5);\n  }\n\n\\draw[color=black]   plot (\\x, \\x) ;\n\\node[above, black] at (0.7, 0.73) {$T_1(x)$};\n\\draw[color=blue]   plot (\\x, 2 * \\x * \\x - 1);\n\\node[below right, blue] at (0, -1) {$T_2(x)$};\n\\draw[color=red]   plot (\\x, 4 * \\x * \\x * \\x - 3* \\x);\n\\node[above, red] at (-0.5, 1) {$T_3(x)$};\n\\draw[color=teal]   plot (\\x, 8 * \\x * \\x * \\x * \\x - 8* \\x * \\x + 1);\n\\node[right, teal] at (0.2, 0.8) {$T_4(x)$};\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 2: Chevyshev 다항식\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-Legendre_polynoimal\n#| code-fold: true\n#| output: asis\n#| fig-width: 4\n#| fig-align: center\n#| fig-cap: \"Legendre 다항식\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{decorations.pathreplacing}\n\n\\begin{tikzpicture}[domain=-1:1, samples = 100, scale=3]\n\n\\draw[-{stealth}] (-1.2, 0) -- (1.2,0) node[right] {$x$};\n\\draw[-{stealth}] (0,-1.2) -- (0,1.2) node[above] {$y$};\n\\node[left, scale=0.8] at (0, 1) {$1$};\n\\node[left, scale=0.8] at (0, -1) {$-1$};\n\\node[below, scale=0.8] at (-1, 0) {$-1$};\n\\node[below, scale=0.8] at (1, 0) {$1$};\n\n\\foreach \\x in {-5,...,5}\n{\n  \\draw[thin] (\\x / 5, 0.02) -- (\\x /5, -0.02);\n  }\n\n\\foreach \\y in {-5,...,5}\n{\n  \\draw[thin] (0.02 , \\y / 5) -- (-0.02 , \\y /5);\n  }\n\n\\draw[color=black]   plot (\\x, 1.5 * \\x * \\x - 0.5 ) ;\n\\node[above, black] at (-0.7, 0.73) {$P_2(x)$};\n\\draw[color=blue]   plot (\\x, 2.5 * \\x * \\x * \\x - 1.5 * \\x);\n\\node[above, blue] at (-0.5, 0.4) {$P_3(x)$};\n\\draw[color=red]   plot (\\x, 35/8 * \\x * \\x * \\x *\\x - 30 / 8 * \\x *\\x + 3/8 );\n\\node[red] at (-0.5, -0.5) {$P_4(x)$};\n\\draw[color=teal]   plot (\\x, 63/8 * \\x * \\x * \\x * \\x * \\x - 70/8* \\x * \\x * \\x + 15/8 * \\x);\n\\node[right, teal] at (0.2, 0.5) {$P_5(x)$};\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 3: Legendre 다항식",
    "crumbs": [
      "Tools",
      "tikz function plots in Quarto"
    ]
  },
  {
    "objectID": "src/tools/tikz/tikz_pde.html",
    "href": "src/tools/tikz/tikz_pde.html",
    "title": "tikz in PDE",
    "section": "",
    "text": "그리드와 직선의 두께\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-pde_grid\n#| code-fold: true\n#| output: asis\n#| fig-width: 8\n#| fig-align: center\n#| fig-cap: \"2차원 그리드\"\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}\n\n\n\\draw[-{stealth}] (-1., 0) -- (8,0) node[right] {$x$};\n\\draw[-{stealth}] (0,-1) -- (0,6) node[above] {$y$};\n\n\\foreach \\x in {2,3,4,5,7} {\n  \\draw[] (\\x, 1) -- (\\x, 5); \n  \\draw[] (\\x, 0.1) -- (\\x, -0.1);\n}\n\\foreach \\y in {1,2,3,5} {\n  \\draw[] (2, \\y) -- (7, \\y);\n  \\draw[] (0.1, \\y) -- (-0.1, \\y);\n}\n\n\\node[below, scale=0.8] at (2, -0.1) {$x_0=a$};\n\\node[below, scale=0.8] at (3, -0.1) {$x_1$};\n\\node[below, scale=0.8] at (4, -0.1) {$x_2$};\n\\node[below, scale=0.8] at (5, -0.1) {$x_3$};\n\\node[below, scale=0.8] at (7, -0.1) {$x_N=b$};\n\n\\node[left, scale=0.8] at (-0.1, 1) {$y_0=c$};\n\\node[left, scale=0.8] at (-0.1, 2) {$y_1$};\n\\node[left, scale=0.8] at (-0.1, 3) {$y_2$};\n\\node[left, scale=0.8] at (-0.1, 5) {$y_M=d$};\n\n\\node[] at (6, 1.5) {$\\cdots$};\n\\node[] at (6, 2.5) {$\\cdots$};\n\\node[] at (2.5, 4) {$\\vdots$};\n\\node[] at (3.5, 4) {$\\vdots$};\n\\node[] at (4.5, 4) {$\\vdots$};\n\\node[] at (5.5, 4) {$\\vdots$};\n\\node[] at (6.5, 4) {$\\vdots$};\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 1: 2차원 그리드",
    "crumbs": [
      "Tools",
      "tikz in PDE"
    ]
  },
  {
    "objectID": "src/tools/tikz/tikz_wavelet.html",
    "href": "src/tools/tikz/tikz_wavelet.html",
    "title": "tikz Wavelet",
    "section": "",
    "text": "코드\n```{r, engine = 'tikz'}\n#| label: fig-wavelet_sharp_function_1\n#| code-fold: true\n#| output: asis\n#| fig-width: 10\n#| fig-align: center\n#| fig-cap: \"Legendre 다항식\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}[samples = 100, scale=2]\n\n\\draw[-{stealth}] (-1.5, 0) -- (1.5,0) node[right] {$t$};\n\\draw[-{stealth}] (0,0) -- (0,1.2) node[above] {$f(t)$};\n\n\\draw[color=black, thick, domain=-1:0, variable = \\t]   plot ({\\t}, {(1+\\t)});\n\\draw[color=black, thick, domain=0:1, variable = \\t]   plot ({\\t}, {(1-\\t)});\n\\draw[] (-1, 0.05) -- (-1, -0.05 ) node[below] {$-a$};\n\\draw[] (1, 0.05) -- (1, -0.05 ) node[below] {$a$};\n\n\\begin{scope}[xshift=3.5cm] \n\n\\draw[-{stealth}] (-1.5, 0) -- (1.5,0) node[right] {$\\omega$};\n\\draw[-{stealth}] (0,0) -- (0,1.2) node[above] {$\\hat{f}(\\omega)$};\n\n\\draw[color=black, thick, domain=-6:6, samples=100, variable = \\t]   plot ({\\t/5}, { (2 * sin((\\t * 180 / pi) /2)/((\\t)))^2 });\n\\draw[] (-0.2, 0.05) -- (-0.2, -0.05 ) node[below] {$-\\frac{1}{a}$};\n\\draw[] (0.2, 0.05) -- (0.2, -0.05 ) node[below] {$\\frac{1}{a}$};\n\n\\end{scope}\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 1: Legendre 다항식\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-wavelet_sharp_function_2\n#| code-fold: true\n#| output: asis\n#| fig-width: 10\n#| fig-align: center\n#| fig-cap: \"Legendre 다항식\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}[samples = 100, scale=2.5]\n\n\\draw[-{stealth}] (-1.2, 0) -- (1.22,0) node[right] {$t$};\n\\draw[-{stealth}] (0,0) -- (0,1.2) node[above] {$f(t)$};\n\n\\draw[color=black, thick, domain=-6:0, variable = \\t]   plot ({\\t/5}, {exp(\\t)});\n\\draw[color=black, thick, domain=0:6, variable = \\t]   plot ({\\t/5}, {exp(-\\t)});\n\\draw[] (-1, 0.05) -- (-1, -0.05 ) node[below] {$-5a$};\n\\draw[] (1, 0.05) -- (1, -0.05 ) node[below] {$5a$};\n\\draw[] (-0.05, 1) -- (0.05, 1 ) node[right] {$1$};\n\n\\begin{scope}[xshift=2.8cm] \n\n\\draw[-{stealth}] (-1.2, 0) -- (1.2,0) node[right] {$\\omega$};\n\\draw[-{stealth}] (0,0) -- (0,1.2) node[above] {$\\hat{f}(\\omega)$};\n\n\\draw[color=black, thick, domain=-6:6, samples=100, variable = \\t]   plot ({\\t/5}, {1/(\\t*\\t + 1)});\n\\draw[] (-0.05, 1) -- (0.05, 1 ) node[right] {$2/a$};\n\\draw[] (-0.2, 0.05) -- (-0.2, -0.05 ) node[below] {$-\\frac{1}{a}$};\n\\draw[] (0.2, 0.05) -- (0.2, -0.05 ) node[below] {$\\frac{1}{a}$};\n\n\\end{scope}\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 2: Legendre 다항식\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-wavelet_haar_wavelet\n#| code-fold: true\n#| output: asis\n#| fig-width: 10\n#| fig-align: center\n#| fig-cap: \"Haar wavelet\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}[samples = 100, scale=2.5]\n\n\\draw[-{stealth}] (-0.5, 0) -- (1.7,0) node[right] {$t$};\n\\draw[-{stealth}] (0,-1.2) -- (0,1.2) node[above] {$\\psi_H(t)$};\n\n\\draw[very thick] (-0.5, 0) -- (0, 0) -- (0, 1) -- (0.5, 1) -- (0.5, -1) -- (1, -1)-- (1, 0) -- (1.5, 0);\n\\node[] at (0, 0) [below left] {$0$};\n\\node[] at (0.5, 0) [below left] {$\\frac{1}{2}$};\n\\node[] at (1, 0) [below left] {$1$};\n\\draw[] (0.1, 1) -- (-0.1, 1) node[left] {$1$};\n\\node[] at (0, -1) [left] {$-1$};\n\n\\begin{scope}[xshift=3.3cm] \n\n\\draw[-{stealth}] (-1.2, -1) -- (1.2,-1) node[right] {$\\omega$};\n\\draw[-{stealth}] (0,-1.0) -- (0,1.2) node[above] {$|\\hat{\\psi}_H(\\omega)|$};\n\n\\draw[color=black, very thick, domain=0.01:40, samples=100, variable = \\t]   plot ({\\t/40}, {(2*(sin(\\t*180/pi/4))*(sin(\\t*180/pi/4)) / (\\t/4)-1)});\n\\draw[color=black, very thick, domain=-40:-0.01, samples=100, variable = \\t]   plot ({\\t/40}, {(-2*(sin(\\t*180/pi/4))*(sin(\\t*180/pi/4)) / (\\t/4)-1)});\n\\draw[] (0.0, -0.96) -- (0.0, -1.04 ) node[below] {$0$};\n\\draw[] (0.314, -0.96) -- (0.314, -1.04 ) node[below] {$4\\pi$};\n\\draw[] (0.628, -0.96) -- (0.628, -1.04 ) node[below] {$8\\pi$};\n\\draw[] (0.942, -0.96) -- (0.942, -1.04 ) node[below] {$12\\pi$};\n\n\\end{scope}\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 3: Haar wavelet\n\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-wavelet_convolution_of_haar_1\n#| code-fold: true\n#| output: asis\n#| fig-width: 5\n#| fig-align: center\n#| fig-cap: \"Haar wavelet\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}[samples = 100, scale=3]\n\n\\draw[-{stealth}] (-0.5, 0) -- (2.5,0) node[right] {$t$};\n\\draw[-{stealth}] (0,-0.7) -- (0,0.7) node[above] {$(\\psi_H \\ast \\phi)(t)$};\n\n\\draw[very thick] (-0.5, 0) -- (0, 0) -- (0.5, 0.5) -- (1.5, -0.5) -- (2, 0) -- (2.4, 0);\n\\node[] at (0, 0) [below left] {$0$};\n\\draw [] (0.5, 0.03) -- (0.5, -0.03) node[below] {$\\frac{1}{2}$};\n\\draw [] (1, 0.03) -- (1, -0.03) node[below] {$1$};\n\\draw [] (1.5, 0.03) -- (1.5, -0.03) node[below] {$\\frac{3}{2}$};\n\\draw [] (2, 0.03) -- (2, -0.03) node[below] {$2$};\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 4: Haar wavelet\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-wavelet_daughter_wavelet_1\n#| code-fold: true\n#| output: asis\n#| fig-width: 10\n#| fig-align: center\n#| fig-cap: \"Haar wavelet\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}[samples = 200, scale=3]\n\n\\draw[-{stealth}] (-1, 0) -- (1,0) node[right] {$t$};\n\\draw[-{stealth}] (0,-0.2) -- (0,1.2) node[above] {$\\psi_{a=1, b=0}(t)$};\n\\draw[color=black, very thick, domain=-1:1, samples=100, variable = \\t]   plot ({\\t}, {exp(-(4*\\t)^2) * cos(\\t*180/pi*10)});\n\n\n\\begin{scope}[xshift=2.3cm] \n\n\\draw[-{stealth}] (-1, 0) -- (1,0) node[right] {$t$};\n\\draw[-{stealth}] (0,-0.2) -- (0,1.2) node[above] {$\\psi_{a&gt;1, b&gt;0} (t)$};\n\n\\draw[color=black, very thick, domain=-1:1, samples=200, variable = \\t]   plot ({\\t}, {exp(-(8*(\\t-0.2))^2) * cos(2*(\\t-0.2)*180/pi*10)});\n\n\\end{scope}\n\n\\begin{scope}[xshift=4.6cm] \n\n\\draw[-{stealth}] (-1, 0) -- (1,0) node[right] {$t$};\n\\draw[-{stealth}] (0,-0.2) -- (0,1.2) node[above] {$\\psi_{a&lt;1, b&gt;0}(t)$};\n\n\\draw[color=black, very thick, domain=-1:1, samples=200, variable = \\t]   plot ({\\t}, {exp(-(2*(\\t-0.2))^2) * cos(0.5*(\\t-0.2)*180/pi*10)});\n\n\\end{scope}\n\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 5: Haar wavelet\n\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-wavelet_maxican_wavelet\n#| code-fold: true\n#| output: asis\n#| fig-width: 10\n#| fig-align: center\n#| fig-cap: \"Haar wavelet\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}[samples = 200, scale=3]\n\n\\draw[-{stealth}] (-1.1, 0) -- (1.1,0) node[right] {$t$};\n\\draw[-{stealth}] (0,-0.5) -- (0,1.2) node[above] {$\\psi_{1, 0}(t)$};\n\\draw[color=black, very thick, domain=-6:6, samples=100, variable = \\t]   plot ({\\t/6}, {(1-(\\t)^2)*exp(-\\t*\\t/2)});\n\\draw (-0.289, -0.02)-- (-0.289, 0.02) node[above, scale=0.8] {$-\\sqrt{3}$};\n\\draw (0.289, -0.02)-- (0.289, 0.02) node[above, scale=0.8] {$\\sqrt{3}$};\n\n\\begin{scope}[xshift=2.3cm] \n\n\\draw[-{stealth}] (-1.1, 0) -- (1.1,0) node[right] {$\\omega$};\n\\draw[-{stealth}] (0,-0.5) -- (0,1.2) node[above] {$\\hat{\\psi}_{1, 0} (t)$};\n\n\\draw[color=black, very thick, domain=-7:7, samples=200, variable = \\t]   plot ({\\t/7}, {\\t*\\t*exp(-\\t*\\t/2)});\n\n\\draw (-0.202, 0.02)-- (-0.202, -0.02) node[below, scale=0.8] {$-\\sqrt{2}$};\n\\draw (0.202, 0.02)-- (0.202, -0.02) node[below, scale=0.8] {$\\sqrt{2}$};\n\\end{scope}\n\n\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 6: Haar wavelet\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-wavelet_maxican_wavelet_2\n#| code-fold: true\n#| output: asis\n#| fig-width: 10\n#| fig-align: center\n#| fig-cap: \"Haar wavelet\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}[samples = 200, scale=1.2]\n\n\\draw[-{stealth}] (-6.3, 0) -- (6.3,0) node[right] {$t$};\n\\draw[-{stealth}] (0,-4) -- (0,6) node[above] {$$};\n\\draw[color=black, very thick, domain=-6:6, samples=300, variable = \\t]   plot ({\\t}, {3*(1-(\\t)^2)*exp(-\\t*\\t/2)});\n\\draw[color=red, very thick, domain=-6:6, samples=300, variable = \\t]   plot ({\\t}, { 3*sqrt(2)/sqrt(3) * (1-((\\t+2)/1.5)^2)*exp(-(((\\t+2)/1.5)^2)/2)});\n\n\\draw[color=teal, very thick, domain=-6:6, samples=300, variable = \\t]   plot ({\\t}, { 3*sqrt(4)* (1-((\\t-sqrt(2))*4)^2)*exp(-(((\\t-sqrt(2))*4)^2)/2)});\n\n\\node [left] at (-0.1, 3) {$\\psi_{1, 0}(\\omega)$};\n\\node [left, red] at (-3, 1) {$\\psi_{\\frac{3}{2}, -2}(\\omega)$};\n\\node [right, teal] at (1.5, 4) {$\\psi_{\\frac{1}{4}, -\\sqrt{2}}(\\omega)$};\n\n\\foreach \\x in {1,...,5}\n{\n  \\draw (\\x, 0.1)-- (\\x, -0.1) node[below, scale=0.8] {$\\x$};\n  \\draw (-\\x, 0.1)-- (-\\x, -0.1) node[below, scale=0.8] {$-\\x$};\n}\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 7: Haar wavelet\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-wavelet_resolution_1\n#| code-fold: true\n#| output: asis\n#| fig-width: 10\n#| fig-align: center\n#| fig-cap: \"Haar wavelet\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}[samples = 200, scale=1.2]\n\n\\draw[-{stealth}] (-0.5, 0) -- (8,0) node[right] {$t$};\n\\draw[-{stealth}] (0,-0.5) -- (0,4) node[above] {$\\omega$};\n\n\\foreach \\x in {0,...,2}\n{\n  \\draw (2*\\x +2 , 0.1)-- (2*\\x +2, 0.0) node[below, scale=0.8] {$b_\\x + a_\\x t_m$};\n  \\draw (0.1, \\x +1)-- (0.0, \\x +1) node[left, scale=0.8] {$\\omega_m/a_\\x$};\n  \\draw[dashed] (2*\\x+2, 0.0) -- (2*\\x+2, \\x+1) -- (0, \\x+1);\n}\n\n\\draw [thick, red] (1, 0.7) -- (3, 0.7) -- (3, 1.3) -- (1, 1.3) -- cycle;\n\\node [above, red, scale=0.8] at (2, 1.3) {$2a_0 \\sigma_t$};\n\\node [right, red, scale=0.8] at (3, 1.0) {$\\dfrac{2}{a_0}\\sigma_\\omega$};\n\n\\draw [thick, blue] (3.5, 1.6) -- (4.5, 1.6) -- (4.5, 2.4) -- (3.5, 2.4) -- cycle;\n\\node [above, blue, scale=0.8] at (4, 2.4) {$2a_1 \\sigma_t$};\n\\node [right, blue, scale=0.8] at (4.5, 2.0) {$\\dfrac{2}{a_1}\\sigma_\\omega$};\n\n\\draw [thick, teal] (5.8, 2) -- (5.8, 4) -- (6.2, 4) -- (6.2, 2) -- cycle;\n\\node [above, teal, scale=0.8] at (6, 4) {$2a_2 \\sigma_t$};\n\\node [right, teal, scale=0.8] at (6.2, 3.0) {$\\dfrac{2}{a_2}\\sigma_\\omega$};\n\n\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 8: Haar wavelet",
    "crumbs": [
      "Tools",
      "tikz Wavelet"
    ]
  },
  {
    "objectID": "src/topics/socket.html",
    "href": "src/topics/socket.html",
    "title": "TCP/UDP 통신",
    "section": "",
    "text": "현재의 많은 장비들은 소켓 통신을 사용하여 데이터와 정보를 주고받는다. 예전의 장비들은 RS232 나 RS485 같은 직렬 통신이나 다른 다양한 통신 방법을 사용하는 경우가 많았지만 최근의 장비들은 소켓 통신을 통해 데이터를 전송하는 경우가 많다. 여기서는 소켓 통신에 대해 짧게 알아보고 실제 구현해 보기로 하자.\n\n\n\n소켓은 같은 컴퓨터의 프로세스 사이에서, 혹은 서로 다른 컴퓨터(혹은 장비)의 프로세스 사이에서 통신을 수행할 때의 종단점 (end point)이다. 같은 컴퓨터의 프로세스 사이의 소켓에는 unix domain socket 이 있으며 다른 컴퓨터 프로세스 사이에서의 통신에는 Datagram socket 과 Streaming socket 이 있다. 각각의 네트워크 하드웨어는 사양과 내부 명령어가 다르지만 운영체제 수준에서 이를 추상화하여 서로 통신할 수 있도록 한 것이 소켓이다. 여기서는 서로 다른 컴퓨터의 프로세스간 통신에 대해서만 다루기로 한다.\n\n\n\n\n전화와 같이 믿을 수 있는 양방향 통신을 제공한다. 즉 데이터를 주고받는 소켓의 양쪽이 성립된 상태에서 한쪽(서버)에서 다른 한쪽(클라이언트)으로의 연결을 초기화하고, 연결이 생성된 후에는 어느 쪽에서든 다른 쪽으로 통신할 수 있다. 데이터를 송신하고 나서 이 데이터가 실제로 도착했는지도 즉각 확인할 수 있다. 보통 전송 제어 프로토콜(Transmission Control Protocol, TCP)이라 불리는 표준 통신 프로토콜을 사용하며 이 외에도 SCTP(Stream Control Transmission Protocol) 나 DCCP (Datagram Congestion Control Protocol) 가 사용되지만 여기서는 다루지 않기로 한다. 컴퓨터 네트워크에서 데이터는 보통 패킷이라는 단위로 전송되는데, TCP는 패킷이 오류 없이 순서대로 도착하도록 설계되었다. 웹서버, 메일서버, 각 클라이언트 애플리케이션 모두는 TCP와 스트림 소켓을 사용한다.\n\n\n\n\n데이터그램 소켓의 연결은 단방향이고 신뢰할 수 없다. IP 와 포트번호를 특정하여 보내지만 수신을 확인하지 않는다. 또한 데이터가 순서대로 전송된다고 보장할 수도 없다. 사용자 데이터그램 프로토콜(User Datagram Protocol, UDP)이라는 표준 프로토콜을 사용한다. TCP 에 비해 단순하고 간단하며 부하가 적고 빠른 방법이다. 패킷 손실이 허용되기도 하며 네트워크 게임이나 음악/동영상 스트리밍에서 자주 쓰인다. UDP 를 통해 신뢰성 있는 데이터 통신을 하고 싶다면 직접 패킷을 통해 구현해야 한다.\n\n\n\n\n여기서는 접속을 기다리는 것이 서버(server), 기다리는 서버에 접근하는 것이 클라이언트(client) 라고 한다.",
    "crumbs": [
      "주제별",
      "TCP/UDP 통신"
    ]
  },
  {
    "objectID": "src/topics/socket.html#소켓-통신",
    "href": "src/topics/socket.html#소켓-통신",
    "title": "TCP/UDP 통신",
    "section": "",
    "text": "현재의 많은 장비들은 소켓 통신을 사용하여 데이터와 정보를 주고받는다. 예전의 장비들은 RS232 나 RS485 같은 직렬 통신이나 다른 다양한 통신 방법을 사용하는 경우가 많았지만 최근의 장비들은 소켓 통신을 통해 데이터를 전송하는 경우가 많다. 여기서는 소켓 통신에 대해 짧게 알아보고 실제 구현해 보기로 하자.\n\n\n\n소켓은 같은 컴퓨터의 프로세스 사이에서, 혹은 서로 다른 컴퓨터(혹은 장비)의 프로세스 사이에서 통신을 수행할 때의 종단점 (end point)이다. 같은 컴퓨터의 프로세스 사이의 소켓에는 unix domain socket 이 있으며 다른 컴퓨터 프로세스 사이에서의 통신에는 Datagram socket 과 Streaming socket 이 있다. 각각의 네트워크 하드웨어는 사양과 내부 명령어가 다르지만 운영체제 수준에서 이를 추상화하여 서로 통신할 수 있도록 한 것이 소켓이다. 여기서는 서로 다른 컴퓨터의 프로세스간 통신에 대해서만 다루기로 한다.\n\n\n\n\n전화와 같이 믿을 수 있는 양방향 통신을 제공한다. 즉 데이터를 주고받는 소켓의 양쪽이 성립된 상태에서 한쪽(서버)에서 다른 한쪽(클라이언트)으로의 연결을 초기화하고, 연결이 생성된 후에는 어느 쪽에서든 다른 쪽으로 통신할 수 있다. 데이터를 송신하고 나서 이 데이터가 실제로 도착했는지도 즉각 확인할 수 있다. 보통 전송 제어 프로토콜(Transmission Control Protocol, TCP)이라 불리는 표준 통신 프로토콜을 사용하며 이 외에도 SCTP(Stream Control Transmission Protocol) 나 DCCP (Datagram Congestion Control Protocol) 가 사용되지만 여기서는 다루지 않기로 한다. 컴퓨터 네트워크에서 데이터는 보통 패킷이라는 단위로 전송되는데, TCP는 패킷이 오류 없이 순서대로 도착하도록 설계되었다. 웹서버, 메일서버, 각 클라이언트 애플리케이션 모두는 TCP와 스트림 소켓을 사용한다.\n\n\n\n\n데이터그램 소켓의 연결은 단방향이고 신뢰할 수 없다. IP 와 포트번호를 특정하여 보내지만 수신을 확인하지 않는다. 또한 데이터가 순서대로 전송된다고 보장할 수도 없다. 사용자 데이터그램 프로토콜(User Datagram Protocol, UDP)이라는 표준 프로토콜을 사용한다. TCP 에 비해 단순하고 간단하며 부하가 적고 빠른 방법이다. 패킷 손실이 허용되기도 하며 네트워크 게임이나 음악/동영상 스트리밍에서 자주 쓰인다. UDP 를 통해 신뢰성 있는 데이터 통신을 하고 싶다면 직접 패킷을 통해 구현해야 한다.\n\n\n\n\n여기서는 접속을 기다리는 것이 서버(server), 기다리는 서버에 접근하는 것이 클라이언트(client) 라고 한다.",
    "crumbs": [
      "주제별",
      "TCP/UDP 통신"
    ]
  },
  {
    "objectID": "src/topics/socket.html#tcp-와-udp-를-이용한-간단한-에코-서버와-클라이언트의-저차원-구현",
    "href": "src/topics/socket.html#tcp-와-udp-를-이용한-간단한-에코-서버와-클라이언트의-저차원-구현",
    "title": "TCP/UDP 통신",
    "section": "2 TCP 와 UDP 를 이용한 간단한 에코 서버와 클라이언트의 저차원 구현",
    "text": "2 TCP 와 UDP 를 이용한 간단한 에코 서버와 클라이언트의 저차원 구현\n여기서는 Python 으로 간단한 서버와 클라이언트를 구현한다. 가장 기본적인 저차원 구현은 C 언어를 이용한 구현이지만 여기서는 이 C 구현과 가장 비슷하며 저차원 구현을 체험해 볼 수 있는 Python 구현을 통해 TCP 와 UDP 통신을 알아보기로 하자.\n\nTCP 통신\n서버가 대기하고 클라이언트와의 접속이 성립하면 클라이언트는 사용자로부터의 입력을 서버에게 보낸다. 서버는 클라이언트로부터 받은 메시지를 출력하고 그 메시지 끝에 # 을 붙여 클라이언트에게 보낸다. 클라이언트는 # 이 붙은 메시지를 받고 출력한다. 사용자로부터 -1 을 받으면 서버는 역시 # 이 붙은 메시지 -1# 을 클리이언트로 보내고 종료하며, 클라이언트 역시 종료한다.\nPython 으로 구현하지만 여기서의 방식은 소켓 통신의 기본적인 즉 low-level 방식으로 거의 모든 언어에서 기본적으로 지원한다. 물론 실제로는 이 방식보다는 이 방식을 좀 더 쓰기 편하게 만든 방식을 쓸 수도 있지만 기본 동작을 일단 확인하기 위해 low-level 방식으로 구현해보자.\n소켓 통신을 위해서는 socket 모듈을 임포트 해야 하고 소켓 객체를 구현해야 한다. 서버에는 두개의 소켓이 필요하다. 하나는 접속을 받아들이고 연결을 위한 역할을 수행하는 소켓(이하 연결 소켓)이며 다른 하나는 클라이언트와 데이터를 주고받기 위한 소캣(이하 서버 소켓)이다. 클라이언트는 데이터를 주고받는 소켓(이하 클라이언트 소켓) 하나만 있으면 된다. 연결 소켓, 서버소켓, 클라이언트 소켓은 편의상 지은 이름이며 다른 곳에서는 다른 이름으로 사용될 수 있다.\n\nTCP 서버\n일단 서버쪽에서 연결 소켓을 성립시켜야 한다. 연결 소켓을 위해서는 서버 IP 와 포트 번호가 필요하다. IP 는 \"123.123.123.12\" 형식의 문자열이며 포트 번호는 0 부터 65535 번까지의 정수이다. IP 와 포트번호는 Internet Assigned Numbers Authority (IANA) 에서 관리하는데 포트 번호중의 일부는 특별한 용도로 지정되어 있다. 자세한 것은 List of TCP and UDP port numbers 를 참고하라. 보통 49152 에서 65535 번호는 자유롭게 사용 할 수 있다.\n\n연결 소켓은 IP 와 포트번호, 그리고 프로토콜로 구성된다. 우선\nimport socket\n을 통해 소캣 모듈을 사용할 수 있도록 한다. 이후 아래와 같이 소켓 인스턴스를 만들고 프로토콜과 옵션을 정한다.\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\nsocket.socket 의 첫번째 인자로는 다음이 사용될 수 있다.\n\nsocket.AF_INET 은 IPv4 즉 4 개의 8비트 정수로 지정된 IP 번호를 사용한는 것을 의미한다. 보퉁 많이 사용하는 123.123.123.12 형식이다.\nsocket.AF_INET6 는 IPv6 주소체계를 사용한다는 것을 의미하며 16비트 정수 4개를 사용한다.\nsocket.AF_UNIX 는 네트웍 통신이 아닌 프로세스간의 통신에 대해 사용한다.\n\nsocket.socket 의 두번째 인자로는 다음이 사용될 수 있다.\n\nsocket.SOCK_STREAM 은 TCP 통신 규약을 사용한다는 것을 의미한다.\nsocket.SOCK_DGRAM 은 UDP 통신 규약을 사용한다는 것을 의미한다.\n\n\nsocket.setsockopt 함수는 소켓의 옵션을 지정한다. 첫번째 인자는 프로토콜 레벨이며 두번째 인자는 프로토콜 레벨에서의 옵션 이름, 세번째 인자부터는 앞의 두 인자에 따른 설정값 등이 온다. 자세한 내용은 setsockopt 서브루틴 을 참고하라. 여기서 socket.SO_REUSEADDR 옵션의 옵션값을 1 로 설정하면 클라이언트 소켓을 닫은 후 같은 IP 와 포트번호로 연결할 수 있다.\n\nserver_socket.bind((host, port))\nserver_socket.listen(0)\nclient_soc, addr = server_socket.accept()\nbind((host, port)) 는 연결 소켓에 IP 번호(host) 와 포트(port) 를 지정한다. 이제 listen() 을 통해 클라이언트로부터 접속 요청 대기를 시작한다. listen 함수는 최대 대기 큐의 갯수를 인자로 받을 수 있며, 인자가 없을 경우 자동으로 할당된다.\naccept() 함수는 연결을 시도한 클라이언트와 통신 할 수 있는 소켓(client_soc), 즉 서버 소켓과 연결된 클라이언트의 (IP 주소, 포트) 튜플을 반환한다. 이 서버 소켓을 통해 클라이언트와 통신한다. 이제 서버의 코드를 보자.\n# TCP 서버 프로그램 \nimport socket, time\n\nhost, port = 'localhost', 43333\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\nserver_socket.bind((host, port))\nserver_socket.listen()\n\nprint('TCP 서버 시작')\n\nclient_soc, addr = server_socket.accept()\n\nprint('연결된 client (IP, port):', addr)\n\n# 접속 유지 변수\nconnection_retained = True\n\nwhile connection_retained :\n    try:\n        data = client_soc.recv(1024)\n    except ConnectionResetError:\n        print('ConnectionResetError')\n        connection_retained = False\n    finally:    \n        msg = data.decode() # 읽은 데이터 디코딩\n        print('받은 메시지 :', msg)\n        client_soc.sendall((msg+\"#\").encode(encoding='utf-8')) # 에코메세지 클라이언트로 보냄\n\n        # 클라이언트로부터 받은 메시지가 \"-1\" 이면 접속을 종료시킨다.\n        if msg == \"-1\":\n            connection_retained = False\n            print(\"to be closed\")        \n            client_soc.close()\n        \n    time.sleep(0.2)\n    \nserver_socket.close() # 사용했던 서버 소켓을 닫아줌 \n앞서 말했듯이 클라이언트로부터 -1 메시지를 받기 전까지는 계속 클라이언트와 통신해야 한다. 이를 위해 일단 connection_retianed = True 로 두고 이 변수값이 True 인 상황에서는 계속 주고 받도록 한다. 그러나 클라이언트로부터 -1 을 받으면 connection_refused = False 가 되며 while 루프를 벗어나고 소켓이 종료되고 (server_socket.close()) 프로그램도 종료한다.\n\n\n\nTCP 클라이언트\n클라이언트는 서버보다 간단한다.\nimport socket\nserver_ip, server_port = 'localhost', 43333\nsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n서버에 접속하기 위해서는 서버의 IP 와 포트 번호를 알야야 한다(server_ip, server_port). TCP 통신이므로 소켓은 server 의 연결소켓과 같이 설정한다. 이제 연결을 시도한다\nsocket.connect((server_ip, server_port))\n서버와 마찬가지로 연결 유지를 확인하기 위한 변수 connetion_retained 가 존재한다. 코드는 아래와 같다.\n# TCP 클라이언트 프로그램\nimport socket, time\n\nserver_ip, server_port = 'localhost', 43333\nsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsocket.connect((server_ip, server_port))\nsocket.settimeout(0.1)\n\n# 연결 유지 변수\nconnection_retained = True\n\nwhile connection_retained :\n    msg = input('msg:') # 서버로 보낼 msg 입력\n    \n    if msg == \"-1\":\n        connection_retained = False\n    socket.sendall(msg.encode(encoding='utf-8'))\n\n    # 서버가 에코로 되돌려 보낸 메시지를 클라이언트가 받음\n    try:\n        data = socket.recv(1024)\n    except TimeoutError:\n        print('TimeoutError')\n    finally:\n        msg = data.decode() # 읽은 데이터 디코딩\n        print('서버로부터 받은 메시지 :', msg)\nsocket.close()\nsocket.recv(1024) 는 서버로부터 최대 1024 바이트를 는다는 의미이다. 그러나 이 함수 실행 후 지정된 시간동안 응답이 없을 경우 TimeoutError 가 발생하며 소캣이 종료된다. 응답대기시간은 socket.settimeout() 함수를 통해 지정하며 인자로 초 단위의 시간을 입력한다. 인자가 없으면 무한정 기다린다.\n여기서는 응답 대기 시간이 길더라도 문제가 없지만 예를 들어 여러 서버로부터 데이터를 받는 경우를 생각해보자. 여기서 응답을 대기한다면 다른 작업을 수행 할 수가 없으며, 이를 위해 응답 대기시간을 짧게 잡고 다른 작업을 수행한 후 다시 메시지를 기다리는 것이 좋다.\n\n\n\n\nUDP 통신\nUDP 통신과 TCP 통신의 차이는 다음과 같다.\n\n소켓 타입이 socket.SOCK_STREAM 이 아닌 socket.SOCK_DGRAM 이다.\n연결 소켓이 없으며 서버소켓이 직접 bind 된다.\nTCP 에서는 recv, send 를 통해 데이터를 주고받지만 UDP 에서는 recvfrom, sendto 함수를 사용한다. 앞서 사용한 sendall 함수는 기본 함수인 send 를 python socket 모듈에서 확장한 것이다.\nrecvfrom 함수를 통해 데이터와 데이터를 보낸 주소를 얻으며, 이 주소가 원하는 주소가 않을 경우 무시한다.\nsendto 함수의 인자로는 데이터와 데이터를 받을 IP, 포트번호의 튜플을 전달한다.\n\n\n소스코드를 보라.\n\n\nUDP 서버\n# UDP 서버 프로그램\nimport socket, time\n\nhost, port = 'localhost', 43333\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nserver_socket.bind((host, port))\n# server_socket.listen()\n\nprint('UDP 서버 시작')\n\n#client_soc, addr = server_socket.accept()\naddr = (None, None)\n\nprint('연결된 client (IP, port):', addr)\n\n# 접속 유지 변수\nconnection_retained = True\n\nwhile connection_retained :\n    try:\n        data, addr = server_socket.recvfrom(1024)\n    except ConnectionResetError:\n        print('ConnectionResetError')\n        connection_retained = False\n    finally:    \n        msg = data.decode() # 읽은 데이터 디코딩\n        print(addr, '받은 메시지 :', msg)\n        server_socket.sendto((msg+\"#\").encode(encoding='utf-8'), addr) # 에코메세지 클라이언트로 보냄\n\n        # 클라이언트로부터 받은 메시지가 \"-1\" 이면 접속을 종료시킨다.\n        if msg == \"-1\":\n            connection_retained = False\n            print(\"to be closed\")        \n            # client_soc.close()\n        \n    time.sleep(0.2)\n    \nserver_socket.close() # 사용했던 서버 소켓을 닫아줌 \n\n\n\nUDP 클라이언트\n# UDP 클라이언트 프로그램\nimport socket, time\n\nserver_addr = ('localhost', 43333)\nsocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n# socket.connect((server_ip, server_port))\nsocket.settimeout(0.1)\n\n# 연결 유지 변수\nconnection_retained = True\n\nwhile connection_retained :\n    msg = input('msg:') # 서버로 보낼 msg 입력\n    \n    if msg == \"-1\":\n        connection_retained = False\n    socket.sendto(msg.encode(encoding='utf-8'),server_addr)\n\n    # 서버가 에코로 되돌려 보낸 메시지를 클라이언트가 받음\n    try:\n        data, addr = socket.recvfrom(1024)\n    except TimeoutError:\n        print('TimeoutError')\n    finally:\n        msg = data.decode() # 읽은 데이터 디코딩\n        print('서버로부터 받은 메시지 :', msg)\nsocket.close()",
    "crumbs": [
      "주제별",
      "TCP/UDP 통신"
    ]
  }
]