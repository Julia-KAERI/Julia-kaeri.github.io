<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Science &amp; Programming - Programming Model</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../src/gpu/cuda/03_programming_interface.html" rel="next">
<link href="../../../src/gpu/cuda/01_introduction.html" rel="prev">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Science &amp; Programming</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../../src/gpu/gpu.html" aria-current="page"> 
<span class="menu-text">GPU &amp; CUDA</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../src/cpp_qt/cpp_qt.html"> 
<span class="menu-text">C++ &amp; Qt</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../src/ML/ml.html"> 
<span class="menu-text">AI &amp; ML</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../src/topics/socket.html"> 
<span class="menu-text">주제별</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../src/tools/tools.html"> 
<span class="menu-text">Tools</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../src/posts/index.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
    <a href="mailto:julia.kaeri@gmail.com" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-envelope"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../src/gpu/cuda/01_introduction.html">CUDA</a></li><li class="breadcrumb-item"><a href="../../../src/gpu/cuda/02_programming_model.html">Programming Model</a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../src/gpu/gpu.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">GPU &amp; CUDA</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">CUDA</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../src/gpu/cuda/01_introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../src/gpu/cuda/02_programming_model.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Programming Model</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../src/gpu/cuda/03_programming_interface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Programming Interface</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">CUDA.jl</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../src/gpu/cuda.jl/cuda_jl_array_programming.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">CUDA.jl 배열 처리</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../src/gpu/cuda.jl/cuda_jl_kernel_programming.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">CUDA.jl 커널 프로그래밍</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../src/gpu/cuda.jl/cuda_jl_performance_tips.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">CUDA.jl 성능 팁</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#커널" id="toc-커널" class="nav-link active" data-scroll-target="#커널"><span class="header-section-number">1</span> 커널</a></li>
  <li><a href="#sec-cuda_thread_hierarchy" id="toc-sec-cuda_thread_hierarchy" class="nav-link" data-scroll-target="#sec-cuda_thread_hierarchy"><span class="header-section-number">2</span> 스레드 계층 구조 : 스레드 <span class="math inline">\(\rightarrow\)</span> 블럭 <span class="math inline">\(\rightarrow\)</span> 그리드</a>
  <ul class="collapse">
  <li><a href="#sec-cuda_thread_block_cluster" id="toc-sec-cuda_thread_block_cluster" class="nav-link" data-scroll-target="#sec-cuda_thread_block_cluster">Thread Block Cluseter</a></li>
  </ul></li>
  <li><a href="#sec-cuda_memory_hierarchy" id="toc-sec-cuda_memory_hierarchy" class="nav-link" data-scroll-target="#sec-cuda_memory_hierarchy"><span class="header-section-number">3</span> 메모리 계층 구조</a></li>
  <li><a href="#sec-cuda_heterogeneous_programming" id="toc-sec-cuda_heterogeneous_programming" class="nav-link" data-scroll-target="#sec-cuda_heterogeneous_programming"><span class="header-section-number">4</span> 이기종 프로그래밍 (Heterogeneous Programming)</a></li>
  <li><a href="#sec-cuda-asynchronous_simt_programming_model" id="toc-sec-cuda-asynchronous_simt_programming_model" class="nav-link" data-scroll-target="#sec-cuda-asynchronous_simt_programming_model"><span class="header-section-number">5</span> 비동기적 SIMT 프로그래밍 모델</a>
  <ul class="collapse">
  <li><a href="#sec-asynchronous_operations" id="toc-sec-asynchronous_operations" class="nav-link" data-scroll-target="#sec-asynchronous_operations">비동기 연산</a></li>
  </ul></li>
  <li><a href="#compute-capability" id="toc-compute-capability" class="nav-link" data-scroll-target="#compute-capability"><span class="header-section-number">6</span> Compute Capability</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../src/gpu/cuda/01_introduction.html">CUDA</a></li><li class="breadcrumb-item"><a href="../../../src/gpu/cuda/02_programming_model.html">Programming Model</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Programming Model</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="커널" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="커널"><span class="header-section-number">1</span> 커널</h2>
<ul>
<li><p>CUDA C++는 프로그래머가 커널이라는 C++ 함수를 정의할 수 있도록 하여 C++를 확장한 것.</p></li>
<li><p>이 함수는 호출되면 N개의 서로 다른 CUDA 스레드에 의해 병렬로 N번 실행된다. 반면 일반 C++ 함수는 한 번만 실행된다.</p></li>
</ul>
<p><br></p>
<p>간단한 커널의 예는 아래와 같다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Kernel definition</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>__global__ <span class="dt">void</span> VecAdd<span class="op">(</span><span class="dt">float</span><span class="op">*</span> A<span class="op">,</span> <span class="dt">float</span><span class="op">*</span> B<span class="op">,</span> <span class="dt">float</span><span class="op">*</span> C<span class="op">)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i <span class="op">=</span> threadIdx<span class="op">.</span>x<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    C<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> A<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> B<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Kernel invocation with N threads</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    VecAdd<span class="op">&lt;&lt;&lt;</span><span class="dv">1</span><span class="op">,</span> N<span class="op">&gt;&gt;&gt;(</span>A<span class="op">,</span> B<span class="op">,</span> C<span class="op">);</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
</section>
<section id="sec-cuda_thread_hierarchy" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="sec-cuda_thread_hierarchy"><span class="header-section-number">2</span> 스레드 계층 구조 : 스레드 <span class="math inline">\(\rightarrow\)</span> 블럭 <span class="math inline">\(\rightarrow\)</span> 그리드</h2>
<ul>
<li><p><code>threadIdx</code> 는 3차원 벡터로 1, 2, 3 차원 스레드 인덱스를 이용하여 스레드를 특정할 수 있다.</p></li>
<li><p>스레드 블럭(Thread block) : 1, 2 혹은 3차원의 스레드 인덱스의 집합</p></li>
</ul>
<p><br></p>
<ul>
<li><p>스레드 인덱스와 스레드 ID</p>
<ul>
<li><p>1차원 블럭 : ID = 인덱스</p></li>
<li><p>2차원 블럭 : 블럭 사이즈가 <span class="math inline">\((D_x, D_y)\)</span> 일 경우 스레드 인덱스 <span class="math inline">\((x,\,y)\)</span> 에 대한 <span class="math inline">\(\text{ID} = x+yD_x\)</span>.</p></li>
<li><p>3차원 블럭 : 블걱 사이즈가 <span class="math inline">\((D_x, D_y, D_z)\)</span> 일 경우 스레드 인덱스 <span class="math inline">\((x,\,y,\,z)\)</span> 에 대한 <span class="math inline">\(\text{ID} = x+yD_x + zD_x D_y\)</span>.</p></li>
</ul></li>
</ul>
<p><br></p>
<ul>
<li><p>블럭당 스레드 수 제한 : 블럭의 모든 스레드는 같은 SM(streaming multiprocess) 코어 안에 있어야 하며 그 코어의 제한된 메모리 자원을 공유한다. 현재의 GPU 에서 하나의 블럭은 최대 1024 개의 스레드를 포함 할 수 있다.</p></li>
<li><p>커널은 <u>같은 형상의 다수의 스레드 블럭</u>에서 실행되며, 따라서 총 스레드 수는 블럭수 와 블럭당 스레드 수의 곱이다.</p></li>
<li><p>그리드 (Grid) 는 블럭의 집합이며, 1, 2 혹은 3차원 인덱스를 갖는다. <u>한 그리드의 스레드 블럭의 갯수는 처리하고자 하는 데이터의 크기에 의해 지정되며, 보통 시스템의 프로세서 수 보다 크다</u>.</p></li>
</ul>
<p><br></p>
<div id="fig-cuda_grid_of_thread_blocks" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-cuda_grid_of_thread_blocks-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://docs.nvidia.com/cuda/cuda-c-programming-guide/_images/grid-of-thread-blocks.png" class="img-fluid figure-img" width="500">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-cuda_grid_of_thread_blocks-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;1: Grid of Thread Blocks
</figcaption>
</figure>
</div>
<p><br></p>
<p>행렬곱에 대한 코드와 실행에 대한 아래의 코드를 보자.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Kernel definition</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>__global__ <span class="dt">void</span> MatAdd<span class="op">(</span><span class="dt">float</span> A<span class="op">[</span>N<span class="op">][</span>N<span class="op">],</span> <span class="dt">float</span> B<span class="op">[</span>N<span class="op">][</span>N<span class="op">],</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> C<span class="op">[</span>N<span class="op">][</span>N<span class="op">])</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i <span class="op">=</span> blockIdx<span class="op">.</span>x <span class="op">*</span> blockDim<span class="op">.</span>x <span class="op">+</span> threadIdx<span class="op">.</span>x<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> j <span class="op">=</span> blockIdx<span class="op">.</span>y <span class="op">*</span> blockDim<span class="op">.</span>y <span class="op">+</span> threadIdx<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">&lt;</span> N <span class="op">&amp;&amp;</span> j <span class="op">&lt;</span> N<span class="op">)</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        C<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> B<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Kernel invocation</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    dim3 threadsPerBlock<span class="op">(</span><span class="dv">16</span><span class="op">,</span> <span class="dv">16</span><span class="op">);</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    dim3 numBlocks<span class="op">(</span>N <span class="op">/</span> threadsPerBlock<span class="op">.</span>x<span class="op">,</span> N <span class="op">/</span> threadsPerBlock<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    MatAdd<span class="op">&lt;&lt;&lt;</span>numBlocks<span class="op">,</span> threadsPerBlock<span class="op">&gt;&gt;&gt;(</span>A<span class="op">,</span> B<span class="op">,</span> C<span class="op">);</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><p><code>&lt;&lt;&lt;...&gt;&gt;&gt;</code> 구문에서 지정된 블록당 스레드 수와 그리드당 블록 수는 <code>int</code> 또는 <code>dim3</code> 타입이다. 2차원 블록 또는 그리드는 위의 예와 같이 지정할 수 있다.</p></li>
<li><p>그리드 내의 각 블록은 커널 내에서 내장된 <code>blockIdx</code> 변수를 통해 액세스할 수 있는 1차원, 2차원 또는 3차원 고유 인덱스로 식별할 수 있다. 스레드 블록의 차원은 커널 내에서 내장된 <code>blockDim</code> 변수를 통해 액세스할 수 있다.</p></li>
<li><p>위 코드의 경우 이 경우 임의적이기는 하지만 16x16(256개 스레드)의 스레드 블록 크기가 일반적인 선택이다. 그리드는 행렬 요소당 하나의 스레드를 가질 수 있을 만큼 충분한 블록으로 생성된다. 단순화를 위해 이 예에서는 각 차원의 그리드당 스레드 수가 해당 차원의 블록당 스레드 수로 균등하게 나누어진다고 가정하지만 반드시 그럴 필요는 없다.</p></li>
<li><p>스레드 블록은 독립적으로 실행될 수 있어야 한다. 병렬 또는 직렬로 어떤 순서로든 실행할 수 있어야 한다. 이러한 독립성으로 인해 <a href="../../../src/gpu/cuda/01_introduction.html#fig-cuda_scalability">앞장의 그림 3</a> 에서 볼 수 있듯이 스레드 블록을 모든 코어 수에 걸쳐 어떤 순서로든 예약할 수 있으므로 프로그래머는 코어 수에 따라 확장되는 코드를 작성할 수 있다.</p></li>
<li><p>블록 내의 스레드는 일부 공유 메모리를 통해 데이터를 공유하고 실행을 동기화하여 메모리 액세스를 조정함으로써 협력할 수 있다. 더 정확하게 말하면 <code>__syncthreads()</code> 내장 함수를 호출하여 커널에서 동기화 지점을 지정할 수 있다. <code>__syncthreads()</code> 는 어떤 허락이 떨어지기 전까지 블록의 모든 스레드가 진행을 멈추고 기다려야 하는 장벽 역할을 한다. <a href="../../../src/gpu/cuda/03_programming_interface.html#sec-shared_memory">공유 메모리</a> 에는 공유 메모리를 사용하는 예를 제시한다. <code>__syncthreads()</code> 외에도 <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/#cooperative-groups">Cooperative Groups</a> API는 풍부한 스레드 동기화 기본 요소를 제공한다.</p></li>
<li><p>효율적인 협력을 위해 공유 메모리는 각 프로세서 코어 근처의 저지연 메모리(L1 캐시와 매우 유사)가 될 것으로 예상되고 <code>__syncthreads()</code> 는 가벼울 것으로 예상된다.</p></li>
</ul>
<p><br></p>
<section id="sec-cuda_thread_block_cluster" class="level3">
<h3 class="anchored" data-anchor-id="sec-cuda_thread_block_cluster">Thread Block Cluseter</h3>
<p><a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/#compute-capability-9-0">NVIDIA Compute Capability 9.0</a> 부터 CUDA 프로그래밍 모델은 스레드 블록으로 구성된 스레드 블록 클러스터라는 선택적 계층 구조를 도입한다. 스레드 블록의 스레드가 스트리밍 멀티프로세서에서 공동 스케줄링되는 것과 유사하게 클러스터의 스레드 블록도 GPU의 GPU 처리 클러스터(GPC)에서 공동 스케줄링된다.</p>
<p>스레드 블록과 유사하게 클러스터도 스레드 블록 클러스터 그리드에서 설명한 대로 1차원, 2차원 또는 3차원으로 구성된다. 클러스터의 스레드 블록 수는 사용자가 정의할 수 있으며 클러스터의 최대 8개 스레드 블록이 CUDA에서 이식 가능한 클러스터 크기로 지원된다. 8개의 멀티프로세서를 지원하기에는 너무 작은 GPU 하드웨어 또는 MIG 구성에서는 최대 클러스터 크기가 그에 따라 줄어들게된다. 8개 이상의 스레드 블록 클러스터 크기를 지원하는 더 큰 구성뿐만 아니라 이러한 더 작은 구성을 식별하는 것은 아키텍처에 따라 다르며 <code>cudaOccupancyMaxPotentialClusterSize</code> API를 사용하여 쿼리할 수 있다.</p>
<div id="fig-cuda_gird_of_thread_block_clusters" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-cuda_gird_of_thread_block_clusters-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://docs.nvidia.com/cuda/cuda-c-programming-guide/_images/grid-of-clusters.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-cuda_gird_of_thread_block_clusters-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;2: Grid of Thread Block Clusters
</figcaption>
</figure>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
노트
</div>
</div>
<div class="callout-body-container callout-body">
<p>In a kernel launched using cluster support, the gridDim variable still denotes the size in terms of number of thread blocks, for compatibility purposes. The rank of a block in a cluster can be found using the <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/#cluster-group-cg">Cluster Group</a> API.</p>
</div>
</div>
<p><br></p>
<p>스레드 블록 클러스터는 <code>__cluster_dims__(X,Y,Z)</code> 를 사용하는 컴파일러 시간 커널 속성을 사용하거나 CUDA 커널 실행 API <code>cudaLaunchKernelEx</code> 를 사용하여 커널에서 활성화할 수 있다. 아래 예는 컴파일러 시간 커널 속성을 사용하여 클러스터를 실행하는 방법을 보여준다. 커널 속성을 사용하는 클러스터 크기는 컴파일 시간에 고정되고 그런 다음 고전적인 <code>&lt;&lt;&lt; , &gt;&gt;&gt;</code> 를 사용하여 커널을 실행할 수 있다. 커널이 이런 컴파일 시간의 클러스터 크기를 사용하는 경우 커널을 실행할 때 클러스터 크기를 수정할 수 없다.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Kernel definition</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Compile time cluster size 2 in X-dimension and 1 in Y and Z dimension</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>__global__ <span class="dt">void</span> __cluster_dims__<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">)</span> cluster_kernel<span class="op">(</span><span class="dt">float</span> <span class="op">*</span>input<span class="op">,</span> <span class="dt">float</span><span class="op">*</span> output<span class="op">)</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> <span class="op">*</span>input<span class="op">,</span> <span class="op">*</span>output<span class="op">;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Kernel invocation with compile time cluster size</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    dim3 threadsPerBlock<span class="op">(</span><span class="dv">16</span><span class="op">,</span> <span class="dv">16</span><span class="op">);</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    dim3 numBlocks<span class="op">(</span>N <span class="op">/</span> threadsPerBlock<span class="op">.</span>x<span class="op">,</span> N <span class="op">/</span> threadsPerBlock<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The grid dimension is not affected by cluster launch, and is still enumerated</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// using number of blocks.</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The grid dimension must be a multiple of cluster size.</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    cluster_kernel<span class="op">&lt;&lt;&lt;</span>numBlocks<span class="op">,</span> threadsPerBlock<span class="op">&gt;&gt;&gt;(</span>input<span class="op">,</span> output<span class="op">);</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
<p>스레드 블록 클러스터 크기는 런타임에 설정할 수도 있고, 커널은 CUDA 커널 실행 API <code>cudaLaunchKernelEx</code> 를 사용하여 실행할 수 있다. 아래 코드 예제는 확장 가능한 API를 사용하여 클러스터 커널을 실행하는 방법을 보여준다.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Kernel definition</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">// No compile time attribute attached to the kernel</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>__global__ <span class="dt">void</span> cluster_kernel<span class="op">(</span><span class="dt">float</span> <span class="op">*</span>input<span class="op">,</span> <span class="dt">float</span><span class="op">*</span> output<span class="op">)</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> <span class="op">*</span>input<span class="op">,</span> <span class="op">*</span>output<span class="op">;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    dim3 threadsPerBlock<span class="op">(</span><span class="dv">16</span><span class="op">,</span> <span class="dv">16</span><span class="op">);</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    dim3 numBlocks<span class="op">(</span>N <span class="op">/</span> threadsPerBlock<span class="op">.</span>x<span class="op">,</span> N <span class="op">/</span> threadsPerBlock<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Kernel invocation with runtime cluster size</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">cudaLaunchConfig_t</span> config <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// The grid dimension is not affected by cluster launch, and is still enumerated</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// using number of blocks.</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// The grid dimension should be a multiple of cluster size.</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        config<span class="op">.</span>gridDim <span class="op">=</span> numBlocks<span class="op">;</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        config<span class="op">.</span>blockDim <span class="op">=</span> threadsPerBlock<span class="op">;</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        cudaLaunchAttribute attribute<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        attribute<span class="op">[</span><span class="dv">0</span><span class="op">].</span>id <span class="op">=</span> cudaLaunchAttributeClusterDimension<span class="op">;</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        attribute<span class="op">[</span><span class="dv">0</span><span class="op">].</span>val<span class="op">.</span>clusterDim<span class="op">.</span>x <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// Cluster size in X-dimension</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>        attribute<span class="op">[</span><span class="dv">0</span><span class="op">].</span>val<span class="op">.</span>clusterDim<span class="op">.</span>y <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>        attribute<span class="op">[</span><span class="dv">0</span><span class="op">].</span>val<span class="op">.</span>clusterDim<span class="op">.</span>z <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>        config<span class="op">.</span>attrs <span class="op">=</span> attribute<span class="op">;</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>        config<span class="op">.</span>numAttrs <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>        cudaLaunchKernelEx<span class="op">(&amp;</span>config<span class="op">,</span> cluster_kernel<span class="op">,</span> input<span class="op">,</span> output<span class="op">);</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>compute capability 9.0 호환 GPU에서 클러스터의 모든 스레드 블록은 단일 GPU 처리 클러스터(GPC)에서 공동 스케줄링되도록 보장되며 클러스터의 스레드 블록이 <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/#cluster-group-cg">Cluster Group</a> API <code>cluster.sync()</code> 를 사용하여 하드웨어가 지원하는 동기화를 수행할 수 있다. Cluster Group은 또한 <code>num_threads()</code> 및 <code>num_blocks()</code> API를 사용하여 스레드 수 또는 블록 수 측면에서 클러스터 그룹 크기를 쿼리하는 멤버 함수를 제공한다. 클러스터 그룹의 스레드 또는 블록 순위는 <code>dim_threads()</code> 및 <code>dim_blocks()</code> API를 사용하여 각각 쿼리할 수 있다.</p>
<p>클러스터에 속한 스레드 블록은 <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/#distributed-shared-memory">분산 공유 메모리(Distributed shared memory)</a>에 액세스할 수 있다. 클러스터의 스레드 블록은 분산 공유 메모리의 모든 주소를 읽고, 쓰고, 원자성을 수행할 수 있다. <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/#distributed-shared-memory">분산 공유 메모리(Distributed shared memory)</a>에는 분산 공유 메모리에서 히스토그램을 수행하는 예를 제시한다.</p>
<p><br></p>
</section>
</section>
<section id="sec-cuda_memory_hierarchy" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="sec-cuda_memory_hierarchy"><span class="header-section-number">3</span> 메모리 계층 구조</h2>
<div id="fig-cuda_memory_hierarchy" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-cuda_memory_hierarchy-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://docs.nvidia.com/cuda/cuda-c-programming-guide/_images/memory-hierarchy.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-cuda_memory_hierarchy-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;3: Memory Hierarchy
</figcaption>
</figure>
</div>
<p>CUDA 스레드는 <a href="#fig-cuda_memory_hierarchy" class="quarto-xref">그림&nbsp;3</a> 에서 설명한 대로 실행 중에 여러 메모리 공간에서 데이터에 액세스할 수 있다. 각 스레드에는 개별적인 로컬 메모리가 있다. 각 스레드 블록에는 블록의 모든 스레드에서 볼 수 있고 블록과 동일한 수명을 가진 공유 메모리가 있다. 스레드 블록 클러스터의 스레드 블록은 서로의 공유 메모리에서 읽기, 쓰기 및 아토믹 연산을 수행할 수 있다. 모든 스레드는 동일한 전역 메모리(Global memory)에 액세스할 수 있다.</p>
<p>또한 모든 스레드에서 액세스할 수 있는 읽기 전용 메모리 공간이 추가로 존재한다 - 상수 메모리 공간과 텍스처 메모리 공간. 전역, 상수 및 텍스처 메모리 공간은 다양한 메모리 사용에 맞게 최적화되어 있다(<a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/#device-memory-accesses">장치 메모리 액세스</a> 참조). 텍스처 메모리는 또한 일부 특정 데이터 형식에 대해 다양한 주소 지정 모드와 데이터 필터링을 제공한다(<a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/#texture-and-surface-memory">텍스처 및 표면 메모리</a> 참조).</p>
<p>글로벌, 상수 및 텍스처 메모리 공간은 동일한 애플리케이션에서 커널을 시작할 때에도 지속된다.</p>
<p><br></p>
</section>
<section id="sec-cuda_heterogeneous_programming" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="sec-cuda_heterogeneous_programming"><span class="header-section-number">4</span> 이기종 프로그래밍 (Heterogeneous Programming)</h2>
<div id="fig-cuda_hetergeneous_programming" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-cuda_hetergeneous_programming-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://docs.nvidia.com/cuda/cuda-c-programming-guide/_images/heterogeneous-programming.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-cuda_hetergeneous_programming-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;4: Heterogeneous Programming
</figcaption>
</figure>
</div>
<p><br></p>
<ul>
<li><p><a href="#fig-cuda_hetergeneous_programming" class="quarto-xref">그림&nbsp;4</a> 에서 알 수 있듯이 CUDA 프로그래밍 모델은 C++ 프로그램을 실행하는 호스트에 대한 보조 프로세서로 작동하는 물리적으로 분리된 장치에서 CUDA 스레드가 실행된다고 가정한다. 예를 들자면 커널이 GPU에서 실행되고 나머지 C++ 프로그램이 CPU에서 실행되는 경우이다. 이후 GPU 가 실행되는 분리된 장치를 디바이스라고 부르겠다. (호스트와 디바이스라는 명칭으로 나누는 것은 일종의 관례이다)</p></li>
<li><p>CUDA 프로그래밍 모델은 또한 호스트와 디바이스가 각각 호스트 메모리와 디바이스 메모리라고 하는 DRAM에서 자체적인 별도 메모리 공간을 유지한다고 가정한다. 따라서 프로그램은 CUDA 런타임(<a href="../../../src/gpu/cuda/03_programming_interface.html">프로그래밍 인터페이스</a>에서 설명)에 대한 호출을 통해 커널에서 볼 수 있는 전역, 상수 및 텍스처 메모리 공간을 관리한다. 여기에는 디바이스 메모리 할당 및 할당 해제와 호스트와 디바이스 메모리 간의 데이터 전송이 포함된다.</p></li>
<li><p>Unified Memory 는 호스트와 디바이스 메모리 공간을 연결하는 관리되는 메모리를 제공한다. 관리되는 메모리는 시스템의 모든 CPU와 GPU에서 공통 주소 공간이 있는 단일의 일관된 메모리 이미지로 액세스할 수 있다. 이 기능은 디바이스 메모리에 대한 초과 예약(oversubcription)을 가능하게 하며 호스트와 디바이스에서 데이터를 명시적으로 미러링할 필요성을 없애 애플리케이션 포팅 작업을 크게 단순화할 수 있다. Unified Memory에 대한 소개는 <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/#um-unified-memory-programming-hd">Unified Memory Programming</a> 을 참조하라.</p></li>
</ul>
<p><br></p>
</section>
<section id="sec-cuda-asynchronous_simt_programming_model" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="sec-cuda-asynchronous_simt_programming_model"><span class="header-section-number">5</span> 비동기적 SIMT 프로그래밍 모델</h2>
<p>CUDA 프로그래밍 모델에서 스레드는 계산이나 메모리 작업을 수행하기 위한 가장 낮은 수준의 추상화이다. NVIDIA Ampere GPU 아키텍처 기반 장치부터 시작하여 CUDA 프로그래밍 모델은 비동기 프로그래밍 모델을 통해 메모리 작업을 가속시킨다. 비동기 프로그래밍 모델은 CUDA 스레드와 관련하여 비동기 연산의 행동을 정의한다.</p>
<p>비동기 프로그래밍 모델은 CUDA 스레드 간 동기화를 위한 <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/#aw-barrier">비동기 배리어</a> 의 동작을 정의한다. 이 모델은 또한 <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/#asynchronous-data-copies"><code>cuda::memcpy_async</code></a>를 사용하여 GPU에서 계산하는 동안 글로벌 메모리에서 비동기적으로 데이터를 이동하는 방법을 설명하고 정의한다.</p>
<p><br></p>
<section id="sec-asynchronous_operations" class="level3">
<h3 class="anchored" data-anchor-id="sec-asynchronous_operations">비동기 연산</h3>
<p>비동기 작업은 한 CUDA 스레드에서 시작하여 다른 스레드에서 실행되는 것처럼 비동기적으로 실행되는 작업으로 정의된다. 잘 구성된 프로그램에서는 하나 이상의 CUDA 스레드가 이 비동기 작업과 동기화된다. 비동기 작업을 시작한 CUDA 스레드는 동기화 스레드에 포함될 필요가 없다.</p>
<p>이러한 비동기 스레드(as-if 스레드)는 항상 비동기 작업을 시작한 CUDA 스레드와 연결된다. 비동기 작업은 작업 완료를 동기화 하기 위해 동기화 객체를 사용한다. 이러한 동기화 객체는 사용자가 명시적으로 관리하거나(예: <code>cuda::memcpy_async</code>) 라이브러리 내에서 암묵적으로 관리할 수 있다(예: <code>cooperative_groups::memcpy_async</code>).</p>
<p>동기화 객체는 <code>cuda::barrier</code> 또는 <code>cuda::pipeline</code> 일 수 있다. 이러한 객체는 <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/#aw-barrier">비동기 Barrier</a> 및 <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/#asynchronous-data-copies"><code>cuda::pipeline</code> 을 사용한 비동기 데이터 복사</a>에서 자세히 설명한다. 이러한 동기화 객체들 다른 스레드 범위(scope)에서 사용할 수 있다. 이 스레드 범위는 비동기 작업과 동기화하기 위해 동기화 객체를 사용할 수 있는 스레드 집합을 정의한다. 다음 표는 CUDA C++에서 사용 가능한 스레드 범위와 각각과 동기화할 수 있는 스레드를 정의한다.</p>
<table class="table">
<colgroup>
<col style="width: 46%">
<col style="width: 53%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">스레드 범위</th>
<th style="text-align: left;">동기화 범위</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>cuda::thread_scope::thread_scope_thread</code></td>
<td style="text-align: left;">비동기 작업을 시작한 CUDA 스레드</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>cuda::thread_scope::thread_scope_block</code></td>
<td style="text-align: left;">시작 스레드와 동일한 스레드 블록 내의 모든 CUDA 스레드 또는 어떤 CUDA 스레드</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>cuda::thread_scope::thread_scope_device</code></td>
<td style="text-align: left;">시작 스레드가 속한 동일한 GPU 디바이스 내의 모든 CUDA 스레드 또는 어떤 CUDA 스레드</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>cuda::thread_scope::thread_scope_system</code></td>
<td style="text-align: left;">시작 스레드가 속한 동일한 시스템 내의 모든 CUDA 스레드 또는 CPU 스레드</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>이러한 스레드 scope 는 표준 C++ 라이브러리에 대한 확장인 <a href="https://nvidia.github.io/libcudacxx/extended_api/memory_model.html#thread-scopes">CUDA Standard C++ library</a> 로 구현되었다.</p>
<p><br></p>
</section>
</section>
<section id="compute-capability" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="compute-capability"><span class="header-section-number">6</span> Compute Capability</h2>
<p>디바이스의 compute capability 는 버전 번호로 표현되며, 때로는 “SM 버전” 이라고도 한다. 이 버전 번호는 GPU 하드웨어에서 지원하는 기능을 식별하며, 런타임에 애플리케이션에서 현재 GPU에서 사용할 수 있는 하드웨어 기능 및/또는 명령어를 확인하는 데 사용된다. compute capability 는 주요 개정 번호 X와 부차 개정 번호 Y로 구성되며 X.Y로 표시된다.</p>
<p>동일한 주요 개정 번호가 있는 장치는 동일한 코어 아키텍처이다. 주요 개정 번호는 NVIDIA Hopper GPU 아키텍처 기반 장치의 경우 9, NVIDIA Ampere GPU 아키텍처 기반 장치의 경우 8, Volta 아키텍처 기반 장치의 경우 7, ​​Pascal 아키텍처 기반 장치의 경우 6, Maxwell 아키텍처 기반 장치의 경우 5, Kepler 아키텍처 기반 장치의 경우 3 이다.</p>
<p>부차 개정 번호는 코어 아키텍처에 대한 점진적 개선에 해당하며, 새로운 기능이 포함될 수 있다.</p>
<p>Turing은 컴퓨팅 기능 7.5의 장치에 대한 아키텍처이며 Volta 아키텍처를 기반으로 하는 점진적 업데이트이다.</p>
<p><a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/#cuda-enabled-gpus">CUDA 지원 GPU</a>는 모든 CUDA 지원 장치와 해당 컴퓨팅 기능을 나열한다. <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/#compute-capabilities">Compute Capability</a> 에서는 각 compute capability 의 기술 사양을 제공한다.</p>
<p><br></p>
<div class="callout callout-style-default callout-warning no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
경고
</div>
</div>
<div class="callout-body-container callout-body">
<p>특정 GPU의 컴퓨팅 기능 버전은 CUDA 소프트웨어 플랫폼의 버전인 CUDA 버전(예: CUDA 7.5, CUDA 8, CUDA 9)과 다르다. CUDA 플랫폼은 애플리케이션 개발자가 아직 발명되지 않은 미래의 GPU 아키텍처를 포함하여 여러 세대의 GPU 아키텍처에서 실행되는 애플리케이션을 만드는 데 사용된다. CUDA 플랫폼의 새 버전은 종종 해당 아키텍처의 컴퓨팅 기능 버전을 지원하여 새 GPU 아키텍처에 대한 기본 지원을 추가하지만, CUDA 플랫폼의 새 버전은 일반적으로 하드웨어 세대와 독립적인 소프트웨어 기능도 포함한다.</p>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/julia-kaeri\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../../src/gpu/cuda/01_introduction.html" class="pagination-link" aria-label="Introduction">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Introduction</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../../src/gpu/cuda/03_programming_interface.html" class="pagination-link" aria-label="Programming Interface">
        <span class="nav-page-text">Programming Interface</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>