<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.43">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Introduction – Science &amp; Programming</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../src/gpu/cuda/02_programming_model.html" rel="next">
<link href="../../../src/gpu/gpu.html" rel="prev">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-d4d76bf8491c20bad77d141916dc28e1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-442e5c93d6224642134ff5cd604ad228.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Science &amp; Programming</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../../src/gpu/gpu.html" aria-current="page"> 
<span class="menu-text">GPU &amp; CUDA</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../src/cpp_qt/cpp_qt.html"> 
<span class="menu-text">C++ &amp; Qt</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../src/ML/ml.html"> 
<span class="menu-text">AI &amp; ML</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../src/topics/socket.html"> 
<span class="menu-text">주제별</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../src/tools/tools.html"> 
<span class="menu-text">Tools</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../src/posts/index.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
    <a href="mailto:julia.kaeri@gmail.com" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-envelope"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../src/gpu/cuda/01_introduction.html">CUDA</a></li><li class="breadcrumb-item"><a href="../../../src/gpu/cuda/01_introduction.html">Introduction</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../src/gpu/gpu.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">GPU &amp; CUDA</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">CUDA</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../src/gpu/cuda/01_introduction.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../src/gpu/cuda/02_programming_model.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Programming Model</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../src/gpu/cuda/03_programming_interface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Programming Interface</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">CUDA.jl</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../src/gpu/cuda.jl/cuda_jl_array_programming.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">CUDA.jl 배열 처리</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../src/gpu/cuda.jl/cuda_jl_kernel_programming.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">CUDA.jl 커널 프로그래밍</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../src/gpu/cuda.jl/cuda_jl_performance_tips.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">CUDA.jl 성능 팁</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#gpu-및-병렬-처리" id="toc-gpu-및-병렬-처리" class="nav-link active" data-scroll-target="#gpu-및-병렬-처리"><span class="header-section-number">1</span> GPU 및 병렬 처리</a>
  <ul class="collapse">
  <li><a href="#sec-cuda_parallel_architecture" id="toc-sec-cuda_parallel_architecture" class="nav-link" data-scroll-target="#sec-cuda_parallel_architecture">병렬 처리 하드웨어 아키텍쳐</a></li>
  <li><a href="#sec-cuda_shared_memory_and_distributed_memory" id="toc-sec-cuda_shared_memory_and_distributed_memory" class="nav-link" data-scroll-target="#sec-cuda_shared_memory_and_distributed_memory">공유 메모리와 분산 메모리</a></li>
  <li><a href="#sec-cuda_simt" id="toc-sec-cuda_simt" class="nav-link" data-scroll-target="#sec-cuda_simt">SIMT</a></li>
  </ul></li>
  <li><a href="#gpu-사용의-이점" id="toc-gpu-사용의-이점" class="nav-link" data-scroll-target="#gpu-사용의-이점"><span class="header-section-number">2</span> GPU 사용의 이점</a>
  <ul class="collapse">
  <li><a href="#cpu-와-gpu-의-목적" id="toc-cpu-와-gpu-의-목적" class="nav-link" data-scroll-target="#cpu-와-gpu-의-목적">CPU 와 GPU 의 목적</a></li>
  </ul></li>
  <li><a href="#cuda-a-general-purpose-parallel-computing-platform-and-programming-model" id="toc-cuda-a-general-purpose-parallel-computing-platform-and-programming-model" class="nav-link" data-scroll-target="#cuda-a-general-purpose-parallel-computing-platform-and-programming-model"><span class="header-section-number">3</span> CUDA®: A General-Purpose Parallel Computing Platform and Programming Model</a></li>
  <li><a href="#확장가능한-프로그래밍-모델" id="toc-확장가능한-프로그래밍-모델" class="nav-link" data-scroll-target="#확장가능한-프로그래밍-모델"><span class="header-section-number">4</span> 확장가능한 프로그래밍 모델</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../src/gpu/cuda/01_introduction.html">CUDA</a></li><li class="breadcrumb-item"><a href="../../../src/gpu/cuda/01_introduction.html">Introduction</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Introduction</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><br></p>
<div class="callout callout-style-default callout-caution no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
기본 용어
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><p>Throughput : 단위 시간 당 instruction 처리 갯수.</p></li>
<li><p>memory bandwidth : 데이터 운반 능력을 의미하는 것으로 한 번의 클럭 신호를 통해서 처리할 수 있는 용량. 메모리 클럭 X 메모리 버스 폭으로 계산</p></li>
<li><p>문맥(context) : 프로세스 실행과 관련한 정보들 (레지스터 상태, 메모리 스택 등) 의 집합</p></li>
</ul>
</div>
</div>
<p><br></p>
<section id="gpu-및-병렬-처리" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="gpu-및-병렬-처리"><span class="header-section-number">1</span> GPU 및 병렬 처리</h2>
<p>병렬 처리 시스템은 그 아키텍쳐와 메모리 공유 상테에 따라 분류 할 수 있다.</p>
<section id="sec-cuda_parallel_architecture" class="level3">
<h3 class="anchored" data-anchor-id="sec-cuda_parallel_architecture">병렬 처리 하드웨어 아키텍쳐</h3>
<p>플린(M. J. Flynn) 은 병렬 처리 하드웨어를 두가지 기준으로 네가지로 분류하였다.</p>
<p> (<span class="math inline">\(1\)</span>) 한 셋의 데이터 흐름에 대해 수행하는 명령어(instruction) 의 개수 : 1 혹은 1 이상 (&gt;1)</p>
<p> (<span class="math inline">\(2\)</span>) 하나의 명령에 의해 수행되는 데이터의 흐름의 수 : 1 혹은 1 이상 (&gt;1)</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">아키텍쳐</th>
<th style="text-align: center;">설명</th>
<th style="text-align: center;">(<span class="math inline">\(1\)</span>) 기준</th>
<th style="text-align: center;">(<span class="math inline">\(2\)</span>) 기준</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">SISD</td>
<td style="text-align: center;">Single instruction stream,single data stream</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">SIMD</td>
<td style="text-align: center;">Single instruction stream, multiple data stream</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">&gt;1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">MISD</td>
<td style="text-align: center;">Multiple instruction stream, single data stream</td>
<td style="text-align: center;">&gt;1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">MIMD</td>
<td style="text-align: center;">Multiple instruction stream multiple data stream</td>
<td style="text-align: center;">&gt;1</td>
<td style="text-align: center;">&gt;1</td>
</tr>
</tbody>
</table>
<p>MISD 구조는 아직 실현되지 않았으며 병렬컴퓨팅에서 사용되는 구조는 SIMD 와 MIMD(멀티코어 CPU) 이다.</p>
<p><br></p>
<section id="mimd" class="level4">
<h4 class="anchored" data-anchor-id="mimd">MIMD</h4>
<p>명령어와 데이터가 1-1 로 매칭되는 SISD 가 하나의 칩 안에 들어있는 구조가 널리 사용된다. 각각의 코어가 자신만의 제어 유닛과 문맥을 가지고 독립적으로 프로세스를 수해 여러개의 코어가 하나의 프로세서 칩 안에 존재한다. 또한 하나의 컴퓨터에 여러개의 프로세서 칩이 있을 경우 멀티코어 멀티 프로세서라고 한다.</p>
<p><br></p>
</section>
<section id="simd" class="level4">
<h4 class="anchored" data-anchor-id="simd">SIMD</h4>
<p>동일한 명령어를 여러 데이터에 대해 수행한다. 데이터 배열의 각 성분에 동일한 연산을 수항한다는 의미에서 벡터 프로세서, 혹은 배열 프로세서라고도 혼다. 대표적으로 GPU 가 있다. 일부 CPU 는 내부적으로 SIMD 유닛을 가지고 있는데 CPU 사양에서 이야기하는 MMX, SSE, AVX, Neon 등이 이러한 SIMD 유닛을 의미한다.</p>
<p><br></p>
<p>ALU(arithmetic logic unit, 산술 논리 유닛) 는 하나의 연산 유닛 혹은 코어를 의미한다. 하나의 제어 유닛이 여러개의 ALU를 제어하는 경우가 SIMD 의 대표적인 경우이고, ALU 와 제어 유닛이 결합된 세트가 여러개일 때가 MIMD 의 대표적인 경우이다.</p>
<p><br></p>
</section>
</section>
<section id="sec-cuda_shared_memory_and_distributed_memory" class="level3">
<h3 class="anchored" data-anchor-id="sec-cuda_shared_memory_and_distributed_memory">공유 메모리와 분산 메모리</h3>
<ul>
<li><p>여러 ALU 가 메모리 공간을 공유하는 시스템을 공유 메모리 시스템이라고 하며, 각 ALU 가 각각의 메모리 공간을 갖고 ALU 간 통신이 필요한 경우 명시적인 통신을 하는 시스템을 분산 메모리 시스템이라고 한다.</p></li>
<li><p>공유 메모리 시스템의 경우 여러 ALU 가 하나의 메모리 공간에 접근하기 때문에 각각의 작업이 간섭을 일으 킬 수 있다. 이 경우 각각의 ALU 의 작업 순서를 맞추는 것을 동기화(synchoronization) 이라고 한다.</p></li>
<li><p>GPU 도 공유 메모리 시스템을 사용한다.</p></li>
</ul>
<p><br></p>
</section>
<section id="sec-cuda_simt" class="level3">
<h3 class="anchored" data-anchor-id="sec-cuda_simt">SIMT</h3>
<p>GPU 는 SISD 아키텍쳐와 공유 메모리 시스템을 사용하지만 일반적으로 SIMT(Single instruction multiple threads) 구조로 정의된다.</p>
<ul>
<li><p>한 스레드 그룹 내의 스레드들은 하나의 제어 유닛으로 제어된다.</p></li>
<li><p>각 스레드는 자신만의 제어 문맥을 가진다.</p></li>
<li><p>스레드 그룹 내 스레드 들 사이의 분기가 허용된다.</p></li>
</ul>
<p><br></p>
</section>
</section>
<section id="gpu-사용의-이점" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="gpu-사용의-이점"><span class="header-section-number">2</span> GPU 사용의 이점</h2>
<section id="cpu-와-gpu-의-목적" class="level3">
<h3 class="anchored" data-anchor-id="cpu-와-gpu-의-목적">CPU 와 GPU 의 목적</h3>
<div id="tbl-cuda_cpu_and_gpu_comparision" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-cuda_cpu_and_gpu_comparision-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
표&nbsp;1: CPU 와 GPU 의 비교
</figcaption>
<div aria-describedby="tbl-cuda_cpu_and_gpu_comparision-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">CPU</th>
<th style="text-align: center;">GPU</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">지향</td>
<td style="text-align: center;">각 코어의 성능 향상</td>
<td style="text-align: center;">병렬 처리 성능 향상</td>
</tr>
<tr class="even">
<td style="text-align: center;">코어 수</td>
<td style="text-align: center;">1 ~ 수십개</td>
<td style="text-align: center;">수백 ~ 수천개</td>
</tr>
<tr class="odd">
<td style="text-align: center;">개별 코어의 성능</td>
<td style="text-align: center;">높다</td>
<td style="text-align: center;">낮다</td>
</tr>
<tr class="even">
<td style="text-align: center;">구조</td>
<td style="text-align: center;">SISD, MIMD</td>
<td style="text-align: center;">SIMT</td>
</tr>
<tr class="odd">
<td style="text-align: center;">공간 분배</td>
<td style="text-align: center;">캐시 및 제어 유닛에 많이</td>
<td style="text-align: center;">연산 유닛에 많이</td>
</tr>
<tr class="even">
<td style="text-align: center;">메모리 크기</td>
<td style="text-align: center;">수 GB 이상</td>
<td style="text-align: center;">수 GB 이상</td>
</tr>
<tr class="odd">
<td style="text-align: center;">메모리 접근</td>
<td style="text-align: center;">접근 지연 시간 최적화</td>
<td style="text-align: center;">메모리 대역폭 최대화</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p><br></p>
<p>이것을 정리하면 다음과 같다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 75%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">장치</th>
<th style="text-align: left;">기본 목적</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">CPU</td>
<td style="text-align: left;">스레드를 최대한 빠르게 처리. 최대 수십개의 스레드를 병렬적으로 처리 할 수 있음.</td>
</tr>
<tr class="even">
<td style="text-align: center;">GPU</td>
<td style="text-align: left;">수천개의 스레드를 를 병렬적으로 최대한 빠르게. 단일 스레드는 느리더라도 throughput 을 최대한으로</td>
</tr>
</tbody>
</table>
<p><br></p>
<ul>
<li><p>CPU 에 비해 상대적으로 캐싱과 흐름 제어보다 데이터 처리에 더 많은 트랜지스터를 사용한다.</p></li>
<li><p>아래 그림은 CPU 와 GPU 칩의 resource 분배를 보여준다. (source : <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/">CUDA C Programming guide</a> )</p></li>
</ul>
<p><br></p>
<div id="fig-cuda-gpu" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-cuda-gpu-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://docs.nvidia.com/cuda/cuda-c-programming-guide/_images/gpu-devotes-more-transistors-to-data-processing.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-cuda-gpu-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;1: The GPU Devotes More Transistors to Data Processing
</figcaption>
</figure>
</div>
<p><br></p>
<p>데이터 처리에 더 많은 트랜지스터를 할당하면 예를 들어 부동 소수점 계산의 병렬 계산처리에 유용하다. GPU는 긴 메모리 액세스 대기 시간을 피하기 위해 대용량 데이터 캐시와 복잡한 흐름 제어에 의존하는 대신 계산을 통해 메모리 액세스 대기 시간을 숨길 수 있다. 대용량 데이터 케시와 복잡한 흐름제어 둘 다 트랜지스터 측면에서 비용이 많이 든다.</p>
<p><br></p>
<p>일반적으로 애플리케이션은 병렬적인 부분과 순차적인 부분이 혼합되어 있으므로 시스템은 전반적인 성능을 극대화하기 위해 GPU와 CPU를 혼합하여 설계된다. 높은 수준의 병렬성을 갖춘 애플리케이션은 GPU의 이러한 대규모 병렬적 특성을 활용하여 CPU보다 더 높은 성능을 달성할 수 있다.</p>
<p><br></p>
</section>
</section>
<section id="cuda-a-general-purpose-parallel-computing-platform-and-programming-model" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="cuda-a-general-purpose-parallel-computing-platform-and-programming-model"><span class="header-section-number">3</span> CUDA®: A General-Purpose Parallel Computing Platform and Programming Model</h2>
<ul>
<li>CUDA : 범용 병렬 컴퓨팅 플랫폼이자 NVIDIA GPU의 병렬 컴퓨팅 엔진을 활용하는 프로그래밍 모델</li>
</ul>
<p><br></p>
<div id="fig-cuda-application" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-cuda-application-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://docs.nvidia.com/cuda/cuda-c-programming-guide/_images/gpu-computing-applications.png" class="img-fluid figure-img" width="900">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-cuda-application-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;2: GPU Computing Applications. CUDA is designed to support various languages and application programming interfaces.
</figcaption>
</figure>
</div>
<p><br></p>
</section>
<section id="확장가능한-프로그래밍-모델" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="확장가능한-프로그래밍-모델"><span class="header-section-number">4</span> 확장가능한 프로그래밍 모델</h2>
<ul>
<li><p>Multicore(CPU) 와 Manycore(GPU) 의 등장으로 처리 장치의 주류가 병렬 시스템이 되었으며, 3D 그래픽 응용 프로그램이 병렬성을 투명하게 확장하여 코어 수가 매우 다양한 많은 코어 GPU로 확장되는 것처럼 이런 병렬성을 투명하게 확장하여 증가하는 프로세서 코어 수를 활용하는 애플리케이션 소프트웨어를 개발하는 것이 목표가 되었다.</p></li>
<li><p>CUDA 병렬 프로그래밍 모델은 C 와 같은 표준 프로그래밍 언어에 익숙한 프로그래머에게 낮은 학습 곡선을 유지하면서 이러한 과제를 극복하도록 설계되었다.</p></li>
<li><p>핵심에는 스레드 그룹, 공유 메모리, 배리어 동기화의 계층 구조라는 세 가지 핵심 추상화가 있으며, 이는 단순히 최소한의 언어 확장 세트로 프로그래머에게 주어진다.</p></li>
<li><p>이러한 추상화는 거친 데이터 병렬성과 작업 병렬성 내에 포개어진 미세한 데이터 병렬성과 스레드 병렬성을 제공한다. 이는 프로그래머가 문제를 스레드 블록으로 독립적으로 병렬로 해결할 수 있는 거친 하위 문제로 분할하고, 각 하위 문제를 블록 내의 모든 스레드가 협력하여 병렬로 해결할 수 있는 더 미세한 부분으로 분할하도록 안내한다.</p></li>
<li><p>이 분해는 각 하위 문제를 해결할 때 스레드가 협력할 수 있도록 하여 언어 표현력을 보존하고 동시에 자동 확장성을 가능하게 한다. 실제로 각 스레드 블록은 GPU 내의 사용 가능한 모든 멀티프로세서에서 어떤 순서로든 동시에 또는 순차적으로 예약될(scheduled) 수 있으므로 컴파일된 CUDA 프로그램은 <a href="#fig-cuda_scalability" class="quarto-xref">그림&nbsp;3</a> 에서 설명한 대로 멀티프로세서의 갯수가 몇개든 실행할 수 있으며 런타임 시스템만 물리적인 멀티프로세서 수를 알면 된다.</p></li>
<li><p>이 확장 가능한 프로그래밍 모델을 사용하면 GPU 아키텍처가 멀티프로세서 수와 메모리 파티션을 간단히 확장하여 광범위한 시장 범위에 걸쳐 확장할 수 있다. 고성능 매니아용 GeForce GPU와 전문가용 Quadro 및 Tesla 컴퓨팅 제품부터 다양한 저렴한 주류 GeForce GPU까지 다양합니다(모든 CUDA 지원 GPU 목록은 <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/#cuda-enabled-gpus">CUDA 지원 GPU</a> 참조).</p></li>
</ul>
<p><br></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
노트
</div>
</div>
<div class="callout-body-container callout-body">
<p>GPU는 스트리밍 멀티프로세서(streaming multiprocessor, SM) 배열을 중심으로 구축됩니다(자세한 내용은 <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/#hardware-implementation">하드웨어 구현</a> 참조). 멀티스레드 프로그램은 서로 독립적으로 실행되는 스레드 블록으로 분할되므로 멀티프로세서가 더 많은 GPU가 멀티프로세서가 적은 GPU보다 자동으로 프로그램을 더 짧은 시간 내에 실행합니다.</p>
</div>
</div>
<p><br></p>
<div id="fig-cuda_scalability" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-cuda_scalability-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://docs.nvidia.com/cuda/cuda-c-programming-guide/_images/automatic-scalability.png" class="img-fluid figure-img" width="400">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-cuda_scalability-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;3: Automatic Scalability
</figcaption>
</figure>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/julia-kaeri\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../../src/gpu/gpu.html" class="pagination-link" aria-label="GPU &amp; CUDA">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">GPU &amp; CUDA</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../../src/gpu/cuda/02_programming_model.html" class="pagination-link" aria-label="Programming Model">
        <span class="nav-page-text">Programming Model</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>