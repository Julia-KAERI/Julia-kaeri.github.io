<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Science &amp; Programming - CUDA.jl 커널 프로그래밍</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../src/gpu/cuda.jl/cuda_jl_performance_tips.html" rel="next">
<link href="../../../src/gpu/cuda.jl/cuda_jl_array_programming.html" rel="prev">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Science &amp; Programming</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../src/topics/topics.html"> 
<span class="menu-text">주제별</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../src/tools/tools.html"> 
<span class="menu-text">Tools</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../../src/gpu/gpu.html" aria-current="page"> 
<span class="menu-text">GPU &amp; CUDA</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../src/posts/index.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
    <a href="mailto:julia.kaeri@gmail.com" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-envelope"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../src/gpu/cuda.jl/cuda_jl_array_programming.html">CUDA.jl</a></li><li class="breadcrumb-item"><a href="../../../src/gpu/cuda.jl/cuda_jl_kernel_programming.html">CUDA.jl 커널 프로그래밍</a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../src/gpu/gpu.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">GPU &amp; CUDA</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">CUDA</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../src/gpu/cuda/01_introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../src/gpu/cuda/02_programming_model.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Programming Model</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../src/gpu/cuda/03_programming_interface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Programming Interface</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">CUDA.jl</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../src/gpu/cuda.jl/cuda_jl_array_programming.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">CUDA.jl 배열 처리</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../src/gpu/cuda.jl/cuda_jl_kernel_programming.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">CUDA.jl 커널 프로그래밍</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../src/gpu/cuda.jl/cuda_jl_performance_tips.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">CUDA.jl 성능 팁</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#sec-cudajl_kernel" id="toc-sec-cudajl_kernel" class="nav-link active" data-scroll-target="#sec-cudajl_kernel"><span class="header-section-number">1</span> 커널</a></li>
  <li><a href="#sec-cudalj_kernel_io" id="toc-sec-cudalj_kernel_io" class="nav-link" data-scroll-target="#sec-cudalj_kernel_io"><span class="header-section-number">2</span> 커널 입력과 출력</a></li>
  <li><a href="#sec-cudajl_kernel_configuration_and_indexing" id="toc-sec-cudajl_kernel_configuration_and_indexing" class="nav-link" data-scroll-target="#sec-cudajl_kernel_configuration_and_indexing"><span class="header-section-number">3</span> 커널 구동 설정과 인덱싱</a></li>
  <li><a href="#sec-cudajl_kernel_compilation_requirements" id="toc-sec-cudajl_kernel_compilation_requirements" class="nav-link" data-scroll-target="#sec-cudajl_kernel_compilation_requirements"><span class="header-section-number">4</span> 커널 컴파일 요건</a></li>
  <li><a href="#sec-cudajl_synchronization" id="toc-sec-cudajl_synchronization" class="nav-link" data-scroll-target="#sec-cudajl_synchronization"><span class="header-section-number">5</span> 동기화 (Synchronization)</a>
  <ul class="collapse">
  <li><a href="#sec-cudajl_shared_memory" id="toc-sec-cudajl_shared_memory" class="nav-link" data-scroll-target="#sec-cudajl_shared_memory">공유 메모리 (Shared memory)</a></li>
  <li><a href="#sec-cudajl_boundary_check" id="toc-sec-cudajl_boundary_check" class="nav-link" data-scroll-target="#sec-cudajl_boundary_check">경계 확인</a></li>
  </ul></li>
  <li><a href="#sec-cudalj_standard_output" id="toc-sec-cudalj_standard_output" class="nav-link" data-scroll-target="#sec-cudalj_standard_output"><span class="header-section-number">6</span> 표준 출력</a></li>
  <li><a href="#sec-cudajl_random_number" id="toc-sec-cudajl_random_number" class="nav-link" data-scroll-target="#sec-cudajl_random_number"><span class="header-section-number">7</span> 난수 발생</a></li>
  <li><a href="#sec-cudajl_atomics" id="toc-sec-cudajl_atomics" class="nav-link" data-scroll-target="#sec-cudajl_atomics"><span class="header-section-number">8</span> Atomics</a>
  <ul class="collapse">
  <li><a href="#sec_cudajl_atomics_low_level" id="toc-sec_cudajl_atomics_low_level" class="nav-link" data-scroll-target="#sec_cudajl_atomics_low_level">저수준</a></li>
  <li><a href="#sec-cudajl_atomic_high_level" id="toc-sec-cudajl_atomic_high_level" class="nav-link" data-scroll-target="#sec-cudajl_atomic_high_level">고수준</a></li>
  </ul></li>
  <li><a href="#sec-cudajl_warp_intrinsics" id="toc-sec-cudajl_warp_intrinsics" class="nav-link" data-scroll-target="#sec-cudajl_warp_intrinsics"><span class="header-section-number">9</span> 워프 내장 함수(Warp intrinsics)</a></li>
  <li><a href="#sec-cudajl_dynamic_parallelism" id="toc-sec-cudajl_dynamic_parallelism" class="nav-link" data-scroll-target="#sec-cudajl_dynamic_parallelism"><span class="header-section-number">10</span> 동적 병렬성 (Dynamic parallelism)</a></li>
  <li><a href="#sec-cudajl_cooperative_groups" id="toc-sec-cudajl_cooperative_groups" class="nav-link" data-scroll-target="#sec-cudajl_cooperative_groups"><span class="header-section-number">11</span> 협력 그룹</a>
  <ul class="collapse">
  <li><a href="#sec-cudajl_indexing" id="toc-sec-cudajl_indexing" class="nav-link" data-scroll-target="#sec-cudajl_indexing">인덱싱</a></li>
  <li><a href="#sec-cudajl_synchronization" id="toc-sec-cudajl_synchronization" class="nav-link" data-scroll-target="#sec-cudajl_synchronization">동기화</a></li>
  <li><a href="#sec-cudajl_collective_operations" id="toc-sec-cudajl_collective_operations" class="nav-link" data-scroll-target="#sec-cudajl_collective_operations">집합 연산</a></li>
  <li><a href="#sec-cudajl_data_transfer" id="toc-sec-cudajl_data_transfer" class="nav-link" data-scroll-target="#sec-cudajl_data_transfer">데이터 전송</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../src/gpu/cuda.jl/cuda_jl_array_programming.html">CUDA.jl</a></li><li class="breadcrumb-item"><a href="../../../src/gpu/cuda.jl/cuda_jl_kernel_programming.html">CUDA.jl 커널 프로그래밍</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">CUDA.jl 커널 프로그래밍</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="sec-cudajl_kernel" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="sec-cudajl_kernel"><span class="header-section-number">1</span> 커널</h2>
<p>CPU 에서 호출하고 GPU 에서 실행되는 함수를 커널(kernel) 이라고 한다. 커널은 보통의 julia 함수처럼 정의한다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">my_kernel</span>()</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>커널을 실행하기 위해서는 <code>@cuda</code> 매크로를 사용한다.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="pp">@cuda</span> my_kernel</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>위의 명령을 실행하면 <code>my_kernel</code> 함수가 컴파일되며 현재의 GPU 에서 실행된다.</p>
<p><br></p>
<p><code>@cuda</code> 매크로에 <code>launch=false</code> 인자를 전달하면 컴파일만 되고 실행하지 않으며 호출 가능한 객체를 리턴한다.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> k <span class="op">=</span> <span class="pp">@cuda</span> launch<span class="op">=</span><span class="cn">false</span> <span class="fu">my_kernel</span>()</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>CUDA.HostKernel <span class="cf">for</span> <span class="fu">my_kernel</span>()</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> CUDA.<span class="fu">registers</span>(k)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="fl">4</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> <span class="fu">k</span>()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
</section>
<section id="sec-cudalj_kernel_io" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="sec-cudalj_kernel_io"><span class="header-section-number">2</span> 커널 입력과 출력</h2>
<p>GPU 커널은 반환값을 가질 수 없다. 즉 항상 <code>return</code> 이거나 <code>return nothing</code> 이어야 한다. 커널과 통신하는 유일한 방법은 <code>CuArray</code> 를 쓰는 것 뿐이다.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">my_kernel</span>(a)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    a[<span class="fl">1</span>] <span class="op">=</span> <span class="fl">42</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="fu">CuArray</span><span class="dt">{Int}</span>(<span class="cn">undef</span>, <span class="fl">1</span>);</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="pp">@cuda</span> <span class="fu">my_kernel</span>(a);</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>a</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>42</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
</section>
<section id="sec-cudajl_kernel_configuration_and_indexing" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="sec-cudajl_kernel_configuration_and_indexing"><span class="header-section-number">3</span> 커널 구동 설정과 인덱싱</h2>
<p><code>@cuda</code> 를 통해 커널을 구동하면 단일 스레드만 시작되므로 그다지 유용하지 않다. <span class="citation" data-cites="cuda">(<a href="#ref-cuda" role="doc-biblioref"><strong>cuda?</strong></a>)</span> 에 대한 <code>threads</code> 및 <code>blocks</code> 키워드 인수를 사용하면 다수의 스레드를 구동할 수 있으며, 커널 내에서는 인덱싱 내장 함수를 사용하여 각 스레드의 계산을 차별화 할 수 있다.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">my_kernel</span>(a)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="fu">threadIdx</span>().x</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    a[i] <span class="op">=</span> <span class="fl">42</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="fu">CuArray</span><span class="dt">{Int}</span>(<span class="cn">undef</span>, <span class="fl">5</span>);</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="pp">@cuda</span> threads<span class="op">=</span><span class="fu">length</span>(a) <span class="fu">my_kernel</span>(a);</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>a</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>5-element CuArray{Int64, 1, CUDA.DeviceMemory}:</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a> 42</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a> 42</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a> 42</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a> 42</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a> 42</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>위에 표시된 대로, CUDA C 의 <code>threadIdx</code> 등의 값은 <code>x</code>, <code>y</code>, <code>z</code> 필드가 있는 <code>NamedTuple</code> 을 반환하는 함수로 사용할 수 있다. 이런 내장 함수는 1 부터 시작하는 인덱스를 반환한다.</p>
<p><br></p>
</section>
<section id="sec-cudajl_kernel_compilation_requirements" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="sec-cudajl_kernel_compilation_requirements"><span class="header-section-number">4</span> 커널 컴파일 요건</h2>
<p>사용자 정의 커널이 작동하기 위해서는 어떤 요건을 충족해야 한다.</p>
<ul>
<li><p>메모리는 GPU에서 접근 가능해야 한다. 이는 <code>CuArray</code> 등을 사용하여 강제할 수 있다. 사용자 지정 구조체는 해당 <a href="https://cuda.juliagpu.org/stable/tutorials/custom_structs/">튜토리얼</a>에서 설명한 대로 이식할 수 있다.</p></li>
<li><p>런타임 디스패치는 불가하며 모든 함수 호출은 컴파일 타임에 결정되어야 합니다. 여기서 런타임 디스패치는 완전히 특정되지 않은 함수에 의해 도입될 수도 있다는 점에 유의해야 한다. <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Be-aware-of-when-Julia-avoids-specializing">Julia 매뉴얼</a> 을 참고하고 다음 예를 보자.</p></li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">my_inner_kernel!</span>(f, t) <span class="co"># does not specialize</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    t <span class="op">.=</span> <span class="fu">f</span>.(t)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">my_outer_kernel</span>(f, a)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="fu">threadIdx</span>().x</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">my_inner_kernel!</span>(f, <span class="pp">@view</span> a[i, <span class="op">:</span>])</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="cn">nothing</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> CUDA.<span class="fu">rand</span>(<span class="dt">Int</span>, (<span class="fl">2</span>,<span class="fl">2</span>))</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span>(x) <span class="op">=</span> x</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="pp">@cuda</span> threads<span class="op">=</span><span class="fu">size</span>(a, <span class="fl">1</span>) <span class="fu">my_outer_kernel</span>(id, a)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>마지막 줄 실행에서 에러가 발생하는데 이는 아래와 같이 회피 할 수 있다.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">my_inner_kernel!</span>(f<span class="op">::</span><span class="dt">F</span>, t<span class="op">::</span><span class="dt">T</span>) <span class="kw">where</span> {F,T}</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    t <span class="op">.=</span> <span class="fu">f</span>.(t)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">my_outer_kernel</span>(f, a)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="fu">threadIdx</span>().x</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">my_inner_kernel!</span>(f, <span class="pp">@view</span> a[i, <span class="op">:</span>])</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="cn">nothing</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> CUDA.<span class="fu">rand</span>(<span class="dt">Int</span>, (<span class="fl">2</span>,<span class="fl">2</span>))</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span>(x) <span class="op">=</span> x</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="pp">@cuda</span> threads<span class="op">=</span><span class="fu">size</span>(a, <span class="fl">1</span>) <span class="fu">my_outer_kernel</span>(id, a)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>단지 첫번째 함수 <code>my_inner_kernel!</code> 의 인자의 함수가 파라미터로 특정되었을 뿐이다.</p>
<p><br></p>
</section>
<section id="sec-cudajl_synchronization" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="sec-cudajl_synchronization"><span class="header-section-number">5</span> 동기화 (Synchronization)</h2>
<p>블록에서 스레드를 동기화하려면 <code>sync_threads()</code> 함수를 사용한다. predicate 를 취하는 보다 고급 변형도 사용 가능하다.</p>
<ul>
<li><p><code>sync_threads_count(pred)</code> : <code>pred</code> 가 <code>true</code> 인 스레드의 갯수를 반환한다.</p></li>
<li><p><code>sync_threads_and(pred)</code> : 모든 스레드에서 <code>pred</code> 가 참이면 <code>true</code> 를 반환한다.</p></li>
<li><p><code>sync_threads_or(pred)</code> : 어떤 스레드에서 <code>pred</code> 가 참이면 <code>true</code> 를 반환한다.</p></li>
</ul>
<p>여러 스레드 동기화 장벽을 유지하려면 장벽을 식별하는 정수 인수를 취하는 <code>barrier_sync</code> 함수를 사용한다.</p>
<p>워프에서 레인을 동기화하려면 <code>sync_warp()</code> 함수를 사용합니다. 이 함수는 참여할 레인을 선택하는 마스크를 취합니다(기본값은 <code>FULL_MASK</code>).</p>
<p>실행 장벽이 아닌 메모리 장벽만 필요한 경우 펜스 내장 함수를 사용합니다.</p>
<ul>
<li><p><code>threadfence_block</code> : 블럭 내의 모든 쓰레드에서 메모리 정렬을 보장한다.</p></li>
<li><p><code>threadfence</code> : 디바이스 내의 모든 쓰레드에서 메모리 정렬을 보장한다.</p></li>
<li><p><code>threadfence_system</code> : 호스트 스레드와 peer 디바이스를 포함한 모든 스레드에서 메모리 정렬을 보장한다.</p></li>
</ul>
<p><br></p>
<section id="sec-cudajl_shared_memory" class="level3">
<h3 class="anchored" data-anchor-id="sec-cudajl_shared_memory">공유 메모리 (Shared memory)</h3>
<p>스레드 간 통신을 위해 공유 메모리로 백업된 디바이스 배열은 <code>CuStaticSharedArray</code> 함수를 통해 할당될 수 있다. 다음은 배열의 순서를 바꾸는 커널이다. 커널 내의 <code>b</code> 가 스레드간 통신을 위해 공유 메모리로 백업된 배열이다.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">reverse_kernel</span>(a<span class="op">::</span><span class="dt">CuDeviceArray{T}</span>) <span class="kw">where</span> T</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="fu">threadIdx</span>().x</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> <span class="fu">CuStaticSharedArray</span>(T, <span class="fl">2</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    b[<span class="fl">2</span><span class="op">-</span>i<span class="op">+</span><span class="fl">1</span>] <span class="op">=</span> a[i]</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">sync_threads</span>()</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    a[i] <span class="op">=</span> b[i]</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="fu">cu</span>([<span class="fl">1</span>,<span class="fl">2</span>])</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="pp">@cuda</span> threads <span class="op">=</span> <span class="fl">2</span> <span class="fu">reverse_kernel</span>(a)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>결과를 출력해보면 <code>a</code> 의 순서가 바뀌었음을 알 수 있다.</p>
<p><br></p>
<p>공유 메모리의 크기를 미리 알 수 없고 각 크기에 대해 커널을 다시 컴파일하고 싶지 않은 경우 대신 <code>CuDynamicSharedArray</code> 타입을 사용할 수 있다. 이를 위해서는 공유 메모리의 크기(바이트)를 커널에 인수로 전달해야 한다.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">reverse_kernel</span>(a<span class="op">::</span><span class="dt">CuDeviceArray{T}</span>) <span class="kw">where</span> T</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="fu">threadIdx</span>().x</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> <span class="fu">CuDynamicSharedArray</span>(T, <span class="fu">length</span>(a))</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    b[<span class="fu">length</span>(a)<span class="op">-</span>i<span class="op">+</span><span class="fl">1</span>] <span class="op">=</span> a[i]</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">sync_threads</span>()</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    a[i] <span class="op">=</span> b[i]</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="fu">cu</span>([<span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span>])</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="pp">@cuda</span> threads<span class="op">=</span><span class="fu">length</span>(a) shmem<span class="op">=</span><span class="fu">sizeof</span>(a) <span class="fu">reverse_kernel</span>(a)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>동적 공유 메모리를 사용하는 다수의 배열이 필요한 경우 후속 <code>CuDynamicSharedArray</code> 생성자에 공유 메모리 시작부터 바이트 단위의 오프셋을 나타내는 오프셋 매개변수를 전달한다. <code>@cuda</code> 에 대한 <code>shmem</code> 키워드는 모든 배열에서 사용하는 총 공유 메모리 양이어야 합니다.</p>
<p><br></p>
</section>
<section id="sec-cudajl_boundary_check" class="level3">
<h3 class="anchored" data-anchor-id="sec-cudajl_boundary_check">경계 확인</h3>
<p>기본적으로 <code>CuDeviceArray</code> 를 인덱싱하면 경계 검사를 수행하고 인덱스가 경계를 벗어나면 오류를 발생시키는데 이는 비용이 많이 드는 작업이므로 인덱스가 경계 내에 있다는 것이 확실하다면 일반적인 배열과 마찬가지로 <code>@inbounds</code> 를 사용 할 수 있다.</p>
<p><br></p>
</section>
</section>
<section id="sec-cudalj_standard_output" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="sec-cudalj_standard_output"><span class="header-section-number">6</span> 표준 출력</h2>
<p><code>CUDA.jl</code> 커널은 아직 Julia의 표준 입출력과 통합되지 않았지만 커널에서 표준 출력으로 인쇄하기 위한 몇 가지 기본 기능을 제공한다.</p>
<ul>
<li><p><code>@cuprintf</code>: 표준 출력으로 형식화된 출력을 내보낸다.</p></li>
<li><p><code>@cuprint</code> 와 <code>@cuprintln</code> : 문자를 포함한 값을 표준 출력으로 내보낸다.</p></li>
<li><p><code>@cushow</code> : 객체의 이름과 값을 출력한다.</p></li>
</ul>
<p><code>@cuprintf</code> 매크로는 모든 형식 옵션을 지원하지 않는다. 자세한 내용은 <code>printf</code> 에 대한 NVIDIA 설명서를 참조하라. <code>@cuprintln</code> 과 <code>CUDA.jl</code> 을 통해 모든 값을 적절한 문자열 표현으로 변환하는 것이 더 편리한 경우가 많다.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> <span class="pp">@cuda</span> threads<span class="op">=</span><span class="fl">2</span> (()<span class="fu">-&gt;</span>(<span class="pp">@cuprintln</span>(<span class="st">"Hello, I'm thread </span><span class="sc">$</span>(<span class="fu">threadIdx</span>().x)<span class="st">!"</span>); <span class="cf">return</span>))()</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>Hello, I<span class="op">'</span>m thread <span class="fl">1</span>!</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>Hello, I<span class="op">'</span>m thread <span class="fl">2</span>!</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br> 단순히 값만 출력하길 원한다면, which can be useful during debugging, <code>@cushow</code> 를 사용하라.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> <span class="pp">@cuda</span> threads<span class="op">=</span><span class="fl">2</span> (()<span class="fu">-&gt;</span>(<span class="pp">@cushow</span> <span class="fu">threadIdx</span>().x; <span class="cf">return</span>))()</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>(<span class="fu">threadIdx</span>()).x <span class="op">=</span> <span class="fl">1</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>(<span class="fu">threadIdx</span>()).x <span class="op">=</span> <span class="fl">2</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이것들은 매우 제한된 수의 유형만 지원한다는 점에 유의하라. 따라서 디버깅 목적으로만 사용하는 것이 좋다. P</p>
<p><br></p>
</section>
<section id="sec-cudajl_random_number" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="sec-cudajl_random_number"><span class="header-section-number">7</span> 난수 발생</h2>
<p>커널에서 <code>rand</code> 혹은 <code>randn</code> 함수를 통해 난수 샘플을 얻을 수 있으며 이 때 GPU-호환 난수 발생기(GPU-compatible random number generator) 가 사용된다. API는 CPU에서 사용되는 난수 생성기와 매우 유사하지만 병렬 RNG의 설계에서 비롯된 몇 가지 차이점과 고려해야할 항이 있다.</p>
<ul>
<li><p>기본 RNG는 글로벌 상태를 사용한다. 여러개의 인스턴스를 사용하는 것은 정의되지 않은 동작이다.</p></li>
<li><p>커널은 host 에서 전달된 고유한 seed 로 RNG를 자동으로 시드하여 동일한 커널을 여러 번 호출해도 다른 결과가 생성되도록 한다.</p></li>
<li><p><code>Random.seed!</code> 를 호출하여 seed 를 수동으로 지정하는 것이 가능하지만 RNG는 워프 공유 상태를 사용하므로 워프당 최소 하나의 스레드가 seed 되어야 하며 워프 내의 모든 seed 는 동일해야 한다.</p></li>
<li><p>후속 커널 호출이 난수를 계속 발생시켜야 하는 경우 seed 뿐만 아니라 카운터 값도 <code>Random.seed!</code> 를 사용하여 수동으로 구성해야 한다. 여기에 대한 예는 <code>CUDA.jl</code> 의 host 측 RNG를 참조하라.</p></li>
</ul>
<p><br></p>
</section>
<section id="sec-cudajl_atomics" class="level2" data-number="8">
<h2 data-number="8" class="anchored" data-anchor-id="sec-cudajl_atomics"><span class="header-section-number">8</span> Atomics</h2>
<p>CUDA.jl 은 두 레벨의 추상화를 통해 아토믹 연산을 제공한다</p>
<ul>
<li><p>저수준 : <code>atomic_</code> 함수는 직접 hardware instruction 에 매핑한다.</p></li>
<li><p>고수준 : <code>CUDA.@atomic</code> 은 편리한 성분별 연산(element-wise operation) 을 제공한다.</p></li>
</ul>
<p>저수준 추상화는 안정적이고 이후의 동작을 변경하지 않으므로 아토믹 연산을 사용하는 가장 안전한 방법이다. 그러나 이 경우 인터페이스는 제한적이며, 하드웨어가 제공하는 것만 지원하고, 입력 타입이 일차할것을 요구한다. <code>CUDA.@atomic</code> API는 훨씬 더 사용자 친화적이지만 Julia Base 의 <code>@atomic</code> 매크로와 통합되면 어느 시점에서 사라질 것이다.</p>
<p><br></p>
<section id="sec_cudajl_atomics_low_level" class="level3">
<h3 class="anchored" data-anchor-id="sec_cudajl_atomics_low_level">저수준</h3>
<p>저수준 아토믹 내재 함수는 포인터 입력을 사용하며 이는 <code>CuArray</code> 에서 포인터 함수를 호출하여 얻을 수 있다.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> <span class="kw">function</span> <span class="fu">atomic_kernel</span>(a)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>           CUDA.<span class="fu">atomic_add!</span>(<span class="fu">pointer</span>(a), <span class="fu">Int32</span>(<span class="fl">1</span>))</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>           <span class="cf">return</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>       <span class="kw">end</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> a <span class="op">=</span> <span class="fu">cu</span>(<span class="dt">Int32</span>[<span class="fl">1</span>])</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="fl">1</span><span class="op">-</span>element CuArray{<span class="dt">Int32</span>, <span class="fl">1</span>, CUDA.DeviceMemory}<span class="op">:</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> <span class="pp">@cuda</span> <span class="fu">atomic_kernel</span>(a)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> a</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="fl">1</span><span class="op">-</span>element CuArray{<span class="dt">Int32</span>, <span class="fl">1</span>, CUDA.DeviceMemory}<span class="op">:</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a> <span class="fl">2</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>지원되는 아토믹 연산은 다음과 같다.</p>
<ul>
<li><p>이항연산 : <code>add</code>, <code>sub</code>, <code>and</code>, <code>or</code>, <code>xor</code>, <code>min</code>, <code>max</code>, <code>xchg</code></p></li>
<li><p>NVIDIA-특정적인 이항연산 : <code>inc</code>, <code>dec</code></p></li>
<li><p>비교와 교환 : <code>cas</code></p></li>
</ul>
<p>자세한 유형 지원 및 하드웨어 요구 사항은 해당 내장 함수의 설명서를 참조하라.</p>
<p><br></p>
</section>
<section id="sec-cudajl_atomic_high_level" class="level3">
<h3 class="anchored" data-anchor-id="sec-cudajl_atomic_high_level">고수준</h3>
<p>배열에 대한 아토믹 연산을 위해 <code>CUDA.@atomic</code> 매크로를 사용한다.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">atomic_kernel</span>(a)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    CUDA.<span class="pp">@atomic</span> a[<span class="fl">1</span>] <span class="op">+=</span> <span class="fl">1</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> CUDA.<span class="fu">zeros</span>(<span class="fl">3</span>)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="pp">@cuda</span> <span class="fu">atomic_kernel</span>(a)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이 결과로 <code>a</code> 는 다음과 같다.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fl">3</span><span class="op">-</span>element CuArray{<span class="dt">Float32</span>, <span class="fl">1</span>, CUDA.DeviceMemory}<span class="op">:</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a> <span class="fl">0.0</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a> <span class="fl">0.0</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a> <span class="fl">0.0</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이 매크로는 훨씬 더 관대한 특성을 가지며, 입력값을 적절한 타입으로 자동 변환하고, 지원되지 않는 연산에 대해서는 아토믹 비교-교환 루프로 대체된다. 하지만, 이는 <code>CUDA.jl</code> 이 Julia Base의 <code>@atomic</code> 매크로와 통합되면 사라질 가능성이 있다.</p>
<p><br></p>
</section>
</section>
<section id="sec-cudajl_warp_intrinsics" class="level2" data-number="9">
<h2 data-number="9" class="anchored" data-anchor-id="sec-cudajl_warp_intrinsics"><span class="header-section-number">9</span> 워프 내장 함수(Warp intrinsics)</h2>
<p>CUDA의 대부분의 워프 내장 함수는 <code>CUDA.jl</code> 에서 유사한 이름으로 사용할 수 있다. 이들의 동작은 대부분 동일하지만 몇 가지 차이점이 있다. 이들은 <code>1</code> 부터 시작하는 인덱스를 사용하며, 입력을 자동으로 변환하고 분할(일정 부분)하여 더 많은 타입을 지원한다.</p>
<ul>
<li><p>인덱싱 : <code>laneid</code>, <code>lanemask</code>, <code>active_mask</code>, <code>warpsize</code></p></li>
<li><p>셔플 : <code>shfl_sync</code>, <code>shfl_up_sync</code>, <code>shfl_down_sync</code>, <code>shfl_xor_sync</code></p></li>
<li><p>투표 : <code>vote_all_sync</code>, <code>vote_any_sync</code>, <code>vote_unisync</code>, <code>vote_ballot_sync</code></p></li>
</ul>
<p>이 내장 함수들 중 많은 수가 마스크 인수를 필요로 하며, 이는 어떤 레인이 연산에 참여해야 하는지를 나타내는 비트 마스크이다. 모든 레인을 기본값으로 설정하려면 <code>FULL_MASK</code> 상수를 사용하면 된다.</p>
<p><br></p>
</section>
<section id="sec-cudajl_dynamic_parallelism" class="level2" data-number="10">
<h2 data-number="10" class="anchored" data-anchor-id="sec-cudajl_dynamic_parallelism"><span class="header-section-number">10</span> 동적 병렬성 (Dynamic parallelism)</h2>
<p>커널은 일반적으로 호스트에서 실행되지만, 동적 병렬성을 사용하면 커널 내부에서 다른 커널을 실행할 수도 있다. 이는 재귀 알고리즘이나 동적으로 새로운 작업을 생성해야 하는 알고리즘에 유용하다. 동적 병렬성을 활용하면 GPU 내에서 작업 요구 사항에 맞게 추가적인 병렬 작업을 생성하고 실행할 수 있어 유연성과 효율성을 높일 수 있다.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">outer</span>()</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">@cuprint</span>(<span class="st">"Hello "</span>)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">@cuda</span> dynamic<span class="op">=</span><span class="cn">true</span> <span class="fu">inner</span>()</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">inner</span>()</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">@cuprintln</span>(<span class="st">"World!"</span>)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="pp">@cuda</span> <span class="fu">outer</span>();</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>Hello World!</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
<p>커널 내에서는 제한된 하위 집합의 CUDA API만 사용할 수 있다. 여기에는 주로 다음과 같은 기능들이 포함된다.</p>
<ul>
<li><p>동기화 : <code>device_synchronize</code> 함수를 통해 동기화를 수행한다.</p></li>
<li><p>스트림 : <code>CuDeviceStream</code> 생성자와 <code>unsafe_destroy!</code> 소멸자를 사용할 수 있다. 이러한 스트림은 <code>@cuda</code> 매크로를 사용할 때 stream 키워드 인수를 통해 전달할 수 있다.</p></li>
</ul>
<p><br></p>
</section>
<section id="sec-cudajl_cooperative_groups" class="level2" data-number="11">
<h2 data-number="11" class="anchored" data-anchor-id="sec-cudajl_cooperative_groups"><span class="header-section-number">11</span> 협력 그룹</h2>
<p>협력 그룹(cooperative groups)을 사용하면 특정 스레드 구성에 얽매이지 않고, 스레드를 더 동적으로 분할하고 스레드 그룹 간에 통신할 수 있는 병렬 커널을 작성할 수 있습니다. 이 기능은 CUDA.jl에서 비교적 새롭게 도입된 것이며, 아직 협력 그룹 프로그래밍 모델의 모든 측면을 지원하지는 않습니다.</p>
<p>본질적으로, 스레드 인덱스를 수동으로 계산하고 이를 사용하여 계산을 구분하는 대신, 이제 커널 기능은 자신이 속한 그룹을 조회하고, 해당 그룹의 크기, rank 등을 조회할 수 있습니다:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> <span class="kw">function</span> <span class="fu">reverse_kernel</span>(d<span class="op">::</span><span class="dt">CuDeviceArray{T}</span>) <span class="kw">where</span> {T}</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>           block <span class="op">=</span> CG.<span class="fu">this_thread_block</span>()</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>           n <span class="op">=</span> <span class="fu">length</span>(d)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>           t <span class="op">=</span> CG.<span class="fu">thread_rank</span>(block)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>           tr <span class="op">=</span> n<span class="op">-</span>t<span class="op">+</span><span class="fl">1</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>           s <span class="op">=</span> <span class="pp">@inbounds</span> <span class="fu">CuDynamicSharedArray</span>(T, n)</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>           <span class="pp">@inbounds</span> s[t] <span class="op">=</span> d[t]</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>           CG.<span class="fu">sync</span>(block)</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>           <span class="pp">@inbounds</span> d[t] <span class="op">=</span> s[tr]</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>           <span class="cf">return</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>       <span class="kw">end</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> a <span class="op">=</span> <span class="fu">cu</span>([<span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span>])</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a><span class="fl">3</span><span class="op">-</span>element CuArray{<span class="dt">Int64</span>, <span class="fl">1</span>, CUDA.DeviceMemory}<span class="op">:</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a> <span class="fl">2</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a> <span class="fl">3</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> <span class="pp">@cuda</span> threads<span class="op">=</span><span class="fu">length</span>(a) shmem<span class="op">=</span><span class="fu">sizeof</span>(a) <span class="fu">reverse_kernel</span>(a)</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> a</span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a><span class="fl">3</span><span class="op">-</span>element CuArray{<span class="dt">Int64</span>, <span class="fl">1</span>, CUDA.DeviceMemory}<span class="op">:</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a> <span class="fl">3</span></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a> <span class="fl">2</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
<p>아래와 같은 암묵적 그룹이 지원됩니다.</p>
<ul>
<li><p>스레드 블럭 : <code>CG.this_thread_block()</code></p></li>
<li><p>그리드 그룹 : <code>CG.this_grid()</code></p></li>
<li><p>워프 : <code>CG.coalesced_threads()</code></p></li>
</ul>
<p>이런 지원은 클러스터나 multi-grid implicit groups, 그리고 모든 명시적인 (tiled, patitioned) 그룹에는 해당하지 않습니다.</p>
<p>스레드 블록은 모든 장치와 모든 커널에서 지원됩니다. Grid 그룹(<code>CG.this_grid()</code>) 은 전체 그리드를 동기화하는 데 사용할 수 있는데, 이는 일반적으로 불가능하지만 추가적인 주의가 필요합니다. 커널은 <code>@cuda cooperative=true</code> 를 사용하여 협력 모드로 실행되어야 하며, 이는 compute capability 6.0 이상인 장치에서만 지원됩니다. 또한 협력 커널은 장치의 SM(Streaming Multiprocessor) 수만큼의 블록만 실행할 수 있습니다.</p>
<p><br></p>
<section id="sec-cudajl_indexing" class="level3">
<h3 class="anchored" data-anchor-id="sec-cudajl_indexing">인덱싱</h3>
<p>모든 종류의 스레드 그룹은 다음의 인덱스 연산을 지원합니다.</p>
<ul>
<li><p><code>thread_rank</code> : 그룹 내에서 현재 스레드의 랭크를 반환합니다.</p></li>
<li><p><code>num_thread</code> : 그룹의 스레드 개수를 반환합니다.</p></li>
</ul>
<p>추가로 일부 그룹 유형은 추가적인 인덱스 연산을 지원합니다.</p>
<ul>
<li><p>스레드 블럭 : <code>group_index</code>, <code>thread_index</code>, <code>dim_threads</code></p></li>
<li><p>그리드 그룹 : <code>block_rank</code>, <code>num_blocks</code>, <code>block_index</code></p></li>
<li><p>coalesced group : <code>meta_group_rank</code>, <code>meta_group_size</code></p></li>
</ul>
<p>자세한 것은 각 함수의 docstring 을 참조하세요.</p>
<p><br></p>
</section>
<section id="sec-cudajl_synchronization" class="level3">
<h3 class="anchored" data-anchor-id="sec-cudajl_synchronization">동기화</h3>
<p>그룹 객체는 그룹 내 스레드를 동기화하기 위해 <code>CG.sync</code> 연산을 지원합니다.</p>
<p>추가적으로, 스레드 및 그리드 그룹은 더 세분화된 동기화를 위해 <code>CG.barrier_arrive</code> 와 <code>CG.barrier_wait</code> 을 사용하는 배리어(barrier)를 지원합니다. <code>barrier_arrive</code> 를 호출하면 토큰이 반환되며, 이 토큰을 <code>barrier_wait</code> 에 전달하여 동기화를 수행해야 합니다.</p>
<p><br></p>
</section>
<section id="sec-cudajl_collective_operations" class="level3">
<h3 class="anchored" data-anchor-id="sec-cudajl_collective_operations">집합 연산</h3>
<p>특정 집합 연산(즉, 여러 스레드가 수행해야 하는 연산)은 협력 그룹을 사용할 때 더 편리한 API를 제공합니다. 예를 들어, 셔플 셰플링(shuffle) 내재 함수는 일반적으로 스레드 마스크가 필요하지만, 이를 그룹 객체로 대체할 수 있습니다:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">reverse_kernel</span>(d)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    cta <span class="op">=</span> CG.<span class="fu">this_thread_block</span>()</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    I <span class="op">=</span> CG.<span class="fu">thread_rank</span>(cta)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    warp <span class="op">=</span> CG.<span class="fu">coalesced_threads</span>()</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> CG.<span class="fu">thread_rank</span>(warp)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    j <span class="op">=</span> CG.<span class="fu">num_threads</span>(warp) <span class="op">-</span> i <span class="op">+</span> <span class="fl">1</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    d[I] <span class="op">=</span> CG.<span class="fu">shfl</span>(warp, d[I], j)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
<p>아래와 같은 집합 연산이 지원됩니다.</p>
<ul>
<li><p>shuffle: <code>shfl</code>, <code>shfl_down</code>, <code>shfl_up</code></p></li>
<li><p>voting: <code>vote_any</code>, <code>vote_all</code>, <code>vote_ballot</code></p></li>
</ul>
<p><br></p>
</section>
<section id="sec-cudajl_data_transfer" class="level3">
<h3 class="anchored" data-anchor-id="sec-cudajl_data_transfer">데이터 전송</h3>
<p>스레드 블록과 병합된(coalesced) 그룹에서는 비동기 메모리 복사를 수행하기 위해 <code>CG.memcpy_async</code> 함수가 제공됩니다. 현재는 장치에서 공유 메모리로의 복사만 가속화되며, compute capability 8.0 이상인 장치에서만 지원됩니다. 그러나 구현은 우아하게 강등(degrade)되어 동기화 복사로 대체됩니다:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> <span class="kw">function</span> <span class="fu">memcpy_kernel</span>(input<span class="op">::</span><span class="dt">AbstractArray{T}</span>, output<span class="op">::</span><span class="dt">AbstractArray{T}</span>,</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>                              elements_per_copy) <span class="kw">where</span> {T}</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>           tb <span class="op">=</span> CG.<span class="fu">this_thread_block</span>()</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>           local_smem <span class="op">=</span> <span class="fu">CuDynamicSharedArray</span>(T, elements_per_copy)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>           bytes_per_copy <span class="op">=</span> <span class="fu">sizeof</span>(local_smem)</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>           i <span class="op">=</span> <span class="fl">1</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>           <span class="cf">while</span> i <span class="op">&lt;=</span> <span class="fu">length</span>(input)</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>               <span class="co"># this copy can sometimes be accelerated</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>               CG.<span class="fu">memcpy_async</span>(tb, <span class="fu">pointer</span>(local_smem), <span class="fu">pointer</span>(input, i), bytes_per_copy)</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>               CG.<span class="fu">wait</span>(tb)</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>               <span class="co"># do something with the data here</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>               <span class="co"># this copy is always a simple element-wise operation</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>               CG.<span class="fu">memcpy_async</span>(tb, <span class="fu">pointer</span>(output, i), <span class="fu">pointer</span>(local_smem), bytes_per_copy)</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>               CG.<span class="fu">wait</span>(tb)</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>               i <span class="op">+=</span> elements_per_copy</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>           <span class="cf">end</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>       <span class="kw">end</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> a <span class="op">=</span> <span class="fu">cu</span>([<span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">4</span>]);</span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> b <span class="op">=</span> <span class="fu">similar</span>(a);</span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> nb <span class="op">=</span> <span class="fl">2</span>;</span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> <span class="pp">@cuda</span> shmem<span class="op">=</span><span class="fu">sizeof</span>(<span class="fu">eltype</span>(a))<span class="op">*</span>nb <span class="fu">memcpy_kernel</span>(a, b, nb)</span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> b</span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a><span class="fl">4</span><span class="op">-</span>element CuArray{<span class="dt">Int64</span>, <span class="fl">1</span>, CUDA.DeviceMemory}<span class="op">:</span></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a> <span class="fl">2</span></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a> <span class="fl">3</span></span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a> <span class="fl">4</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>위의 예제는 복사가 완료될 때까지 기다린 후 계속 진행하지만, <code>CG.wait_prior</code> 함수를 사용하여 여러 복사를 동시에 진행할 수도 있습니다. 이 함수는 마지막 N개의 복사를 제외한 모든 복사가 완료될 때까지 기다립니다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/julia-kaeri\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../../src/gpu/cuda.jl/cuda_jl_array_programming.html" class="pagination-link" aria-label="CUDA.jl 배열 처리">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">CUDA.jl 배열 처리</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../../src/gpu/cuda.jl/cuda_jl_performance_tips.html" class="pagination-link" aria-label="CUDA.jl 성능 팁">
        <span class="nav-page-text">CUDA.jl 성능 팁</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>