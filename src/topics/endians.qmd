---
title: "엔디언과 네트워크 통신"

number-sections: true
number-depth: 2
crossref:
  chapters: false
---

<br>

## 엔디언 {#sec-topics_endian}

컴퓨터의 모든 데이터와 명령어들은 내부적으로 모두 2진수로 처리되며 각 2진 처리 단위를 비트(bit) 라고 하며, 명령어와 데이터의 단위는 8개의 비트가 모인 바이트(Byte) 이다. 즉 1 Byte = 8 bits 이다. 1 Byte 는 2<sup>8</sup>=256 개의 서로 다른 정보를 표현 할 수 있다.

C/C++ 의 `char` 나 `unsigned char` Julia 의 `UInt8`, `Int8`, 그리고 Python 의 numpy 의 dtype 인 `np.uint8` 이나 `np.int8` 같은 경우는 8 비트 그러니까 1 바이트 단위로 데이터를 저장한다. 그러나 이 타입은 많아야 256 개의 서로 다른 것 이상을 표현 할 수 없기 때문에 여러 바이트의 자료형이 필요하다. 예를 들어 C/C++ 의 부동소수 타입인 `float`  같은 경우는 CPU 에 따라 다르지만 4 바이트 혹은 8 바이트 의 자료형이며 마찬가지로 Julia 의 `Float32` 나 numpy 의 `np.float32` 같은 경우는 4 바이트, 그러니까 32 비트 데이터 타입이다.

엔디언은 여러 바이트로 이루어진 데이터를 어떤 순서로 나열하느냐에 대한 것이다. 컴퓨터의 역사에서 두가지 방법이 있었다. 예를 들어 2 바이트 부호 없는 정수 타입의 `24577` 을 이진수로 16자리까지 표현하면 `01100000 00000001` 이다. 바이트를 구분하기 위해 중간에 공백을 두었다. 컴퓨터 메모리상에 이렇게 저장하는 방식을 리틀 엔디언(little endian) 이라고 한다. 바이트 내의 비트 순서는 그대로 두면서 바이트 순서만 바뀌는 것, 즉 2바이트 부호 없는 정수 타입의 `24577` 을 `00000001 01100000` 로 표현하는 방식을 빅 엔디언(big endian) 이라고 한다. 이것은 2바이트 보다 큰 바이트에도 그대로 적용되는데 리틀 엔디언이 우리가 일반적으로 쓰는 2진수 표현과 동등하다면 빅 엔디언은 역시 바이트 순서가 역전된 방식 (바이트 내의 비트 순서는 리틀 엔디언과 동일하다) 이다.

이게 단순히 역사적 문제이면 좋겠는데, 어떤 컴퓨터는 내부적으로 빅엔디언을, 어떤 컴퓨터는 리틀엔디언을 사용하며 이 두 컴퓨터가 통신할 때 각자의 엔디언에 맞추어 변환하지 않는다면 당연히 오류가 발생한다. 네트워크 전송에는 보통 빅 엔디언을 사용하도록 표준이 정해져 있다. 이를 네트워크 바이트 순서(Network Byte Order) 라고 한다.


- 예를 들어 필자의 컴퓨터는 리틀 엔디언을 사용하지만 데이터를 네트워크 전송할 때는 빅 엔디언으로 전송하는 것이 좋다. 특별한 약속이 없다면 받는 쪽도 당연히 빅 엔디언으로 받는 것으로 알 것이기 때문이다.

- 한 데이터 내의 바이트 배치만 거꾸로 되는 것이지 데이터 자체의 순서가 바뀌는 것은 아니다. 예를 들어 1바이트 문자열 `ABCD` 는 `ABCD` 로 보내면 된다. 

워낙 오래되고, 중요한 사항이기 때문에 각 컴파일러, 인터프리터 들은 엔디언 변환 함수를 제공한다. 

</br>

## 부동소수의 네트워크 전송 {#sec-transmission_of_floating_number}

- [Stackoverflow 관련 스레드](https://stackoverflow.com/questions/16674664/transfer-float-across-network-via-socket)

부동소수를 네트워크로 전송할 때는 정수화하여 보내거나, 문자열로 보내거나 아니면 [google protocol buffers](https://protobuf.dev) 와 같은 정해진 규약에 따라 보내는 것이 좋다. 

- 정수화 하여 보낸다는것은, 예를 들어 당신이 원하는 부동소수의 정밀도가 소숫점 아래 네자리라면 10000 을 곱하여 정수로 만들어 보내고 받는 쪽에서 이 정수를 다시 10000 으로 나누어 사용하는 것을 말한다. 
- 32 비트 부동소수 133.44235 은 4 바이트이지만 문자열 "133.44235" 은 9바이트이다. 부동소수에 따라 더 커질수 있다. 즉 문자열로 보내면 부동소수의 표현은 보존되지만 네트워크 자원을 낭비한다.
- 부동 소수가 아니더라도 google protocol bufers 와 같은 언어와 플랫폼에 독립적인 방식을 사용하는 것은 복잡한 구조의 데이터를 보낼 때 유용하다.  

