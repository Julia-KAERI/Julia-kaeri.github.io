---
title: "인터페이스"

number-sections: true
number-depth: 2
crossref:
  chapters: false
---

반복자(Iterator) 는 컨테이너 타입으로 포함하는 성분을 처음부터 끝까지 하나 하나 접근 할 수 있는 자료구조를 말하며, Julia 에서 제공하는 컨테이너 타입은 대부분 iterator 입니다. 배열이나 튜플과 같이 순서가 정해져 있을 수도 있고 사전과 같이 순서가 임의적일 수는 있지만 어쨌든 하나하나 접근 할 수 있어야 합니다. 다음과 같은 자료형은 정의상 4개의 값을 저장할 수 있는 컨테이너이지만 반복자는 아닙니다.

```julia
struct NonIterator
    first
    second
    third
    final
end
```

Julia 에서 어떤 타입이 반복자라는 것은 그 타입에 대해 아래의 메서드가 정의되어 있다는 것을 말합니다. 아래에서 `state` 는 컨테이너의 아이템과 1대1 대응되는 어떤 값이며 배열의 경우는 인덱스입니다.

| 메서드 | 설명 |
|:-----:|:----------------|
| `iterate(iter)` |	컨테이너의 첫번째 아이템과 상태를 튜플로 반환합니다. 빈 컨테이너의 경우는 `nothing` 을 반환합니다. |
| `iterate(iter, state)` | `state` 에 의히 지정되는 아이템의 다음 아이템과 그 `state` 를 튜플로 반환합니다. 마지막 값일 경우는 `nothing` 을 반환합니다. |

</br>
반복자에 대해 추가로 정의 할 수 있는 메서드에는 다음과 같은 것이 있습니다. 

| 선택적 메서드 | 기본 정의 | 설명 |
|:--------:|:---------:|:-------------------|
| `Base.IteratorSize(IterType)` | `Base.HasLength()` | 길이를 가지면 `Base.HasLength()`, 차원을 가지면 `Base.HasShape{N}()`, 무한개의 사이즈이면 `Base.IsInfinite()`, 크기를 특정할 수 없으면 `Base.SizeUnknown()` 을 반환합니다. |
| `Base.IteratorEltype(IterType)` | `Base.HasEltype()` | `eltype(Itertype)` 이 존재하면 `Base.EltypeUnknown()`, 아니면 `Base.HasEltype()` 을 반환합니다.|
| `eltype(IterType)` | Any | `iterate()` 에 의해 반환되는 첫번째 성분의 타입을 반환합니다. |
| `length(iter)` | (undefined) | 아이템 갯수 |
| `size(iter, [dim])` | (undefined) | 각 차원에서의 아이템 갯수 |


</br>

이제 유용한 반복자를 하나 만들어 봅시다. 신호처리에서 많이 사용하는 베열가운데 로그스케일로 변화하는 배열이 있습니다. matlab 에서의 `logspace` 함수, python 에서의 `numpy.logspace` 함수로 `logspace(a, b, n, base=10)` 는  `base` 의 `a` 승부터 `base` 의 `b` 승까지 로그스케일로 변하는 배열입니다. Julia 에서는 `base .^ range(a,b,n)` 과 그 결과가 같습니다.(정확히 말하면 끝값을 포함 하느냐 하지 않느냐에 따라 다릅니다. Matlab 과 julia 는 포함하며 python 은 포함하지 않습니다.)

이것을 반복자로 만들어 봅시다. 다음과 같습니다.


```julia
struct LogSpacingRange{T}
    start::T
    stop::T
    base::T
    size::Int64

    function LogSpacingRange(start::Real, stop::Real, size::Int64, base::Real)
        @assert base > 1
        @assert size ≥ 1
        ftype = promote_type(typeof(start), typeof(stop))
        if ~(ftype <: AbstractFloat)
            ftype = Float64
        end

        return new{ftype}(start, stop, base, size)
    end
end

Base.size(p::LogSpacingRange) = (p.size, )
Base.length(p::LogSpacingRange) = p.size
Base.iterate(p::LogSpacingRange, state=1) = state > p.size ? nothing : (p[state], state+1)
Base.eltype(p::LogSpacingRange{T}) where {T} = T
Base.IteratorSize(::LogSpacingRange{T}) where {T} = Base.HasLength()
Base.IteratorEltype(::LogSpacingRange{T}) where {T} = Base.HasEltype()

function Base.getindex(p::LogSpacingRange, i::Int64) 
    @assert 0 < i ≤ p.size
    if p.size == 1
        return p.start
    else 
        r = p.start + (p.stop-p.start)/(p.size-1)*(i-1)
        return (p.base)^r
    end
end

function logspace(a, b, n::Integer=10, base::Real=10)
    return LogSpacingRange(a, b, n, base)
end
```

</br>

`logspace(a, b, n=10, base=10)` 함수를 통해 `LogSpacingRange` 타입의 반복자를 생성 할 수 있습니다. 

```julia
for v in logspace(1, 5, 3, 10)
    @show v
end 
```

를 통해 다음과 같은 결과를 얻습니다. 

```txt
v = 10.0
v = 1000.0
v = 100000.0
```

또한 `getindex` 함수를 통해


