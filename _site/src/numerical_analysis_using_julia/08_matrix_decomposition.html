<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.302">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Julia &amp; Numerical Anlaysis - 행렬의 분해</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../src/numerical_analysis_using_julia/09_iterative_method_for_linear_system.html" rel="next">
<link href="../../src/numerical_analysis_using_julia/07_finding_root.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Julia &amp; Numerical Anlaysis</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../src/introduction_to_julia/index.html" rel="" target="">
 <span class="menu-text">Julia 프로그래밍 언어</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../src/numerical_analysis_using_julia/index.html" rel="" target="" aria-current="page">
 <span class="menu-text">Julia 언어를 이용한 수치해석</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../src/image_processing/index.html" rel="" target="">
 <span class="menu-text">영상 처리와 토모그래피</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../src/tools/tools.html" rel="" target="">
 <span class="menu-text">Tools</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
    <a href="mailto:julia.kaeri@gmail.com" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-envelope"></i></a>
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../src/numerical_analysis_using_julia/index.html">Julia 언어를 이용한 수치해석 1부</a></li><li class="breadcrumb-item"><a href="../../src/numerical_analysis_using_julia/08_matrix_decomposition.html">행렬의 분해</a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Julia 언어를 이용한 수치해석 1부</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">들어가며</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/01_numerical_analysis_and_algorithm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">수치해석 (Numerical Analysis) 과 알고리즘 (Algorithm)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/02_notations_and_propositions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2장 수학에 관련된 표기법과 명제들</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/03_linear_system.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">수치해석 입문 : 선형시스템과 다항식</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/04_matrix_algebra.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Julia 에서의 행렬 계산</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/04I_polynomial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">일변수 다항식의 Julia 구현</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/05_interpolation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">다항식을 이용한 보간법</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/05I_interpolation_struct.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">보간법의 구현</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/06_calculus_of_one_variable_function.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">일변수 함수의 미분과 적분</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/06I_Bezier.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Interude : 베지에 곡선(Bézier curve)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/07_finding_root.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">일변수 방정식의 해</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/08_matrix_decomposition.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">행렬의 분해</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/09_iterative_method_for_linear_system.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">반복법을 이용한 선형 시스템의 해를 구하기</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/10_least_square_problem.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">최소자승 문제</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/11_ode_initial_value_problem.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">상미분 방정식의 초기값 문제</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/12_ode_boundary_value_problem.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">상미분 방정식의 경계값 문제</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/A01_appendix_01.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">부록</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#수학적-기초" id="toc-수학적-기초" class="nav-link active" data-scroll-target="#수학적-기초"><span class="header-section-number">1</span> 수학적 기초</a>
  <ul class="collapse">
  <li><a href="#대각-지배-행렬" id="toc-대각-지배-행렬" class="nav-link" data-scroll-target="#대각-지배-행렬">대각 지배 행렬</a></li>
  <li><a href="#positive-definite-행렬" id="toc-positive-definite-행렬" class="nav-link" data-scroll-target="#positive-definite-행렬">Positive Definite 행렬</a></li>
  </ul></li>
  <li><a href="#숄레스키-분해" id="toc-숄레스키-분해" class="nav-link" data-scroll-target="#숄레스키-분해"><span class="header-section-number">2</span> 숄레스키 분해</a>
  <ul class="collapse">
  <li><a href="#boldsymbolllast-분해" id="toc-boldsymbolllast-분해" class="nav-link" data-scroll-target="#boldsymbolllast-분해"><span class="math inline">\(\boldsymbol{LL}^\ast\)</span> 분해</a></li>
  <li><a href="#구현" id="toc-구현" class="nav-link" data-scroll-target="#구현">구현</a></li>
  <li><a href="#boldsymbolldlast-분해" id="toc-boldsymbolldlast-분해" class="nav-link" data-scroll-target="#boldsymbolldlast-분해"><span class="math inline">\(\boldsymbol{LDL}^\ast\)</span> 분해</a></li>
  <li><a href="#sec-crout_decompositioni" id="toc-sec-crout_decompositioni" class="nav-link" data-scroll-target="#sec-crout_decompositioni">크라우트 분해</a></li>
  </ul></li>
  <li><a href="#qr-분해" id="toc-qr-분해" class="nav-link" data-scroll-target="#qr-분해"><span class="header-section-number">3</span> QR 분해</a>
  <ul class="collapse">
  <li><a href="#하우스홀더-행렬" id="toc-하우스홀더-행렬" class="nav-link" data-scroll-target="#하우스홀더-행렬">하우스홀더 행렬</a></li>
  <li><a href="#하우스홀더-변환과-하우스홀더-반사" id="toc-하우스홀더-변환과-하우스홀더-반사" class="nav-link" data-scroll-target="#하우스홀더-변환과-하우스홀더-반사">하우스홀더 변환과 하우스홀더 반사</a></li>
  <li><a href="#하우스홀더-변환과-qr-분해" id="toc-하우스홀더-변환과-qr-분해" class="nav-link" data-scroll-target="#하우스홀더-변환과-qr-분해">하우스홀더 변환과 QR 분해</a></li>
  </ul></li>
  <li><a href="#연습문제" id="toc-연습문제" class="nav-link" data-scroll-target="#연습문제"><span class="header-section-number">4</span> 연습문제</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">행렬의 분해</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>선형 대수학에서 행렬 분해는 행렬을 다른 행렬들의 곱으로 분해하는 것을 말한다. 다양한 행렬 분해 방법이 존재하며, 각각은 특정 유형의 문제 해결에 활용된다. 수치 해석에서는 효율적인 행렬 알고리즘을 구현하는 데 다양한 분해 방법을 사용 할 수 있다. 우리는 이미 LU 분해를 하는 방법과 그 유용성을 알아 보았다. 여기서는 다양한 행렬의 분해에 대해 알아보고자 한다.</p>
<section id="수학적-기초" class="level2 page-columns page-full" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="수학적-기초"><span class="header-section-number">1</span> 수학적 기초</h2>
<section id="대각-지배-행렬" class="level3">
<h3 class="anchored" data-anchor-id="대각-지배-행렬">대각 지배 행렬</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-diagonally_dominat_matrix" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1 (대각 지배 행렬) </strong></span>행렬 <span class="math inline">\(\boldsymbol{A}\in \mathcal{M}_{n \times n}(\mathbb{F})\)</span> 의 각 행의 대각성분의 절대값이 그 행의 대각성분을 제외한 성분의 절대값의 합보다 크면, 즉 각각의 <span class="math inline">\(i=1,\ldots,\,n\)</span> 행에 대해</p>
<p><span class="math display">\[
|A_{ii}| \ge \sum_{j=1,\, j\ne i}^n |A_{ij}|, \qquad i=1,\ldots,\,n
\]</span></p>
<p>이면 이 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 를 <strong>행에 대한 대각 지배 행렬 (row-wise diagonally dominant matrix)</strong>이라 한다. 또한 각 열에대해</p>
<p><span class="math display">\[
|A_{ii}| \ge \sum_{j=1,\, j\ne i}^n |A_{ji}|, \qquad i=1,\ldots,\,n
\]</span></p>
<p>이면 이 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 를 <strong>열에 대한 대각 지배 행렬 (column-wise diagonally dominant matrix)</strong>이라 한다. 행/열 에 대한 대각 지배 행렬의 조건에서 등호 조건을 제외하고 성립하면 <strong>행/열 에 대한 엄격한 대각 지배 행렬 (strictly row-wise/column-wise diagonally dominant matrix)</strong> 이라고 한다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<div id="prp-strictly_diagonallly_dominat_matrix_is_invertible" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1 </strong></span>엄격한 대각 지배 행렬은 가역행렬이다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>행에 대해 엄격한 대각 지배 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 이 가역행렬이면, <span class="math inline">\(\boldsymbol{A}^T\)</span> 는 열에 대해 엄격한 대각 지배 행렬이며 가역행렬이다. 따라서 행에 대해 엄격한 대각 지배 행렬이 가역행렬임을 보이면 된다.</p>
<p><span class="math inline">\(\boldsymbol{A}\in \mathcal{M}_{n \times n}(\mathbb{F})\)</span> 이 행에 대한 엄격한 대각 지배 행렬이라고 하자. <span class="math inline">\(\boldsymbol{A}\)</span> 가 가역행렬이 아니면 <span class="math inline">\(\boldsymbol{Ax}=\boldsymbol{0}\)</span> 을 만족하는 <span class="math inline">\(\boldsymbol{x}\ne \boldsymbol{0}\)</span> 이 존재하지 않으므로 존재한다고 가정하고 모순이 생긴다는 것을 보이자. 이 <span class="math inline">\(\boldsymbol{x}\)</span> 의 성분 가운데 그 절대값이 가장 큰 <span class="math inline">\(|x_k|\ne 0\)</span> 을 찾을 수 있다. <span class="math inline">\(\boldsymbol{Ax}=0\)</span> 이므로, 각각의 <span class="math inline">\(i=1,\ldots,\,n\)</span> 에 대해</p>
<p><span class="math display">\[
\sum_{j=1}^n A_{ij}x_j=0
\]</span></p>
<p>이며, 따라서 <span class="math inline">\(x_k\)</span> 의 <span class="math inline">\(k\)</span> 에 대해</p>
<p><span class="math display">\[
A_{kk}x_k = -\sum_{j=1,\,j \ne k}^n A_{kj}x_j
\]</span></p>
<p>이다. <span class="math inline">\(\boldsymbol{A}\)</span> 가 행에 대해 엄격한 대각 지배 행렬이므로 모든 대각성분은 <span class="math inline">\(0\)</span> 이 아니다. 삼각부등식에 의해,</p>
<p><span class="math display">\[
|A_{kk}| |x_k|  \le \sum_{j=1,\,j\ne k}^n |A_{kj}| |x_j|
\]</span></p>
<p>이 성립하며 <span class="math display">\[
|A_{kk}| \le \sum_{j= 1,\, j \ne k}^n \dfrac{|x_j|}{|x_k|} |A_{kj}| &lt; \sum_{j= 1,\, j \ne k}^n |A_{kj}|
\]</span></p>
<p>이므로 <span class="math inline">\(\boldsymbol{A}\)</span> 가 행에 대해 엄격한 대각 지배 행렬이라는 가정에 위배된다. 따라서 <span class="math inline">\(\boldsymbol{A}\)</span> 는 가역행렬이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<div id="prp-diagonally_dominant_matrix_and_LU_factorization" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 2 </strong></span>행에 대해 엄격한 대각 지배 행렬은 피보팅 없이 가우스-요르단 소거법을 수행 할 수 있다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(\boldsymbol{A}\in\mathcal{M}_{n \times n}(\mathbb{F})\)</span> 가 행에 대해 엄격한 대각 지배 행렬일 때 induction 으로 증명한다. 우선 <span class="math inline">\(n=1\)</span> 일 경우는 자명하다. <span class="math inline">\(n\)</span> 에 대해 명제가 성립함을 가정하자. 가우스-요르단 소거법을 첫번째 행을 가준으로 하여 피보팅 없이 두번째 행부터 <span class="math inline">\(n+1\)</span> 번째 행까지 첫번째 열을 소거한 행렬을 <span class="math inline">\(\boldsymbol{A}'\)</span> 이라 하면 <span class="math display">\[
A'_{ij} = A_{ij}- \dfrac{A_{i1}}{A_{11}}A_{1j},\qquad i=2,\ldots,\,n+1 \tag{1}
\]</span></p>
<p>이다.</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{j=2,\, j\ne i}^n |A'_{ij}| &amp;= \sum_{j=2,\, j \ne i} \left|A_{ij}- \dfrac{A_{i1}}{A_{11}}A_{1j}\right| \le \sum_{j=2,\, j \ne i}^n |A_{ij}| + \sum_{j=2,\,j \ne i} \left|\dfrac{A_{i1}}{A_{11}}A_{1j}\right|
\end{aligned}\tag{2}
\]</span></p>
<p>이다. 행에 대한 엄격한 지배행렬이라는 조건으로 부터 다음을 얻는다.</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{j=2,\, j \ne i}^n |A_{ij}| &lt; |A_{ii}| - |A_{i1}|,\\
\sum_{j=2,\, j \ne i}^n |A_{1j}| &lt; |A_{11}| - |A_{1i}|
\end{aligned} \tag{3}
\]</span></p>
<p>위 식을 이용하여 <span class="math inline">\((3)\)</span> 를 보면 <span class="math display">\[
\sum_{j=2,\, j\ne i}^n |A'_{ij}| &lt; |A_{ii}|-|A_{i1}| + \dfrac{|A_{i1}|}{|A_{11}|} \left(|A_{11}| - |A_{1i}|\right) = |A_{ii}| - \dfrac{|A_{i1}|}{|A_{11}|} |A_{1i}| \tag{4}
\]</span></p>
<p>이다. <span class="math inline">\((1)\)</span> 로 부터,</p>
<p><span class="math display">\[
|A'_{ii}| = \left|A_{ii}- \dfrac{A_{i1}}{A_{11}}A_{1i}\right| \ge \left|A_{ii}\right|- \left|\dfrac{A_{i1}}{A_{11}}A_{1i}\right| \tag{5}
\]</span></p>
<p>이므로, <span class="math inline">\((4)\)</span> 와 <span class="math inline">\((5)\)</span> 를 결합하면,</p>
<p><span class="math display">\[
|A'_{ii}| &gt; \sum_{j=2,\, j\ne i}^n |A'_{ij}|
\]</span></p>
<p>이다. 즉 2행 2열부터 <span class="math inline">\(n+1\)</span> 행 <span class="math inline">\(n+1\)</span> 열까지의 <span class="math inline">\(\boldsymbol{A}'\)</span> 의 부분행렬은 행에 대해 엄격한 지배행렬이므로 가정에 의해 피보팅 없이 가우스-조르단 소거법을 수행 할 수 있다. 따라서 임의의 크기의 정사각 행렬이 행에 대해 엄격한 대각 지배 행렬일 때, 피보팅 없이 가우스-조르단 소거법을 수행 할 수 있다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
</section>
<section id="positive-definite-행렬" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="positive-definite-행렬">Positive Definite 행렬</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-positive_definite_matrices" class="theorem definition">
<p><span class="theorem-title"><strong>정의 2 (Positive definite 행렬) </strong></span>행렬 <span class="math inline">\(\boldsymbol{A}\in \mathcal{M}_{n \times n}(\mathbb{F})\)</span> 이 에르미트 행렬이며 모든 <span class="math inline">\(\boldsymbol{x}\in \mathcal{M}_n(\mathbb{F})\)</span>, <span class="math inline">\(\boldsymbol{x}\ne \boldsymbol{0}\)</span> 에 대해 <span class="math inline">\(\langle \boldsymbol{Ax},\boldsymbol{x}\rangle &gt; 0\)</span> 일 경우, 즉 <span class="math inline">\(\boldsymbol{x}^T\boldsymbol{Ax}&gt;0\)</span> 일 경우 <span class="math inline">\(\boldsymbol{A}\)</span> 를 <strong>positive definite</strong> 라 한다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p>Positive definite 행렬은 복소수체에서 정의할 수도 있으나 여기서는 실수체에서 정의된 행렬만 생각하기로 한다. Positive definite 행렬은 정의상 대칭행렬이므로 <a href="../../src/numerical_analysis_using_julia/02_notations_and_propositions.html#">Interude : 수학에 관련된 표기법과 명제들</a> 의 <a href="../../src/numerical_analysis_using_julia/02_notations_and_propositions.html#prp-properties_of_hermitian_matrix">실수체에서 정의된 행렬의 스펙트럼 정리</a> 를 만족한다. 즉 모든 <span class="math inline">\(\boldsymbol{x}\in \mathcal{M}_n(\mathbb{R})\)</span> 은 <span class="math inline">\(\boldsymbol{A}\)</span> 의 고유벡터의 선형결합으로 표현 할 수 있다. 이제 positive definite 행렬에 대한 성질을 알아보자.</p>
<p><br></p>
<div id="prp-positive_definite_matrix_1" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3 </strong></span><span class="math inline">\(\boldsymbol{A}\in \mathcal{M}_{n \times n}(\mathbb{R})\)</span> 이 positive definite 일 경우 다음이 성립한다.</p>
<p>  (<span class="math inline">\(1\)</span>) <span class="math inline">\(\boldsymbol{A}\)</span> 의 모든 고유값은 양수이다.</p>
<p>  (<span class="math inline">\(2\)</span>) <span class="math inline">\(\det (\boldsymbol{A}) &gt;0\)</span> 이다.</p>
<p>  (<span class="math inline">\(3\)</span>) <span class="math inline">\(\boldsymbol{A}\)</span> 는 가역행렬이다.</p>
<p>  (<span class="math inline">\(4\)</span>) <span class="math inline">\(\boldsymbol{A}\)</span> 의 대각성분은 모두 양수이다.</p>
<p>  (<span class="math inline">\(5\)</span>) <span class="math inline">\(|A_{ij}| \le \max \{|A_{ii}| : i=1,\ldots,\,n\}\)</span>.</p>
<p>  (<span class="math inline">\(6\)</span>) 모든 <span class="math inline">\(i\ne j\)</span> 에 대해 <span class="math inline">\((A_{ij})^2 &lt; A_{ii} A_{jj}\)</span> 이다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>(<span class="math inline">\(1\)</span>) <span class="math inline">\(\lambda\)</span> 가 <span class="math inline">\(\boldsymbol{A}\)</span> 의 고유값이며 <span class="math inline">\(\boldsymbol{v}\)</span> 가 <span class="math inline">\(\lambda\)</span> 에 대한 고유벡터일 경우 <span class="math inline">\(\lambda = \langle \boldsymbol{Av}, \boldsymbol{v}\rangle &gt;0\)</span> 이어야 한다.</p>
<p>(<span class="math inline">\(2\)</span>) 대칭행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 의 행렬식은 모든 고유값의 곱이므로 양수이다.</p>
<p>(<span class="math inline">\(3\)</span>) <span class="math inline">\(\boldsymbol{x}\ne 0\)</span> 이며 <span class="math inline">\(\boldsymbol{Ax}=\boldsymbol{0}\)</span> 일 경우 <span class="math inline">\(\langle \boldsymbol{Ax}, \boldsymbol{x}\rangle = 0\)</span> 인데 이는 <span class="math inline">\(\boldsymbol{A}\)</span> 가 positive definite 가 아니라는 의미이다.</p>
<p>(<span class="math inline">\(4\)</span>) <span class="math inline">\(A_{ii} = \langle \boldsymbol{A}\hat{\boldsymbol{e}}_i,\, \hat{\boldsymbol{e}}_i\rangle &gt; 0\)</span></p>
<p>(<span class="math inline">\(5\)</span>) <span class="math inline">\(i\ne j\)</span> 에 대해</p>
<p><span class="math display">\[
\begin{aligned}
0&lt; \langle \boldsymbol{A}(\hat{\boldsymbol{e}}_i-\hat{\boldsymbol{e}}_j), (\hat{\boldsymbol{e}}_i-\hat{\boldsymbol{e}}_j)\rangle = A_{ii}+ A_{jj} - 2 A_{ij} \\
0&lt; \langle \boldsymbol{A}(\hat{\boldsymbol{e}}_i+\hat{\boldsymbol{e}}_j), (\hat{\boldsymbol{e}}_i+\hat{\boldsymbol{e}}_j)\rangle = A_{ii}+ A_{jj} + 2 A_{ij} \\
\end{aligned}
\]</span></p>
<p>이므로 <span class="math display">\[
|A_{ij}| &lt; \dfrac{A_{ii}+A_{jj}}{2} \le \max \{|A_{ii}| : i=1,\ldots,\,n\}
\]</span></p>
<p>이다.</p>
<p>(<span class="math inline">\(6\)</span>) 임의의 실수 <span class="math inline">\(t\)</span> 에 대해 <span class="math inline">\(\boldsymbol{x} = \hat{\boldsymbol{e}}_i + t \hat{\boldsymbol{e}}_j\)</span> 라고 하자. <span class="math inline">\(\langle \boldsymbol{Ax},\,\boldsymbol{x}\rangle = t^2A_{ii} + 2tA_{ij} + A_{jj} &gt; 0\)</span> 이므로 <span class="math inline">\((A_{ij})^2-A_{ii}A_{ij}&lt;0\)</span> 이어야 한다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-submatrix" class="theorem definition">
<p><span class="theorem-title"><strong>정의 3 (부분 행렬과 선행 주 부분 행렬) </strong></span>행렬 <span class="math inline">\(\boldsymbol{A}\in \mathcal{M}_{m\times n}(\mathbb{F})\)</span> 에 대해 임의의 중복되지 않은 행 <span class="math inline">\(I=\{i_1,\ldots,\,i_p: 1\le i_k\le m\}\)</span> 과 중복되지 않은 열 <span class="math inline">\(J=\{j_1,\ldots,\,j_q: 1 \le j_l \le n \}\)</span> 을 모아 만든 행렬을 <span class="math inline">\(\boldsymbol{A}\)</span> 의 <strong>부분 행렬 (submatrix)</strong>이라고 하고 <span class="math inline">\(\boldsymbol{A}[I, J]\)</span> 라고 쓴다. <span class="math inline">\(I=J=\{1,\,2,\ldots,\,k\}\)</span>일 때 <span class="math inline">\(\boldsymbol{A}[I, J]\)</span> 를 <strong>선행 주 부분 행렬 (leading principal submatrix)</strong> 이라고 한다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p>이제 정사각 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 가 positive definite 인 것과 <span class="math inline">\(\boldsymbol{A}\)</span> 의 모든 선행 주 부분행렬의 행렬식이 <span class="math inline">\(0\)</span> 보다 큰 것이 동치임을 보이고자 한다. 이를 위해 몇가지 미리 보여야 할 것이 있다.</p>
<div id="lem-positive_definite" class="theorem lemma">
<p><span class="theorem-title"><strong>보조정리 1 </strong></span><span class="math inline">\(\boldsymbol{A}\in \mathcal{M}_{n \times n}(\mathbb{F})\)</span> 이 에르미트행렬이고 <span class="math inline">\(\boldsymbol{Q} \in \mathcal{M}_{n \times n}(\mathbb{F})\)</span> 이 가역행렬 일 때 다음은 동치이다.</p>
<p>  (<span class="math inline">\(1\)</span>) <span class="math inline">\(\boldsymbol{A}\)</span> 가 positive definite 이고 <span class="math inline">\(\boldsymbol{Q}^\ast\boldsymbol{AQ}\)</span> 가 에르미트행렬이다.</p>
<p>  (<span class="math inline">\(2\)</span>) <span class="math inline">\(\boldsymbol{Q}^\ast \boldsymbol{AQ}\)</span> 가 positive definte 이다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>(<span class="math inline">\(1 \implies 2\)</span>) <span class="math inline">\(\boldsymbol{0}\)</span> 벡터가 아닌 <span class="math inline">\(\boldsymbol{v}\in \mathcal{M}_n(\mathbb{F})\)</span> 에 대해 <span class="math inline">\(\boldsymbol{Qv}\ne \boldsymbol{0}\)</span> 이다. <span class="math inline">\(\boldsymbol{A}\)</span> 가 positive definite 이므로,</p>
<p><span class="math display">\[
0 &lt; (\boldsymbol{Qv})^\ast \boldsymbol{A}(\boldsymbol{Qv}) = \boldsymbol{v}^\ast \left(\boldsymbol{Q}^\ast\boldsymbol{AQ}\right)\boldsymbol{v}
\]</span></p>
<p>이므로 <span class="math inline">\(\boldsymbol{Q}^\ast\boldsymbol{AQ}\)</span> 는 positive definite 이다.</p>
<p>(<span class="math inline">\(2 \implies 1\)</span>) <span class="math inline">\(\boldsymbol{A}\)</span> 가 에르미트행렬이므로 <span class="math inline">\((\boldsymbol{Q}^\ast\boldsymbol{AQ})^\ast = \boldsymbol{Q}^\ast \boldsymbol{A}^\ast\boldsymbol{Q} = \boldsymbol{Q}^\ast\boldsymbol{AQ}\)</span> 이다. 즉 <span class="math inline">\(\boldsymbol{Q}^\ast\boldsymbol{AQ}\)</span> 는 에르미트행렬이다. <span class="math inline">\(\boldsymbol{Q}\)</span> 가 가역이므로 임의의 <span class="math inline">\(\boldsymbol{x}\in \mathcal{M}_n(\mathbb{F})\)</span> 에 대해 <span class="math inline">\(\boldsymbol{x}=\boldsymbol{Qy}\)</span> 를 만족하는 <span class="math inline">\(\boldsymbol{y}\in \mathcal{M}_n(\mathbb{F})\)</span> 이 존재한다.</p>
<p><span class="math display">\[
\boldsymbol{x}^\ast\boldsymbol{Ax} =  (\boldsymbol{Qy})^\ast \boldsymbol{A}\boldsymbol{Qy} = \boldsymbol{y}^\ast\boldsymbol{Q}^\ast\boldsymbol{AQ}\boldsymbol{y} &gt; 0
\]</span></p>
<p>이므로 <span class="math inline">\(\boldsymbol{A}\)</span> 는 positive defnite 이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<div id="prp-leading_principal_submatrix" class="theorem proposition page-columns page-full">
<p><span class="theorem-title"><strong>명제 4 (실베스터 판정법 (Sylvester’s criterion)) </strong></span>에르미트 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 에 대해 다음은 동치이다.</p>
<p>  (<span class="math inline">\(1\)</span>) <span class="math inline">\(\boldsymbol{A}\)</span> 의 모든 선행 주 부분 행렬의 행렬식이 양수이다.</p>
<div class="page-columns page-full"><p>  (<span class="math inline">\(2\)</span>) <span class="math inline">\(\boldsymbol{A}\)</span> 는 positive definite 이다. </p><div class="no-row-height column-margin column-container"><span class=""><a href="#prp-leading_principal_submatrix">명제&nbsp;4</a> 가 실베스터 판정법이라고 불리우는 것은 임의의 에르미트 행렬이 positive definite 인지 아닌지를 확인하는 방법이기 때문이다.</span></div></div>
</div>
<div class="proof page-columns page-full">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(\boldsymbol{A}\)</span> 의 <span class="math inline">\(k\)</span> 행 <span class="math inline">\(k\)</span> 열 까지의 선 주 부분행렬을 <span class="math inline">\(\boldsymbol{A}_k\)</span> 라고 쓰자.</p>
<div class="page-columns page-full"><p>(<span class="math inline">\(1\implies 2\)</span>) Inductinon 을 통해 증명한다. <span class="math inline">\(1 \times 1\)</span> 행렬의 경우는 trivial 하다. 이제 <span class="math inline">\(n\times n\)</span> 행렬에 대해 성립한다고 가정한다. <span class="math inline">\(\boldsymbol{A}\)</span> 가 <span class="math inline">\((n+1)\times (n+1)\)</span> 행렬이라 하자.</p><div class="no-row-height column-margin column-container"><span class="">Carl P.Simon &amp; Lawrence E. Blume 의 <em>Mathematics for Economists</em> 에 나오는 증명이다.</span></div></div>
<p>우선 모든 <span class="math inline">\(\boldsymbol{A}_i\)</span>, <span class="math inline">\(i=1,\ldots,\,n\)</span> 의 행렬식이 양수이면 <span class="math inline">\(\boldsymbol{A}\)</span> 가 positive definite 임을 보이자. 우선 <span class="math inline">\(\boldsymbol{A}\)</span> 를 <span class="math inline">\(\boldsymbol{A}_n\)</span> 에 대하여 아래와 같이 분할하여 보자.</p>
<p><span class="math display">\[
\boldsymbol{A} = \left[\begin{array}{c|c} \boldsymbol{A}_n &amp; \boldsymbol{a} \\ \hline \boldsymbol{a}^\ast &amp; a\end{array}\right].
\]</span></p>
<p>여기서 <span class="math inline">\(\boldsymbol{a}=\begin{bmatrix} A_{1, n+1} &amp; \cdots &amp; A_{n, n+1}\end{bmatrix}^T\)</span> 이고 <span class="math inline">\(a=A_{n+1, n+1}\)</span> 이다. 또한 <span class="math inline">\(\boldsymbol{A}\)</span> 가 에르미트행렬이므로 <span class="math inline">\(\boldsymbol{A}_n\)</span> 도 에르미트행렬이며 따라서 <span class="math inline">\((\boldsymbol{A}^\ast)^{-1}=\boldsymbol{A}^{-1}\)</span> 이다. . 그렇다면,</p>
<p><span class="math display">\[
\boldsymbol{A} = \left[\begin{array}{c|c} \boldsymbol{I}_n &amp; \boldsymbol{0} \\ \hline (\boldsymbol{A}_n^{-1}\boldsymbol{a})^\ast &amp; 1\end{array}\right] \left[\begin{array}{c|c} \boldsymbol{A}_n &amp; \boldsymbol{0}_n \\ \hline (\boldsymbol{0}_n)^\ast &amp; d\end{array}\right] \left[\begin{array}{c|c} \boldsymbol{I}_n &amp; \boldsymbol{A}_n^{-1}\boldsymbol{a} \\ \hline (\boldsymbol{0}_n)^\ast &amp; 1\end{array}\right] = \boldsymbol{Q}^\ast\boldsymbol{BQ}
\]</span></p>
<p>이며 이 때 <span class="math inline">\(d=a-\boldsymbol{a}^\ast(\boldsymbol{A}_n)^{-1}\boldsymbol{a}\)</span> 이다. 우리는 <span class="math inline">\(\det (\boldsymbol{Q}^\ast) = \det (\boldsymbol{Q})=1\)</span> 이며 <span class="math inline">\(\det (\boldsymbol{B})=d \cdot \det (\boldsymbol{A}_n)\)</span> 임을 안다. 즉</p>
<p><span class="math display">\[
\det (\boldsymbol{A}) =  d \cdot \det (\boldsymbol{A}_n)
\]</span></p>
<p>이다. <span class="math inline">\(\boldsymbol{A}\)</span> 가 positive definite 이며 <span class="math inline">\(\det (\boldsymbol{A})&gt;0\)</span> 이므로 <span class="math inline">\(d&gt;0\)</span> 이다. 즉 모든 선행 주 부분행렬식이 양수이면 그 행렬은 positive definite 이다.</p>
<p>(<span class="math inline">\(2 \implies 1\)</span>) <span class="math inline">\(\boldsymbol{A}\)</span> 가 positive definite 임을 가정하자. 임의의 <span class="math inline">\(\boldsymbol{x}\in \mathcal{M}_{n+1}(\mathbb{R})\)</span> 에 대해 <span class="math inline">\(\boldsymbol{x} = \begin{bmatrix} \boldsymbol{x}_0 &amp; x \end{bmatrix}^T\)</span>, <span class="math inline">\(\boldsymbol{x}_0 \in \mathcal{M}_{n}(\mathbb{R})\)</span> 이라 하면,</p>
<p><span class="math display">\[
\boldsymbol{x}^\ast \boldsymbol{Bx} = \boldsymbol{x}^\ast \boldsymbol{A}_n \boldsymbol{x} + d\cdot x^2
\]</span></p>
<p>이다. <span class="math inline">\(\boldsymbol{A}_n\)</span> 이 가정에 의해 positive definite 이며, <span class="math inline">\(d&gt;0\)</span> 이므로 <span class="math inline">\(\boldsymbol{x}^\ast\boldsymbol{Bx}&gt;0\)</span> 이다. 따라서 <a href="#lem-positive_definite">보조정리&nbsp;1</a> 에 의해 <span class="math inline">\(\boldsymbol{B}=\boldsymbol{Q}^\ast\boldsymbol{AQ}\)</span> 일 때 <span class="math inline">\(\boldsymbol{A}\)</span> 는 positive definite 이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<p><br></p>
</section>
</section>
<section id="숄레스키-분해" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="숄레스키-분해"><span class="header-section-number">2</span> 숄레스키 분해</h2>
<section id="boldsymbolllast-분해" class="level3">
<h3 class="anchored" data-anchor-id="boldsymbolllast-분해"><span class="math inline">\(\boldsymbol{LL}^\ast\)</span> 분해</h3>
<div id="thm-cholesky_decomposition" class="theorem">
<p><span class="theorem-title"><strong>정리 1 </strong></span>Positive definite 행렬 <span class="math inline">\(\boldsymbol{A}\in \mathcal{M}_{n \times n}(\mathbb{F})\)</span>은 어떤 모든 대각성분이 양수인 하삼각행렬 <span class="math inline">\(\boldsymbol{L} \in \mathcal{M}_{n \times n}(\mathbb{F})\)</span> 에 대해 <span class="math inline">\(\boldsymbol{A}= \boldsymbol{LL}^\ast\)</span> 이다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>수학적 귀납법으로 증명한다. <span class="math inline">\(n=1\)</span> 일 때 경우 <span class="math inline">\(\boldsymbol{A}=\begin{bmatrix}a \end{bmatrix}\)</span> 라면 <a href="#prp-positive_definite_matrix_1">명제&nbsp;3</a> 의 (<span class="math inline">\(4\)</span>) 에 의해 <span class="math inline">\(a&gt;0\)</span> 이므로 <span class="math inline">\(\boldsymbol{L}=\begin{bmatrix} \sqrt{a}\end{bmatrix}\)</span> 이다. <span class="math inline">\(n\)</span> 일때 성립함을 가정하자. <span class="math inline">\(\boldsymbol{A}\in \mathcal{M}_{(n+1)\times (n+1)}(\mathbb{F})\)</span> 에 대해</p>
<p><span class="math display">\[
\boldsymbol{A} = \left[\begin{array}{c|c} \boldsymbol{A}_n &amp; \boldsymbol{b} \\ \hline \boldsymbol{b}^\ast &amp; a\end{array}\right].
\]</span></p>
<p>로 표현 할 수 있다. <span class="math inline">\(\boldsymbol{A}_n = \boldsymbol{L}_n \boldsymbol{L}_n^\ast\)</span> 라면 일 때</p>
<p><span class="math display">\[
\boldsymbol{L} = \left[\begin{array}{c|c} \boldsymbol{L}_n &amp; \boldsymbol{0} \\ \hline \boldsymbol{c}^\ast &amp; d\end{array}\right].
\]</span></p>
<p>라 하자.</p>
<p><span class="math display">\[
\boldsymbol{LL}^\ast = \left[\begin{array}{c|c} \boldsymbol{L}_n\boldsymbol{L}_n^\ast &amp; \boldsymbol{L}_n \boldsymbol{c} \\ \hline (\boldsymbol{L}_n \boldsymbol{c})^\ast &amp; |d|^2\end{array}\right].
\]</span></p>
<p>이므로 <span class="math inline">\(\boldsymbol{b}=\boldsymbol{L}_n \boldsymbol{c}\)</span>, <span class="math inline">\(d+ \boldsymbol{c}^\ast\boldsymbol{c}=|a|^2\)</span> 을 만족하는 <span class="math inline">\(\boldsymbol{c}\)</span> 와 양수 <span class="math inline">\(d\)</span> 가 존재한다면 <span class="math inline">\(\boldsymbol{A} = \boldsymbol{LL}^\ast\)</span> 이다.</p>
<p><span class="math inline">\(\boldsymbol{L}_n\)</span> 이 대각성분이 양수인 하삼각행렬이므로 가역행렬이다. 따라서 <span class="math inline">\(\boldsymbol{c}=(\boldsymbol{L}_n)^{-1} \boldsymbol{b}\)</span> 이다. 따라서 어쨋든 (그것이 양수가 아니고 복소수라고 하더라도) <span class="math inline">\(d=\sqrt{|a|^2-\boldsymbol{c}^\ast \boldsymbol{c}}\)</span> 가 존재하며, <span class="math inline">\(\det(\boldsymbol{A})=|\det(\boldsymbol{L}_n)|^2 d^2 &gt;0\)</span> 로부터 <span class="math inline">\(d^2&gt;0\)</span> 임을 안다. 따라서 <span class="math inline">\(d&gt;0\)</span> 를 얻는다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-Cholesky_decomposition" class="theorem definition">
<p><span class="theorem-title"><strong>정의 4 (숄레스키 분해) </strong></span><a href="#thm-cholesky_decomposition">정리&nbsp;1</a> 에 따라 Positive definite 행렬 <span class="math inline">\(\boldsymbol{A}\in \mathcal{M}_{n \times n}(\mathbb{F})\)</span> 를 모든 대각성분이 양수인 하삼각 행렬 <span class="math inline">\(\boldsymbol{L}\in \mathcal{M}_{n \times n}(\mathbb{F})\)</span> 에 대해 <span class="math inline">\(\boldsymbol{A}=\boldsymbol{LL}^\ast\)</span> 로 분해하는 것을 <strong>숄레스키 분해 (Cholesky decomposition)</strong> 라고 한다. <span class="math inline">\(\mathbb{F} =\mathbb{R}\)</span> 인 경우 <span class="math inline">\(\boldsymbol{A}=\boldsymbol{LL}^T\)</span> 이므로 <span class="math inline">\(\boldsymbol{LL}^T\)</span> 분해라고도 한다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
</section>
<section id="구현" class="level3">
<h3 class="anchored" data-anchor-id="구현">구현</h3>
<p><span class="math inline">\(\boldsymbol{A},\,\boldsymbol{L}\in \mathcal{M}_{n \times n}(\mathbb{F})\)</span> 을 생각하자. <span class="math inline">\(\boldsymbol{A} = \boldsymbol{LL}^\ast\)</span> 이므로,</p>
<p><span class="math display">\[
\begin{bmatrix} A_{11} &amp; A_{12} &amp; A_{13} &amp; \cdots &amp; A_{1n} \\
A_{21} &amp; A_{22} &amp; A_{23} &amp; \cdots &amp; A_{2n}\\
\vdots &amp; &amp; &amp; &amp; \vdots \\
A_{n1} &amp; A_{n2} &amp; A_{n3} &amp; \cdots &amp; A_{nn}\end{bmatrix}
= \begin{bmatrix} L_{11} &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\
L_{21}&amp; L_{22} &amp; 0 &amp; \cdots &amp; 0 \\
\vdots &amp; &amp; &amp; &amp; \vdots \\
L_{n1} &amp; L_{n2} &amp; L_{n3} &amp; \cdots &amp; L_{nn} \end{bmatrix}
\begin{bmatrix} L_{11} &amp; \overline{L_{21}} &amp; \overline{L_{31}} &amp; \cdots &amp; \overline{L_{n1}} \\
0 &amp; L_{22} &amp; \overline{L_{32}} &amp; \cdots &amp; \overline{L_{n2}}\\
\vdots &amp; &amp; &amp; &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; \cdots &amp; \overline{L_{nn}}\end{bmatrix}
\]</span></p>
<p>이다. 또한 <span class="math inline">\(\boldsymbol{L}\)</span> 이 하삼각행렬이므로 다음이 성립한다. <span class="math display">\[
A_{ij} = \boldsymbol{L}_{i:} (\boldsymbol{L}^\ast)_{:j} = \sum_{k=1}^n L_{ik} \overline{L_{jk}} = \sum_{k=1}^{\min (i, j)} L_{ik} \overline{L_{jk}}
\]</span></p>
<p><span class="math inline">\(A_{11}=|L_{11}|^2\)</span>, <span class="math inline">\(A_{i1} = L_{i1}\overline{L_{11}}=L_{i1}L_{11}\)</span> 이므로 <span class="math inline">\(L_{11}= \sqrt{A_{11}},\, L_{i1} = A_{i1}/L_{11}\)</span> 으로 부터 <span class="math inline">\(\boldsymbol{L}\)</span> 의 1열을 얻을 수 있다. 이제 <span class="math inline">\(\boldsymbol{L}\)</span> 의 <span class="math inline">\(j-1\)</span> 열까지 얻었다고 가정하자.</p>
<p><span class="math display">\[
\begin{aligned}
A_{1, j} &amp; = L_{11}\overline{L_{j1}},\\
A_{i, j} &amp; = \sum_{k=1}^{\min (i, j)} L_{ik}\overline{L_{jk}},
\end{aligned}
\]</span></p>
<p>이다. <span class="math inline">\(i\le j\)</span> 인 경우,</p>
<p><span class="math display">\[
A_{i, j} = L_{i1}\overline{L_{j1}} + \cdots + L_{ii}\overline{L_{ji}}
\]</span></p>
<p>이므로 다음을 얻는다.</p>
<p><span class="math display">\[
\begin{aligned}
\text{if }j \ne i &amp; &amp;L_{ji} &amp;= \dfrac{1}{(\overline{L_{ii}})}\overline{A_{ij} - \sum_{k=1}^{i-1} L_{ik}\overline{L_{jk}}}, \\
&amp; &amp;L_{jj} &amp;= \sqrt{A_{ij}- \sum_{k=1}^{j-1} L_{jk}\overline{L_{jk}}}
\end{aligned}
\]</span></p>
<p>즉 <span class="math inline">\(i\le j\)</span> 일 경우 <span class="math inline">\(L_{ji}\)</span> 는 <span class="math inline">\(\boldsymbol{L}\)</span> 의 <span class="math inline">\(1\)</span> 열부터 <span class="math inline">\(j-1\)</span> 열까지와 <span class="math inline">\(j\)</span> 열의 <span class="math inline">\(1\)</span> 행부터, <span class="math inline">\(j-1\)</span> 행까지의 값을 이용하여 얻을 수 있다. Julia 로 구현한 것은 아래와 같다. 하지만 <code>LinearAlgebra</code> 모듈에 <code>cholesky</code> 함수로 존재하며(그래서 함수 이름을 굳이 <code>mcholesky</code> 로 붙였다), 앞으로 필요하다면 그것을 쓸 것이다.</p>
<p><br></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">mcholesky</span>(A<span class="op">::</span><span class="dt">Matrix{T}</span>) <span class="kw">where</span> T<span class="op">&lt;:</span><span class="dt">Number</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    M <span class="op">=</span> <span class="fu">size</span>(A)[<span class="fl">1</span>]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    L <span class="op">=</span> <span class="fu">zero</span>(A)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    L[<span class="fl">1</span>, <span class="fl">1</span>] <span class="op">=</span> <span class="fu">sqrt</span>(A[<span class="fl">1</span>, <span class="fl">1</span>])</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span>M</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        L[i, <span class="fl">1</span>] <span class="op">=</span> A[i, <span class="fl">1</span>]<span class="op">/</span>L[<span class="fl">1</span>, <span class="fl">1</span>]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span>M, i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>j</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> j <span class="op">==</span> i </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            L[i, i] <span class="op">=</span> <span class="fu">sqrt</span>(A[i, i] <span class="op">-</span> <span class="fu">dot</span>(L[i, <span class="fl">1</span><span class="op">:</span>i<span class="op">-</span><span class="fl">1</span>], L[i, <span class="fl">1</span><span class="op">:</span>i<span class="op">-</span><span class="fl">1</span>]) )</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            L[j, i] <span class="op">=</span> (A[i, j] <span class="op">-</span> <span class="fu">dot</span>(L[j, <span class="fl">1</span><span class="op">:</span>i<span class="op">-</span><span class="fl">1</span>], L[i, <span class="fl">1</span><span class="op">:</span>i<span class="op">-</span><span class="fl">1</span>]))<span class="op">/</span>L[i, i]</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> L</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
</section>
<section id="boldsymbolldlast-분해" class="level3">
<h3 class="anchored" data-anchor-id="boldsymbolldlast-분해"><span class="math inline">\(\boldsymbol{LDL}^\ast\)</span> 분해</h3>
<div id="prp-decomposition_of_lower_triangular_matrix" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 5 </strong></span>대각성분이 모두 <span class="math inline">\(0\)</span> 이 아닌 하삼각 행렬 <span class="math inline">\(\boldsymbol{L}\)</span> 은 어떤 대각행렬 <span class="math inline">\(\boldsymbol{\Delta}\)</span> 와 대각성분이 <span class="math inline">\(1\)</span> 인 하삼각 행렬 <span class="math inline">\(\boldsymbol{\Lambda}\)</span> 에 대해 <span class="math inline">\(\boldsymbol{L}=\boldsymbol{\Lambda}\boldsymbol{\Delta}\)</span> 로 분해된다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(\boldsymbol{\Delta}\)</span> 를 <span class="math inline">\(\boldsymbol{L}\)</span> 의 대각성분만으로 이루어진 대각행렬이라고 하고 <span class="math inline">\(\boldsymbol{\Lambda}\)</span> 를 <span class="math inline">\(\Lambda_{ij} = L_{ij}/\Delta_{ii}\)</span> 라고 하면,</p>
<p><span class="math display">\[
(\boldsymbol{\Lambda \Delta})_{ij} = \sum_{k=1}^i \Lambda_{ik}\Delta_{kj} = L_{ij}
\]</span></p>
<p>이므로 <span class="math inline">\(\boldsymbol{L}=\boldsymbol{\Lambda \Delta}\)</span> 이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<p>우리는 positive definite 행렬이 하삼각 행렬과 그 하삼각행렬의 에르미트 conjugarte 의 곱으로 표현된다는 것을 안다(<a href="#thm-cholesky_decomposition">정리&nbsp;1</a>). 여기에 <a href="#prp-decomposition_of_lower_triangular_matrix">명제&nbsp;5</a> 를 같이 생각하면 positive definite 행렬은 어떤 대각행렬이 <span class="math inline">\(1\)</span> 인 하삼각행렬 <span class="math inline">\(\boldsymbol{L}\)</span> 과 대각 행렬 <span class="math inline">\(\boldsymbol{D}_0\)</span> 에 대해</p>
<p><span class="math display">\[
\boldsymbol{A} = (\boldsymbol{LD}_0) (\boldsymbol{LD}_0)^\ast = \boldsymbol{L}(\boldsymbol{D}_0\boldsymbol{D}_0^\ast) \boldsymbol{L}^\ast
\]</span></p>
<p>이다. <span class="math inline">\(\boldsymbol{D}_0\)</span> 는 모든 성분이 양수인 대각행렬이므로 <span class="math inline">\(\boldsymbol{D}=(\boldsymbol{D}_0\boldsymbol{D}_0^\ast)\)</span> 도 그러하다. 따라서 우리는 다음의 결론을 얻을 수 있다.</p>
<div id="prp-LDLt_dcomposition" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 6 </strong></span>positive definite 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 는 어떤 대각성분이 모두 <span class="math inline">\(1\)</span> 인 하삼각 행렬 <span class="math inline">\(\boldsymbol{L}\)</span> 과 대각성분이 모두 양수인 대각행렬 <span class="math inline">\(\boldsymbol{D}\)</span> 에 대해 <span class="math inline">\(\boldsymbol{A} = \boldsymbol{LDL}^\ast\)</span> 로 분해된다.</p>
</div>
<p><br></p>
</section>
<section id="sec-crout_decompositioni" class="level3">
<h3 class="anchored" data-anchor-id="sec-crout_decompositioni">크라우트 분해</h3>
<p>숄레스키 분해와는 유사한 분해로 크라우트 분해가 있다. <a href="../../src/numerical_analysis_using_julia/04_matrix_algebra.html#sec-pseudodiagonal_matrix">삼중대각행렬</a> 을 하쌍대각행렬 <span class="math inline">\(\boldsymbol{L}\)</span> 과 대각성분이 모두 <span class="math inline">\(1\)</span> 인 상쌍대각행렬 <span class="math inline">\(\boldsymbol{U}\)</span> 의 곱으로 분해하는 것을 <strong>크라우트 분해 (Crount decomposition)</strong> 라고 한다.</p>
<p><br></p>
</section>
</section>
<section id="qr-분해" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="qr-분해"><span class="header-section-number">3</span> QR 분해</h2>
<section id="하우스홀더-행렬" class="level3">
<h3 class="anchored" data-anchor-id="하우스홀더-행렬">하우스홀더 행렬</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-householder_matrix" class="theorem definition">
<p><span class="theorem-title"><strong>정의 5 (하우스홀더 행렬과 하우스홀더 변환) </strong></span>벡터공간 <span class="math inline">\(\mathcal{M}_n(\mathbb{C})\)</span> 에서의 벡터 <span class="math inline">\(\boldsymbol{v}\)</span> 에 대해 다음과 같이 정의된 <span class="math inline">\(\boldsymbol{H}_v\)</span> 를 <strong>하우스홀더 행렬 (Householder matrix)</strong> 이라 한다.</p>
<p><span id="eq-householder_transformation_1"><span class="math display">\[
\begin{aligned}
\boldsymbol{H}_{\boldsymbol{v}} := I_n- \dfrac{2\boldsymbol{v}\boldsymbol{v}^{\ast}}{\|\boldsymbol{v}\|^2}, \qquad \text{i. e. }\quad
(\boldsymbol{H}_{\boldsymbol{v}})_{ij} := \delta_{ij} - \dfrac{2 v_i \overline{v_j}}{\|\boldsymbol{v}\|^2}.
\end{aligned}
\tag{1}\]</span></span> 여기서 <span class="math inline">\(\boldsymbol{v}\boldsymbol{v}^{\ast}\)</span> 는 벡터의 내적이 아니라 <span class="math inline">\(n\times 1\)</span> 행렬 <span class="math inline">\(\boldsymbol{v}\)</span> 와 <span class="math inline">\(1 \times n\)</span> 행렬 <span class="math inline">\(\boldsymbol{v}^{\ast}\)</span> 가 곱해진 <span class="math inline">\(n \times n\)</span> 행렬을 의미한다. 벡터 <span class="math inline">\(\boldsymbol{x}\in \mathbb{C}^n\)</span> 에 대해 <span class="math inline">\(\boldsymbol{H}_{\boldsymbol{v}} \boldsymbol{x}\in \mathbb{C}^n\)</span> 을 <strong>하우스홀더 변환</strong> 이라 한다. <span class="math inline">\(\boldsymbol{v}\)</span> 가 단위벡터일 경우, 즉 <span class="math inline">\(\|\boldsymbol{v}\|=1\)</span> 라면 좀 더 간단하게 쓸 수 있다.</p>
<p><span id="eq-householder_transformation_2"><span class="math display">\[
\boldsymbol{H}_{\boldsymbol{v}} = I_n- 2\boldsymbol{v}\boldsymbol{v}^{\ast},\qquad \text{where } \|\boldsymbol{v}\|=1.
\tag{2}\]</span></span></p>
</div>
</div>
</div>
</div>
<p><br></p>
<div id="prp-perperties_of_householder_matrix" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 7 </strong></span>하우스홀더 행렬 <span class="math inline">\(\boldsymbol{H}_{\boldsymbol{v}} \in \mathcal{M}_{n \times n}(\mathbb{C})\)</span> 은 다음의 특징을 가진다.</p>
<p>  (<span class="math inline">\(1\)</span>) 에르미트 행렬이다. 즉 <span class="math inline">\(\boldsymbol{H}_{\boldsymbol{v}}= \boldsymbol{H}_{\boldsymbol{v}}^\ast\)</span>.</p>
<p>  (<span class="math inline">\(2\)</span>) 유니타리 행렬이다. 즉 <span class="math inline">\(\boldsymbol{H}_{\boldsymbol{v}} (\boldsymbol{H}_{\boldsymbol{v}})^\ast = I\)</span>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>(<span class="math inline">\(1\)</span>) <span class="math inline">\(\boldsymbol{v}\)</span> 가 단위벡터일 경우에만 보여도 된다. <span class="math inline">\(\boldsymbol{H} = \boldsymbol{H}_{\boldsymbol{v}}\)</span> 라 하면,</p>
<p><span class="math display">\[
(\boldsymbol{H}^\ast)_{ij} = \overline{H_{ji}}= \delta_{ij}-2 \overline{v_j \overline{v_i}} = \delta_{ij}-2 v_i \overline{v_j} = (\boldsymbol{H})_{ij}
\]</span></p>
<p>이므로 <span class="math inline">\(\boldsymbol{H}_{\boldsymbol{v}}\)</span> 는 에르미트 행렬이다.</p>
<p>(<span class="math inline">\(2\)</span>) 또한,</p>
<p><span class="math display">\[
\begin{aligned}
\left(\boldsymbol{H} (\boldsymbol{H}^\ast)\right)_{ij} &amp;= \left((\boldsymbol{H})^2\right)_{ij} = \sum_{k}(\delta_{ik}-2 v_i \overline{v_k})(\delta_{kj} -2 v_k \overline{v_j}) \\
&amp;= \sum_k \delta_{ik}\delta_{kj} - 2\sum_k \delta_{ik}v_k \overline{v_j} - 2 \sum_k \delta_{kj} v_i \overline{v_k} + 4 \sum_{k} v_i \overline{v_j} v_k \overline{v_k} \\
&amp;= \delta_{ij} - 2 v_i \overline{v_{j}} - 2 v_i \overline{v_j} + 4 v_i \overline{v_j} = \delta_{ij}
\end{aligned}
\]</span></p>
<p>이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<div id="cor-perperties_of_householder_matrix" class="theorem corollary">
<p><span class="theorem-title"><strong>따름정리 1 </strong></span>실수성분의 하우스홀더 행렬 <span class="math inline">\(\boldsymbol{H}_{\boldsymbol{v}} \in \mathcal{M}_{n \times n}(\mathbb{R})\)</span> 은 대칭행렬이며 직교행렬이다.</p>
</div>
<p><br></p>
</section>
<section id="하우스홀더-변환과-하우스홀더-반사" class="level3">
<h3 class="anchored" data-anchor-id="하우스홀더-변환과-하우스홀더-반사">하우스홀더 변환과 하우스홀더 반사</h3>
<p>하우스 홀더 변환이 리플렉션(reflection, 반사) 라고 불린다. 수학적으로 <span class="math inline">\(\mathbb{R}^n\)</span> 공간에서 벡터 <span class="math inline">\(\boldsymbol{v}\)</span> 만으로 <span class="math inline">\(\boldsymbol{v}\)</span> 와 수직이며 원점을 지나는 평면이 유일하게 정의될 수 있다. 임의의 벡터 <span class="math inline">\(\boldsymbol{x} \in \mathbb{F}^n\)</span> 에 대해,</p>
<p><span class="math display">\[
\begin{aligned}
(\boldsymbol{H}_{\boldsymbol{v}}\boldsymbol{x})_k &amp;=  x_k - \dfrac{2}{\|\boldsymbol{v}\|^2}  \sum_{j=1}^n v_k \overline{v_j} x_j\\
\boldsymbol{H}_{\boldsymbol{v}}\boldsymbol{x} &amp;= \boldsymbol{x} - 2 \dfrac{\langle \boldsymbol{x},\,  \boldsymbol{v} \rangle \boldsymbol{v}}{\|\boldsymbol{v}\|^2}
\end{aligned}
\]</span></p>
<p>이며, <span class="math inline">\(\boldsymbol{x}\)</span> 의 <span class="math inline">\(\boldsymbol{v}\)</span> 벡터에 대한 projection <span class="math inline">\(\text{Proj}_\boldsymbol{v}\boldsymbol{x}= \langle \boldsymbol{v},\, \boldsymbol{x}\rangle \boldsymbol{v}\)</span> 이므로,</p>
<p><span class="math display">\[
\begin{aligned}
\dfrac{1}{2 }(\boldsymbol{x}+\boldsymbol{Hx}) &amp;= \boldsymbol{x} - \langle \boldsymbol{v,\,  x}\rangle \boldsymbol{v} = \boldsymbol{x} - \text{Proj}_{\boldsymbol{v}} \boldsymbol{x} \\
\boldsymbol{x}-\boldsymbol{Hx} &amp;= 2\langle \boldsymbol{v ,\, x} \rangle  \boldsymbol{v} = 2\, \text{Proj}_{\boldsymbol{v}}\boldsymbol{x}
\end{aligned}
\]</span></p>
<p>이다. 즉 <span class="math inline">\(\boldsymbol{x}\)</span> 와 <span class="math inline">\(\boldsymbol{Hx}\)</span> 는 <span class="math inline">\(\boldsymbol{v}\)</span> 에 의해 정의되는 평면에 대해 대칭이다.</p>
<div class="cell" data-layout-align="center">
<details>
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode tikz code-with-copy"><code class="sourceCode latex"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">\begin</span>{<span class="ex">tikzpicture</span>}</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">\draw</span> [black, very thick, -&gt;](0, 0) -- (2, 2)  node[right] {<span class="ss">$</span><span class="sc">\boldsymbol</span><span class="ss">{v}$</span>};</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">\draw</span> [red, very thick, -&gt;] (0, 0) -- (-2.646, 1 ) node[left] {<span class="ss">$</span><span class="sc">\boldsymbol</span><span class="ss">{H_v x}$</span>};</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">\draw</span> [blue, very thick, -&gt;] (0, 0) -- (-0.646, 3 ) node[left] {<span class="ss">$</span><span class="sc">\boldsymbol</span><span class="ss">{x}$</span>};</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">\draw</span> [green, dashed, thick] (1, -1) -- (-2, 2 ) node[left, black] {Plane normal to <span class="ss">$</span><span class="sc">\boldsymbol</span><span class="ss">{v}$</span>};</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">\end</span>{<span class="ex">tikzpicture</span>}</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div id="fig-householder_1" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="08_matrix_decomposition_files/figure-html/fig-householder_1-1.png" class="img-fluid figure-img" width="384"></p>
<p></p><figcaption class="figure-caption">그림&nbsp;1: Householder 반사</figcaption><p></p>
</figure>
</div>
</div>
<p><span class="math inline">\(\boldsymbol{x}\)</span> 를 <span class="math inline">\(\boldsymbol{v}\)</span> 와 평행한 부분과 수직한 부분으로 분리하자. 즉 <span class="math inline">\(\boldsymbol{x}_{\|} = \text{Proj}_{\boldsymbol{v}}\boldsymbol{x}\)</span>, <span class="math inline">\(\boldsymbol{x}_{\perp} = \boldsymbol{x}-\text{Proj}_{\boldsymbol{v}}\boldsymbol{x}\)</span> 라 하면, <span class="math inline">\(\boldsymbol{x} = \boldsymbol{x}_{\|} + \boldsymbol{x}_{\perp}\)</span> 이며 <span class="math inline">\(\boldsymbol{x}\cdot \boldsymbol{v} = \boldsymbol{x}_{\|}\cdot \boldsymbol{v}\)</span> 이다.</p>
<p><span class="math display">\[
\boldsymbol{H}_{\boldsymbol{v}}\boldsymbol{x} = \boldsymbol{x} - 2 \boldsymbol{x}_{\|} = \boldsymbol{x}_{\perp} - \boldsymbol{x}_{\|}
\]</span></p>
<p>이다.</p>
<p><br></p>
</section>
<section id="하우스홀더-변환과-qr-분해" class="level3">
<h3 class="anchored" data-anchor-id="하우스홀더-변환과-qr-분해">하우스홀더 변환과 QR 분해</h3>
<p><span class="math inline">\(\mathcal{M}_n (\mathbb{F})\)</span> 에서의 벡터 <span class="math inline">\(\boldsymbol{x}\)</span> 과 표준 기저 <span class="math inline">\(\{\hat{\boldsymbol{e}}_1,\ldots,\,\hat{\boldsymbol{e}}_n\}\)</span> 를 생각하자. <span class="math inline">\(\alpha\)</span> 를 <span class="math inline">\(\boldsymbol{x}\)</span> 의 첫번째 성분 <span class="math inline">\(x_1 = re^{i\theta}\)</span> 에 대해 다음과 같이 정의한다.</p>
<p><span class="math display">\[
\alpha = \left\{ \begin{array}{ll} \|\boldsymbol{x}\|_2  &amp; \text{where } \mathbb{F}=\mathbb{R}, \\ e^{i\theta}\|\boldsymbol{x}\|_2 \qquad &amp; \text{where } \mathbb{F} =\mathbb{C}. \end{array} \right.
\]</span></p>
<p><span class="math inline">\(\boldsymbol{x}\)</span> 에 대해 <span class="math inline">\(\boldsymbol{v}\)</span> 를 다음과 같이 정하자.</p>
<p><span class="math display">\[
\boldsymbol{v} = \boldsymbol{x} - \alpha \hat{\boldsymbol{e}}_1, \\
\]</span></p>
<p>이렇게 정해진 <span class="math inline">\(\boldsymbol{v}\)</span> 를 <strong>하우스홀더 벡터(householder vector)</strong> 라고 한다. 이 때 <span class="math inline">\(\boldsymbol{x}\)</span> 의 <span class="math inline">\(\boldsymbol{v}\)</span> 에 대한 하우스홀더 변환 <span class="math inline">\(\boldsymbol{H}_{\boldsymbol{v}}\boldsymbol{x}\)</span> 는 다음과 같다. (증명은 연습문제에)</p>
<p><span id="eq-householder_vector"><span class="math display">\[
\boldsymbol{H}_{\boldsymbol{v}}\boldsymbol{x} = \boldsymbol{x}-\boldsymbol{v} = \alpha \hat{\boldsymbol{e}}_1.
\tag{3}\]</span></span></p>
<p><br></p>
<p><a href="#eq-householder_transformation_1">식&nbsp;1</a> 에서 보듯이 <span class="math inline">\(\boldsymbol{v}\)</span> 에 스칼라곱을 해도 하우스홀더 변환은 변하지 않는다. 실제로 계산을 위해서는 주어진 <span class="math inline">\(\boldsymbol{v}\)</span> 에 대해 <span class="math inline">\(\overline{\boldsymbol{v}}=\dfrac{1}{v_1}\boldsymbol{v}\)</span> 를 사용하여 변환을 하게되며 <span class="math inline">\(\overline{v}_1=1\)</span> 이 된다.</p>
<p><br></p>
<div id="thm-qr_decomposition_1" class="theorem">
<p><span class="theorem-title"><strong>정리 2 </strong></span><span class="math inline">\(\boldsymbol{A}\in \mathcal{M}_{m \times n}(\mathbb{F})\)</span> 일 때 어떤 isometry <span class="math inline">\(\boldsymbol{Q}\in \mathcal{M}_{m \times m}(\mathbb{F})\)</span> 와 상삼각 행렬 <span class="math inline">\(\boldsymbol{R}\in \mathcal{M}_{m \times n}(\mathbb{F})\)</span> 에 대해 <span class="math inline">\(\boldsymbol{A}=\boldsymbol{QR}\)</span> 이다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>하우스홀더 행렬은 isometry 이며 에르미트 행렬임을 생각하자. <span class="math inline">\(n\)</span> 에 대한 induction 으로 증명한다.</p>
<p><span class="math inline">\(n=1\)</span> 일 경우 <span class="math inline">\(\boldsymbol{x}=\boldsymbol{A}\)</span> 라고 하면 <span class="math inline">\(\boldsymbol{Q} = \boldsymbol{H}[\boldsymbol{x}]\)</span> 에 대해 <span class="math inline">\(\boldsymbol{QA}=\boldsymbol{R}\)</span> 은 2 행부터의 값이 <span class="math inline">\(0\)</span> 인 <span class="math inline">\(m \times 1\)</span> 행렬이다. <span class="math inline">\(\boldsymbol{A}=\boldsymbol{Q}^\ast \boldsymbol{R} = \boldsymbol{QR}\)</span> 이므로 <span class="math inline">\(n=1\)</span> 일 때 성립한다.</p>
<p>이제 <span class="math inline">\(n\)</span> 보다 작거나 같은 자연수에 대해 성립함을 가정하자. <span class="math inline">\(\boldsymbol{A}_1\in \mathcal{M}_{m\times n}(\mathbb{F})\)</span> 와 <span class="math inline">\(\boldsymbol{a}\in \mathcal{M}_{m\times 1}(\mathbb{F})\)</span> 에 대해 <span class="math inline">\(\boldsymbol{A}= \begin{bmatrix} \boldsymbol{A}_1 &amp; \boldsymbol{a} \end{bmatrix}\in \mathcal{M}_{m \times (n+1)}(\mathbb{F})\)</span> 이다. Induction 의 가정에 의해 <span class="math inline">\(\boldsymbol{A}_1 = \boldsymbol{Q}_1\boldsymbol{R}_1\)</span> 을 만족하는 isometry <span class="math inline">\(\boldsymbol{Q}_1\in \mathcal{M}_{m \times m}(\mathbb{F})\)</span> 와 상삼각 행렬 <span class="math inline">\(\boldsymbol{R}_1 \in \mathcal{M}_{m \times n}(\mathbb{F})\)</span> 이 존재한다. <span class="math inline">\(m &gt; n\)</span> 일 경우 <span class="math inline">\(n\)</span> 보다 큰 <span class="math inline">\(\boldsymbol{R}_1\)</span> 의 행벡터는 모두 영벡터이다.</p>
<p><span class="math inline">\(\boldsymbol{a}\)</span> 에 대해 <span class="math inline">\(\boldsymbol{w} = \boldsymbol{Q}_1^\ast\boldsymbol{a}\)</span> 라고 하자. <span class="math inline">\(\boldsymbol{Q}_1\in \mathcal{M}_{m \times m}(\mathbb{F})\)</span> 이다. <span class="math inline">\(\boldsymbol{w}\)</span> 는 첫행을 제외한 나머지 행이 <span class="math inline">\(0\)</span> 인 열벡터이다. 이제 <span class="math inline">\(\boldsymbol{w}\)</span> 의 <span class="math inline">\(1\)</span> 행부터 <span class="math inline">\(n\)</span> 행까지를 <span class="math inline">\(\boldsymbol{w}_1\)</span>, <span class="math inline">\(n+1\)</span> 행부터 <span class="math inline">\(m\)</span> 행 까지를 <span class="math inline">\(\boldsymbol{w}_2\)</span> 라고 하자. <span class="math inline">\(\boldsymbol{w}_2\)</span> 에 대해 <span class="math inline">\(\boldsymbol{w}_2 = \boldsymbol{Q}_2 \boldsymbol{r}_2\)</span> 를 만족하는 <span class="math inline">\(\boldsymbol{Q}_2 \in \mathcal{M}_{(m - n)\times (m - n)}(\mathbb{F})\)</span>, <span class="math inline">\(\boldsymbol{r}_2\in \mathcal{M}_{(m-n)}(\mathbb{F})\)</span> 가 존재한다.</p>
<p>이제 <span class="math inline">\(\boldsymbol{A}_1=\boldsymbol{Q}_1\boldsymbol{R}_1\)</span> 이며 <span class="math inline">\(\boldsymbol{Q}_1\)</span> 은 <span class="math inline">\(n \times n\)</span> isomegtry 이고 <span class="math inline">\(\boldsymbol{R}_1\)</span> 은 <span class="math inline">\(m \times n\)</span> 상삼각행렬이라고 하자.</p>
<p><span class="math display">\[
\boldsymbol{Q} = \boldsymbol{Q}_1 \begin{bmatrix} \boldsymbol{I}_{n} &amp; \boldsymbol{0} \\ \boldsymbol{0} &amp; \boldsymbol{Q}_2\end{bmatrix}
\]</span></p>
<p>이라 하면,</p>
<p><span class="math display">\[
\boldsymbol{Q} \left[\begin{array}{c|c} \boldsymbol{R}_1 &amp; \begin{array}{c}  \boldsymbol{w}_1 \\ \boldsymbol{r}_2 \end{array} \end{array}\right]=\boldsymbol{Q}_1 \left[\begin{array}{c|c} \boldsymbol{R}_1 &amp; \begin{array}{c}  \boldsymbol{w}_1 \\ \boldsymbol{Qr}_2 \end{array} \end{array}\right] = \boldsymbol{A}
\]</span></p>
<p>이다.</p>
</div>
<p><br></p>
<p>이미 설명한 그람 슈미트 방법과 유사하게</p>
<p>이제 <span class="math inline">\(\boldsymbol{Q}_1= \boldsymbol{Q},\, \boldsymbol{A}=\boldsymbol{A}_1\)</span> 이라 놓으면,</p>
<p><span class="math display">\[
\boldsymbol{Q}_1\boldsymbol{A}_1 = \begin{bmatrix}\alpha _{1} &amp; \ast &amp;\cdots &amp;\ast \\0 &amp; &amp; &amp;\\ \vdots &amp; &amp; \boldsymbol{A}_2 &amp; \\ 0 &amp; &amp; &amp; \end{bmatrix}
\]</span></p>
<p>꼴이 된다. 이제 행렬 <span class="math inline">\(m \times n\)</span> 행렬 <span class="math inline">\(\boldsymbol{A}_k\)</span> 가 <span class="math inline">\(k\)</span> 번째 행까지는 상삼각 행렬의 모양을 따른다고 하자. 즉 <span class="math inline">\(j\le k\)</span> 이고 <span class="math inline">\(i&gt;k\)</span> 이면 <span class="math inline">\((\boldsymbol{A}_k)_{ij}=0\)</span> 이라 하자. 이 때 <span class="math inline">\(\boldsymbol{A}_k\)</span> 의 <span class="math inline">\(k\)</span> 번째 행부터 <span class="math inline">\(m\)</span> 행, <span class="math inline">\(k\)</span> 번째 열부터 <span class="math inline">\(m\)</span> 열까지를 <span class="math inline">\(\boldsymbol{A}'_k\)</span> 라 하고,(julia 로 표현하면 <code>Ak[k:end, k:end]</code> 가 될 것이다) 이 <span class="math inline">\(\boldsymbol{A}'_k\)</span> 에 대해 앞서 <span class="math inline">\(\boldsymbol{A}\)</span> 에 했던 것과 똑같은 과정을 수행하는 하우스홀더 행렬을 <span class="math inline">\(\boldsymbol{Q}'_k\)</span> 라 하면 <span class="math inline">\(\boldsymbol{Q}'_k \boldsymbol{A}'_k\)</span> 는 <span class="math inline">\(\boldsymbol{Q}_1\boldsymbol{A}_1\)</span> 처럼 첫번째 열에서는 첫번째 행을 제외한 나며지 행의 값이 <span class="math inline">\(0\)</span> 이 된다. 만약</p>
<p><span class="math display">\[
\boldsymbol{Q}_k = \begin{bmatrix} \boldsymbol{I}_{k-1} &amp; 0 \\ 0 &amp; \boldsymbol{Q}_k'\end{bmatrix}
\]</span></p>
<p>이라 하면, <span class="math inline">\((k-1)\times (k-1)\)</span> 단위행렬 <span class="math inline">\(I_{k-1}\)</span> 과 <span class="math inline">\(\boldsymbol{A}_k\)</span> 를 <span class="math inline">\(k\)</span> 행 과 <span class="math inline">\(k\)</span> 열 부터 잘라 <span class="math inline">\(\boldsymbol{A}_{k} = \begin{bmatrix} B_{k} &amp; C_{k} \\ 0 &amp;\boldsymbol{A}'_{k}\end{bmatrix}\)</span> 로 만들자. <span class="math inline">\(B_k\)</span> 는 <span class="math inline">\((k-1) \times (k-1)\)</span> 행렬이며 <span class="math inline">\(\boldsymbol{A}'_{k}\)</span> 는 <span class="math inline">\((m-k+1)\times (n-k+1)\)</span> 행렬이다. <span class="math inline">\(\boldsymbol{A}_k\)</span> 가 <span class="math inline">\(k\)</span> 열까지 상삼각 행렬 모양이므로 <span class="math inline">\(B_k\)</span> 아래는 <span class="math inline">\(0\)</span> 행렬이다. 두 행렬의 곱은 <span class="math display">\[
\boldsymbol{Q}_k \boldsymbol{A}_k = \begin{bmatrix} \boldsymbol{I}_{k-1} &amp; 0 \\ 0 &amp; \boldsymbol{Q}_k' \end{bmatrix} \begin{bmatrix} B_{k} &amp; C_{k} \\ 0 &amp;\boldsymbol{A}'_{k}\end{bmatrix} = \begin{bmatrix} B_k &amp; C_k \\ 0 &amp; \boldsymbol{Q}'_k \boldsymbol{A'}_k \end{bmatrix}
\]</span></p>
<p>이 되고 <span class="math inline">\(\boldsymbol{Q}'_k \boldsymbol{A}'_k\)</span> 의 첫번째 열은 첫번째 행을 제외하면 모두 <span class="math inline">\(0\)</span> 이므로 <span class="math inline">\(\boldsymbol{Q}_k \boldsymbol{A}_k\)</span> 는 <span class="math inline">\(k\)</span> 열까지 상삼각 행렬 꼴이 된다.</p>
<p><span class="math inline">\(L = \min\{m,\,n\}\)</span> 이라 하면 <span class="math inline">\(\boldsymbol{Q}_L \boldsymbol{Q}_{L-1} \cdots \boldsymbol{Q}_1 \boldsymbol{A}\)</span> 는 상삼각행렬꼴이 된다. 이를 <span class="math inline">\(\boldsymbol{R}\)</span> 이라 하자. <span class="math inline">\(\boldsymbol{Q}'_k\)</span> 가 하우스홀더 행렬이므로</p>
<p><span class="math display">\[
\boldsymbol{Q}_k \boldsymbol{Q}_k^\ast = \begin{bmatrix} \boldsymbol{I}_{k-1} &amp; 0 \\ 0 &amp; \boldsymbol{Q}_k'\end{bmatrix} \begin{bmatrix} \boldsymbol{I}_{k-1} &amp; 0 \\ 0 &amp; (\boldsymbol{Q}_k')^\ast\end{bmatrix} = \begin{bmatrix} I_{k-1} &amp; 0 \\0 &amp; \boldsymbol{Q}_k'
(\boldsymbol{Q}_k')^\ast\end{bmatrix} = I
\]</span></p>
<p>이다. 즉 <span class="math inline">\(\boldsymbol{Q}_k\)</span> 도 직교행렬이다. <span class="math inline">\(\boldsymbol{Q}_k\)</span> 가 에르미트 행렬임은 쉽게 보일 수 있다. 이제,</p>
<p><span class="math display">\[
\boldsymbol{Q}_L \cdots \boldsymbol{Q}_1 \boldsymbol{A} = \boldsymbol{R} \implies \boldsymbol{A} = \boldsymbol{Q}_1^\ast \cdots \boldsymbol{Q}_L^\ast \boldsymbol{R}
\]</span></p>
<p>임은 쉽게 보일 수 있다. 직교행렬의 곱은 직교행렬이므로 <span class="math inline">\(\boldsymbol{Q}_1^\ast \cdots \boldsymbol{Q}_L^\ast\)</span> 도 직교행렬이다. 따라서 QR 분해를 할 수 있다.</p>
<p><br></p>
</section>
</section>
<section id="연습문제" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="연습문제"><span class="header-section-number">4</span> 연습문제</h2>
<div id="exr-householder-1" class="theorem exercise">
<p><span class="theorem-title"><strong>연습문제 1 </strong></span>위의 <a href="#eq-householder_vector">식&nbsp;3</a> 을 증명하라.</p>
</div>
<div class="solution proof">
<p><span class="proof-title"><em>(해답)</em>. </span><span class="math inline">\(\alpha \overline{x}_1 = \overline{\alpha}x_1 = |x_1| \|\boldsymbol{x}\|_2\)</span> 이며 <span class="math inline">\(|\alpha|^2 = \|\boldsymbol{x}\|_2^2\)</span> 이다. <span class="math inline">\(a=\alpha\overline{x}_1=\overline{\alpha}x_1\)</span> 이라 놓고 다음을 계산해 보자. <span class="math display">\[
\begin{aligned}
\langle \boldsymbol{x},\,\boldsymbol{v}\rangle &amp; = \langle \, \boldsymbol{x} , \boldsymbol{x}-\alpha \hat{\boldsymbol{e}}_1\rangle = \|\boldsymbol{x}\|_2^2-\overline{\alpha} x_1  = \|\boldsymbol{x}\|_2^2 - a\\
\langle \boldsymbol{v},\,\boldsymbol{v}\rangle &amp;= \langle \boldsymbol{x} -\alpha \boldsymbol{e}_1,\, \boldsymbol{x} -\alpha \hat{\boldsymbol{e}}_1 \rangle  = \|\boldsymbol{x}\|^2 - \overline{\alpha} x_1 -\alpha \overline{x_1} + |\alpha|^2 = 2(\|\boldsymbol{x}\|_2^2 -a) \\
&amp;= 2 \langle \boldsymbol{x},\, \boldsymbol{v} \rangle
\end{aligned}
\]</span></p>
<p>이므로, (잠시 <span class="math inline">\(\|\boldsymbol{x}\|_2\)</span> 를 <span class="math inline">\(\|\boldsymbol{x}\|\)</span> 라 하자.)</p>
<p><span class="math display">\[
\boldsymbol{H}_\boldsymbol{v} \boldsymbol{x} = \boldsymbol{x} - 2\dfrac{\langle \boldsymbol{x},\, \boldsymbol{v}\rangle}{\|\boldsymbol{v}\|^2} \boldsymbol{v} = \boldsymbol{x}-\boldsymbol{v} = \alpha \hat{\boldsymbol{e}}_1
\]</span></p>
<p>이다.</p>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../src/numerical_analysis_using_julia/07_finding_root.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">일변수 방정식의 해</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../src/numerical_analysis_using_julia/09_iterative_method_for_linear_system.html" class="pagination-link">
        <span class="nav-page-text">반복법을 이용한 선형 시스템의 해를 구하기</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>