[
  {
    "objectID": "src/image_processing/wavelet/wavelet_transform.html",
    "href": "src/image_processing/wavelet/wavelet_transform.html",
    "title": "웨이블릿 변환",
    "section": "",
    "text": "정의 1 (Wavelet) \\(\\psi\\in L^2(\\mathbb{R})\\) 이 \\(\\hat{\\psi}=\\mathfrak{F}[\\psi]\\) 에 대해 다음을 만족할 때 \\(\\psi\\) 를 웨이블릿(wavelet) 이라고 한다.\n\\[\nC_\\psi := {\\Large \\int}_{-\\infty}^\\infty \\dfrac{\\left| \\hat{\\psi}(\\omega)\\right|^2}{|\\omega|} \\, d\\omega &lt; \\infty.\n\\tag{1}\\]\n\n\n\n\n\n\n명제 1 식 1 을 admissibility condition 이라고 한다. 이 정의로부터 다음을 알 수 있다.\n  (\\(1\\)) \\(\\displaystyle \\lim_{\\omega \\to 0} \\hat{\\psi}(\\omega) = 0\\).\n  (\\(2\\)) \\(\\hat{\\psi}\\) 가 연속함수라면 \\(\\hat{\\psi}(0)=0\\) 이어야 한다.\n  (\\(3\\)) \\(\\displaystyle 0 = \\hat{\\psi}(0) = \\int_{-\\infty}^\\infty \\psi (t)\\, dt\\) 이다. 즉 \\(\\psi\\) 의 평균값은 \\(0\\) 이다.\n  (\\(4\\)) \\(\\displaystyle \\lim_{|\\omega| \\to \\infty }  \\hat{\\psi}(\\omega) = 0\\) 이다.\n\n\n\n\n\n\n\n\n\n정의 2 (웨이블릿의 \\(k\\)-차 모멘트) \\(\\psi\\in L^2(\\mathbb{R})\\) 이 웨이블릿일 때 아래와 같이 정의된 \\(m_k\\) 를 \\(k\\)-차 모멘트 라고 한다.\n\\[\nm_k := \\int_{-\\infty}^\\infty t^k \\psi(t)\\, dt.\n\\tag{2}\\]\n\n\n\n\n\n\n명제 2 정의 2 에서 \\(m_k=0\\) 인 것의 필요충분조건은 다음과 같다.\n\\[\n\\left[\\dfrac{d^k \\hat{\\psi}(\\omega)}{d\\omega^k}\\right]_{\\omega = 0} = 0.\n\\]\n\n\n(증명). 푸리에 변환의 수학적 성질 (\\(7\\)) 로부터\n\\[\n\\left[\\dfrac{d^k \\hat{\\psi}(\\omega)}{d\\omega^k}\\right]_{\\omega = 0} = (-i)^k \\mathfrak{F}\\left[t^k \\psi(t)\\right](\\omega = 0) = (-i)^k \\int_{-\\infty}^\\infty t^n \\psi(t)\\, dt = (-i)^k m_k\n\\]\n이다. \\(\\square\\)\n\n\n웨이블릿은 보통 1차부터 특정 \\(n\\) 차 까지의 모멘트가 \\(0\\) 이다. \\(m_k=0\\) 이 되는 가장 큰 \\(k\\) 값은 웨이블릿의 성질을 파악하는 중요한 값이다.\n\n\n\n예제 1 (Harr 웨이블릿) Haar 웨이블릿은 헝가리의 수학자 Alfred Haar 에 의해 도입된 최초의 웨이블릿으로 아래와 같이 정의된다.\n\\[\n\\psi_H (t) = \\left\\{\\begin{array}{ll} 1, \\qquad & 0, \\le t &lt; \\dfrac{1}{2} \\\\ -1 & \\dfrac{1}{2} \\le t &lt; 1 \\\\ 0, & \\text{otherwise}.\\end{array}\\right.\n\\tag{3}\\]\n이로부터 다음을 쉽게 알 수 있다.\n\\[\n\\int_{-\\infty}^\\infty \\psi_H (t)\\, dt = 0, \\qquad \\int_{-\\infty}^\\infty |\\psi_H(t)|^2 = 1.\n\\]\n웨이블릿의 푸리에 변환 \\(\\mathfrak{F}[\\psi_H](\\omega)\\) 는 다음과 같다.\n\\[\n\\begin{aligned}\n\\hat{\\psi}_H(\\omega) &= \\int_{0}^{1/2} e^{-i \\omega t} \\, dt - \\int_{1/2}^1 e^{-i\\omega t}\\, dt = i e^{-i\\omega/2} \\dfrac{\\sin^2(\\omega/4)}{\\omega/4}\n\\end{aligned}\n\\tag{4}\\]\nadmissibility condition 을 확인해보자.\n\\[\n{\\Large \\int}_{-\\infty}^\\infty \\dfrac{\\left| \\hat{\\psi}_H(\\omega)\\right|^2}{|\\omega|} \\, d\\omega = \\int_{-\\infty}^\\infty 16|\\omega|^{-3} \\left|\\sin^4 \\left(\\dfrac{\\omega}{4}\\right)\\right|\\, d\\omega \\le \\int_{-\\infty}^\\infty \\dfrac{16}{|\\omega|^3}\\, d\\omega &lt;\\infty\n\\]\n\n\n\nHaar 웨이블릿과 그 푸리에 변환",
    "crumbs": [
      "영상 처리/토모그래피",
      "푸리에 변환과 웨이블릿 변환",
      "웨이블릿 변환"
    ]
  },
  {
    "objectID": "src/image_processing/wavelet/wavelet_transform.html#정의와-기본적인-성질",
    "href": "src/image_processing/wavelet/wavelet_transform.html#정의와-기본적인-성질",
    "title": "웨이블릿 변환",
    "section": "",
    "text": "정의 1 (Wavelet) \\(\\psi\\in L^2(\\mathbb{R})\\) 이 \\(\\hat{\\psi}=\\mathfrak{F}[\\psi]\\) 에 대해 다음을 만족할 때 \\(\\psi\\) 를 웨이블릿(wavelet) 이라고 한다.\n\\[\nC_\\psi := {\\Large \\int}_{-\\infty}^\\infty \\dfrac{\\left| \\hat{\\psi}(\\omega)\\right|^2}{|\\omega|} \\, d\\omega &lt; \\infty.\n\\tag{1}\\]\n\n\n\n\n\n\n명제 1 식 1 을 admissibility condition 이라고 한다. 이 정의로부터 다음을 알 수 있다.\n  (\\(1\\)) \\(\\displaystyle \\lim_{\\omega \\to 0} \\hat{\\psi}(\\omega) = 0\\).\n  (\\(2\\)) \\(\\hat{\\psi}\\) 가 연속함수라면 \\(\\hat{\\psi}(0)=0\\) 이어야 한다.\n  (\\(3\\)) \\(\\displaystyle 0 = \\hat{\\psi}(0) = \\int_{-\\infty}^\\infty \\psi (t)\\, dt\\) 이다. 즉 \\(\\psi\\) 의 평균값은 \\(0\\) 이다.\n  (\\(4\\)) \\(\\displaystyle \\lim_{|\\omega| \\to \\infty }  \\hat{\\psi}(\\omega) = 0\\) 이다.\n\n\n\n\n\n\n\n\n\n정의 2 (웨이블릿의 \\(k\\)-차 모멘트) \\(\\psi\\in L^2(\\mathbb{R})\\) 이 웨이블릿일 때 아래와 같이 정의된 \\(m_k\\) 를 \\(k\\)-차 모멘트 라고 한다.\n\\[\nm_k := \\int_{-\\infty}^\\infty t^k \\psi(t)\\, dt.\n\\tag{2}\\]\n\n\n\n\n\n\n명제 2 정의 2 에서 \\(m_k=0\\) 인 것의 필요충분조건은 다음과 같다.\n\\[\n\\left[\\dfrac{d^k \\hat{\\psi}(\\omega)}{d\\omega^k}\\right]_{\\omega = 0} = 0.\n\\]\n\n\n(증명). 푸리에 변환의 수학적 성질 (\\(7\\)) 로부터\n\\[\n\\left[\\dfrac{d^k \\hat{\\psi}(\\omega)}{d\\omega^k}\\right]_{\\omega = 0} = (-i)^k \\mathfrak{F}\\left[t^k \\psi(t)\\right](\\omega = 0) = (-i)^k \\int_{-\\infty}^\\infty t^n \\psi(t)\\, dt = (-i)^k m_k\n\\]\n이다. \\(\\square\\)\n\n\n웨이블릿은 보통 1차부터 특정 \\(n\\) 차 까지의 모멘트가 \\(0\\) 이다. \\(m_k=0\\) 이 되는 가장 큰 \\(k\\) 값은 웨이블릿의 성질을 파악하는 중요한 값이다.\n\n\n\n예제 1 (Harr 웨이블릿) Haar 웨이블릿은 헝가리의 수학자 Alfred Haar 에 의해 도입된 최초의 웨이블릿으로 아래와 같이 정의된다.\n\\[\n\\psi_H (t) = \\left\\{\\begin{array}{ll} 1, \\qquad & 0, \\le t &lt; \\dfrac{1}{2} \\\\ -1 & \\dfrac{1}{2} \\le t &lt; 1 \\\\ 0, & \\text{otherwise}.\\end{array}\\right.\n\\tag{3}\\]\n이로부터 다음을 쉽게 알 수 있다.\n\\[\n\\int_{-\\infty}^\\infty \\psi_H (t)\\, dt = 0, \\qquad \\int_{-\\infty}^\\infty |\\psi_H(t)|^2 = 1.\n\\]\n웨이블릿의 푸리에 변환 \\(\\mathfrak{F}[\\psi_H](\\omega)\\) 는 다음과 같다.\n\\[\n\\begin{aligned}\n\\hat{\\psi}_H(\\omega) &= \\int_{0}^{1/2} e^{-i \\omega t} \\, dt - \\int_{1/2}^1 e^{-i\\omega t}\\, dt = i e^{-i\\omega/2} \\dfrac{\\sin^2(\\omega/4)}{\\omega/4}\n\\end{aligned}\n\\tag{4}\\]\nadmissibility condition 을 확인해보자.\n\\[\n{\\Large \\int}_{-\\infty}^\\infty \\dfrac{\\left| \\hat{\\psi}_H(\\omega)\\right|^2}{|\\omega|} \\, d\\omega = \\int_{-\\infty}^\\infty 16|\\omega|^{-3} \\left|\\sin^4 \\left(\\dfrac{\\omega}{4}\\right)\\right|\\, d\\omega \\le \\int_{-\\infty}^\\infty \\dfrac{16}{|\\omega|^3}\\, d\\omega &lt;\\infty\n\\]\n\n\n\nHaar 웨이블릿과 그 푸리에 변환",
    "crumbs": [
      "영상 처리/토모그래피",
      "푸리에 변환과 웨이블릿 변환",
      "웨이블릿 변환"
    ]
  },
  {
    "objectID": "src/posts/index.html",
    "href": "src/posts/index.html",
    "title": "The Notebook",
    "section": "",
    "text": "첫번째 글\n\n\n\n\n\n\n\n\n\n\n\nJulia_KAERI\n\n\n\n\n\n\n일치 없음"
  },
  {
    "objectID": "src/tools/tikz/tikz_functions.html",
    "href": "src/tools/tikz/tikz_functions.html",
    "title": "tikz function plots in Quarto",
    "section": "",
    "text": "코드\n```{r, engine = 'tikz'}\n#| label: fig-linear_approximation\n#| code-fold: true\n#| output: asis\n#| fig-width: 3\n#| fig-align: center\n#| fig-cap: \"tikz in Quarto 예시\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{decorations.pathreplacing}\n\n\\begin{tikzpicture}\n\\draw[very thin,color=gray] (-0.1,-0.1) grid (4.2,5.2);\n\n\\draw[-&gt;] (-0.6, 0) -- (4.2,0) node[right] {$x$};\n\\draw[-&gt;] (0,-0.6) -- (0,5.2) node[above] {$y$};\n\n\\foreach \\x in {1,...,8}\n{\n  \\draw[thin] (\\x / 2, 0.05) -- (\\x /2, -0.05);\n  }\n\n\\foreach \\x in {2, 4, 6, 8}\n{\n  \\node[below]  at (\\x /2 , -0.05) {$\\x$};\n  }\n\n\\foreach \\y in {1,...,9}\n{\n  \\draw[thin] (0.05 , \\y / 2) -- (-0.05 , \\y /2);\n  }\n\n\\foreach \\y in {2, 4, 6, 8, 10}\n{\n  \\node[left]  at (-0.05, \\y / 2) {$\\y$};\n  }\n\n\\filldraw[black] (0.5,1.1 /2) circle (2pt);\n\\filldraw[black] (2/2, 1.65 /2) circle (2pt);\n\\filldraw[black] (3/2, 3.43/2) circle (2pt);\n\\filldraw[black] (4/2, 4.02/2) circle (2pt);\n\\filldraw[black] (5/2, 4.58/2) circle (2pt);\n\\filldraw[black] (6/2, 5.78/2) circle (2pt);\n\\filldraw[black] (7/2, 7.32/2) circle (2pt);\n\n\\draw[thick, dashed, red] (0, 0) -- (3.8, 3.8);\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 1: tikz in Quarto 예시\n\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-Chevyshev_polynoimal\n#| code-fold: true\n#| output: asis\n#| fig-width: 4\n#| fig-align: center\n#| fig-cap: \"Chevyshev 다항식\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{decorations.pathreplacing}\n\n\\begin{tikzpicture}[domain=-1:1, samples = 100, scale=3]\n\n\\draw[-{stealth}] (-1.2, 0) -- (1.2,0) node[right] {$x$};\n\\draw[-{stealth}] (0,-1.2) -- (0,1.2) node[above] {$y$};\n\\node[left, scale=0.8] at (0, 1) {$1$};\n\\node[left, scale=0.8] at (0, -1) {$-1$};\n\\node[below, scale=0.8] at (-1, 0) {$-1$};\n\\node[below, scale=0.8] at (1, 0) {$1$};\n\n\\foreach \\x in {-5,...,5}\n{\n  \\draw[thin] (\\x / 5, 0.02) -- (\\x /5, -0.02);\n  }\n\n\\foreach \\y in {-5,...,5}\n{\n  \\draw[thin] (0.02 , \\y / 5) -- (-0.02 , \\y /5);\n  }\n\n\\draw[color=black]   plot (\\x, \\x) ;\n\\node[above, black] at (0.7, 0.73) {$T_1(x)$};\n\\draw[color=blue]   plot (\\x, 2 * \\x * \\x - 1);\n\\node[below right, blue] at (0, -1) {$T_2(x)$};\n\\draw[color=red]   plot (\\x, 4 * \\x * \\x * \\x - 3* \\x);\n\\node[above, red] at (-0.5, 1) {$T_3(x)$};\n\\draw[color=teal]   plot (\\x, 8 * \\x * \\x * \\x * \\x - 8* \\x * \\x + 1);\n\\node[right, teal] at (0.2, 0.8) {$T_4(x)$};\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 2: Chevyshev 다항식\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-Legendre_polynoimal\n#| code-fold: true\n#| output: asis\n#| fig-width: 4\n#| fig-align: center\n#| fig-cap: \"Legendre 다항식\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{decorations.pathreplacing}\n\n\\begin{tikzpicture}[domain=-1:1, samples = 100, scale=3]\n\n\\draw[-{stealth}] (-1.2, 0) -- (1.2,0) node[right] {$x$};\n\\draw[-{stealth}] (0,-1.2) -- (0,1.2) node[above] {$y$};\n\\node[left, scale=0.8] at (0, 1) {$1$};\n\\node[left, scale=0.8] at (0, -1) {$-1$};\n\\node[below, scale=0.8] at (-1, 0) {$-1$};\n\\node[below, scale=0.8] at (1, 0) {$1$};\n\n\\foreach \\x in {-5,...,5}\n{\n  \\draw[thin] (\\x / 5, 0.02) -- (\\x /5, -0.02);\n  }\n\n\\foreach \\y in {-5,...,5}\n{\n  \\draw[thin] (0.02 , \\y / 5) -- (-0.02 , \\y /5);\n  }\n\n\\draw[color=black]   plot (\\x, 1.5 * \\x * \\x - 0.5 ) ;\n\\node[above, black] at (-0.7, 0.73) {$P_2(x)$};\n\\draw[color=blue]   plot (\\x, 2.5 * \\x * \\x * \\x - 1.5 * \\x);\n\\node[above, blue] at (-0.5, 0.4) {$P_3(x)$};\n\\draw[color=red]   plot (\\x, 35/8 * \\x * \\x * \\x *\\x - 30 / 8 * \\x *\\x + 3/8 );\n\\node[red] at (-0.5, -0.5) {$P_4(x)$};\n\\draw[color=teal]   plot (\\x, 63/8 * \\x * \\x * \\x * \\x * \\x - 70/8* \\x * \\x * \\x + 15/8 * \\x);\n\\node[right, teal] at (0.2, 0.5) {$P_5(x)$};\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 3: Legendre 다항식",
    "crumbs": [
      "Tools",
      "tikz function plots in Quarto"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/A_generalized_inverse.html",
    "href": "src/numerical_analysis_using_julia/A_generalized_inverse.html",
    "title": "일반화된 역행렬과 의사 역행렬",
    "section": "",
    "text": "정의 1 (일반화된 역행렬) 행렬 \\(\\boldsymbol{A} \\in \\mathcal{M}_{m \\times n}(\\mathbb{F})\\) 에 대해 \\(\\boldsymbol{AGA}=\\boldsymbol{A}\\) 를 만족하는 행렬 \\(\\boldsymbol{G} \\in \\mathcal{M}_{n \\times m}(\\mathbb{F})\\) 를 \\(\\boldsymbol{A}\\) 에 대한 일반화된 역행렬(generalized inverse matrix) 라고 한다. \\(\\boldsymbol{A}\\) 의 일반화된 역행렬을 \\(\\boldsymbol{A}^{-}\\) 로 표기한다.\n\n\n\n\n\n\n명제 1 \\(\\boldsymbol{A}\\) 가 가역행렬이면 \\(\\boldsymbol{G}=\\boldsymbol{A}^{-1}\\) 이다.\n\n\n(증명). \\(\\boldsymbol{A}\\) 가 가역행렬이면 \\(m=n\\) 이다. \\[\n\\boldsymbol{AGA} = \\boldsymbol{A} \\implies \\boldsymbol{AGAA}^{-1} = \\boldsymbol{AA}^{-1} \\implies \\boldsymbol{AG}= \\boldsymbol{I}_n \\qquad \\square\n\\]\n\n\n\n명제 2 \\(\\boldsymbol{A}\\in \\mathcal{M}_{m \\times n}(\\mathbb{F})\\) 와 \\(\\boldsymbol{G}\\in \\mathcal{M}_{n \\times n}\\) 에 대해 다음은 동치이다.\n  (\\(1\\)) \\(\\boldsymbol{G}\\) 는 \\(\\boldsymbol{A}\\) 의 일반화된 역행렬이다.\n  (\\(2\\)) \\(\\boldsymbol{AG}=\\boldsymbol{I}_m\\) 이고 \\(\\operatorname{rank}(\\boldsymbol{AG})= \\operatorname{rank}(\\boldsymbol{A})\\) 이거나 \\(\\boldsymbol{GA}= \\boldsymbol{I}_n\\) 이고 \\(\\operatorname{rank}(\\boldsymbol{GA})= \\operatorname{rank}(\\boldsymbol{G})\\) 이다.\n  (\\(3\\)) \\(\\boldsymbol{Ay}=\\boldsymbol{x}\\) 의 해는 \\(\\boldsymbol{x}=\\boldsymbol{Gy}\\) 이다.\n\n\n(증명). (\\(1\\implies 2\\))",
    "crumbs": [
      "수치해석",
      "수학",
      "일반화된 역행렬과 의사 역행렬"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/A_generalized_inverse.html#일반화된-역행렬",
    "href": "src/numerical_analysis_using_julia/A_generalized_inverse.html#일반화된-역행렬",
    "title": "일반화된 역행렬과 의사 역행렬",
    "section": "",
    "text": "정의 1 (일반화된 역행렬) 행렬 \\(\\boldsymbol{A} \\in \\mathcal{M}_{m \\times n}(\\mathbb{F})\\) 에 대해 \\(\\boldsymbol{AGA}=\\boldsymbol{A}\\) 를 만족하는 행렬 \\(\\boldsymbol{G} \\in \\mathcal{M}_{n \\times m}(\\mathbb{F})\\) 를 \\(\\boldsymbol{A}\\) 에 대한 일반화된 역행렬(generalized inverse matrix) 라고 한다. \\(\\boldsymbol{A}\\) 의 일반화된 역행렬을 \\(\\boldsymbol{A}^{-}\\) 로 표기한다.\n\n\n\n\n\n\n명제 1 \\(\\boldsymbol{A}\\) 가 가역행렬이면 \\(\\boldsymbol{G}=\\boldsymbol{A}^{-1}\\) 이다.\n\n\n(증명). \\(\\boldsymbol{A}\\) 가 가역행렬이면 \\(m=n\\) 이다. \\[\n\\boldsymbol{AGA} = \\boldsymbol{A} \\implies \\boldsymbol{AGAA}^{-1} = \\boldsymbol{AA}^{-1} \\implies \\boldsymbol{AG}= \\boldsymbol{I}_n \\qquad \\square\n\\]\n\n\n\n명제 2 \\(\\boldsymbol{A}\\in \\mathcal{M}_{m \\times n}(\\mathbb{F})\\) 와 \\(\\boldsymbol{G}\\in \\mathcal{M}_{n \\times n}\\) 에 대해 다음은 동치이다.\n  (\\(1\\)) \\(\\boldsymbol{G}\\) 는 \\(\\boldsymbol{A}\\) 의 일반화된 역행렬이다.\n  (\\(2\\)) \\(\\boldsymbol{AG}=\\boldsymbol{I}_m\\) 이고 \\(\\operatorname{rank}(\\boldsymbol{AG})= \\operatorname{rank}(\\boldsymbol{A})\\) 이거나 \\(\\boldsymbol{GA}= \\boldsymbol{I}_n\\) 이고 \\(\\operatorname{rank}(\\boldsymbol{GA})= \\operatorname{rank}(\\boldsymbol{G})\\) 이다.\n  (\\(3\\)) \\(\\boldsymbol{Ay}=\\boldsymbol{x}\\) 의 해는 \\(\\boldsymbol{x}=\\boldsymbol{Gy}\\) 이다.\n\n\n(증명). (\\(1\\implies 2\\))",
    "crumbs": [
      "수치해석",
      "수학",
      "일반화된 역행렬과 의사 역행렬"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/12_ode_initial_value_problem_2.html",
    "href": "src/numerical_analysis_using_julia/12_ode_initial_value_problem_2.html",
    "title": "상미분 방정식의 초기값 문제-II",
    "section": "",
    "text": "지금까지 상미분 방정식의 초기값 문제에 대한 기본적인 지식을 쌓았다. 이제 좀 더 정교한 미분방정식의 수치해석적 풀이법을 알아보고자 한다.",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "상미분 방정식의 초기값 문제-II"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/12_ode_initial_value_problem_2.html#runge-kutta-fehlberg-방법rkf",
    "href": "src/numerical_analysis_using_julia/12_ode_initial_value_problem_2.html#runge-kutta-fehlberg-방법rkf",
    "title": "상미분 방정식의 초기값 문제-II",
    "section": "1 Runge-Kutta-Fehlberg 방법(RKF)",
    "text": "1 Runge-Kutta-Fehlberg 방법(RKF)\n미분방정식의 초기값 문제\n\\[\nx'(t) = f(t, x),\\qquad x(t_0) = x_0\n\\]\n를 생각하자. 지금까지의 오일러 방법이나 RK2, RK4 에서는 정해진 간격 \\(h&gt;0\\) 에 대해 \\(t_k = t_0 + kh\\) 를 이용하였다. 이 경우\n\\[\nx_{k+1} = x_k + \\phi (t_k,\\,x_k) + O(h^{n+1})\n\\]\n의 꼴로 \\(x(t)\\) 의 경로를 얻었다. 이 때 오차는 방법에 따라 \\(n\\) 값이 정해지는 \\(ch^{n+1}\\) 이었다.\n그러나 이제는 간격 \\(h\\) 를 조절하고자 한다. 이렇게 수치해석에서 문제에 주어진 변수가 아닌 문제 해결에 사용되는 값(여기서는 \\(h\\)) 를 문제 해결 도중에 유연하게 변경하는 방법을 적응형(adaptive) 라고 한다. Runge-Kutta-Fehlberg 방법이 바로 적응형 수치해석 방법중 하나이다. 즉 지금까지는\n\\[\n\\begin{aligned}\nt_{k+1} &= t_k + h, \\\\\nx_{k+1} &= x_k + \\phi (t_k,\\, x_k)\n\\end{aligned}\n\\]\n로 문제를 풀어왔다면 이제는\n\\[\n\\begin{aligned}\nt_{k+1} & = t_k + h_k,\\\\\nx_{k+1} & = x_k + \\phi (t_k,\\, x_k,\\,h_k)\n\\end{aligned}\n\\]\n로 문제를 풀게 될 것이다. \\(h_k\\) 를 어떻게 정하는 지가 중요한 전환점이 될 것이다.\n이제 \\(t_k,\\,x_k\\) 와 정해진 \\(h\\) 에 따라 \\(x_{k+1}\\) 을 정하는 함수에 \\(\\phi\\) 와 \\(\\tilde{\\phi}\\) 의 두가지 방법이 있다고 하자. \\(\\phi\\) 의 trunction error 는 \\(O(h^{n+1})\\) 이며 \\(\\tilde{\\phi}\\) 의 truncation error 는 \\(O(h^{n+2})\\) 라고 하자. 각각의 방법을 구분하기 위해,\n\\[\n\\begin{aligned}\nx_{k+1} & = x_k + \\phi (t_k,\\,x_k,\\, h),\\\\\n\\tilde{x}_{k+1} &= \\tilde{x}_k + \\tilde{\\phi}(t_k,\\,\\tilde{x}_k,\\,h)\n\\end{aligned}\n\\]\n라고 하자. 이제 수치해석적인 방법으로 계산한 \\(x_{k}\\) 와 실제 해 \\(x(t_k)\\) 를 구분하기로 하자. \\(x_{k} \\approx \\tilde{x}_k \\approx x(t_k)\\) 라고 가정 할 때 \\(t_{k+1}\\) 에서의 실제 경로 \\(x(t_{k+1})\\) 과의 truncation error \\(\\tau_{k+1}(h)\\) 는\n\\[\n\\tau_{k+1}= \\vartau\n\\]",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "상미분 방정식의 초기값 문제-II"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/08_matrix_decomposition.html",
    "href": "src/numerical_analysis_using_julia/08_matrix_decomposition.html",
    "title": "행렬의 분해",
    "section": "",
    "text": "선형 대수학에서 행렬 분해는 행렬을 다른 행렬들의 곱으로 분해하는 것을 말한다. 다양한 행렬 분해 방법이 존재하며, 각각은 특정 유형의 문제 해결에 활용된다. 수치 해석에서는 효율적인 행렬 알고리즘을 구현하는 데 다양한 분해 방법을 사용 할 수 있다. 우리는 이미 LU 분해를 하는 방법과 그 유용성을 알아 보았다. 여기서는 다양한 행렬의 분해에 대해 알아보고자 한다.",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "행렬의 분해"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/08_matrix_decomposition.html#수학적-기초",
    "href": "src/numerical_analysis_using_julia/08_matrix_decomposition.html#수학적-기초",
    "title": "행렬의 분해",
    "section": "1 수학적 기초",
    "text": "1 수학적 기초\n\n대각 지배 행렬\n\n\n\n\n\n\n\n정의 1 (대각 지배 행렬) 행렬 \\(\\boldsymbol{A}\\in \\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 의 각 행의 대각성분의 절대값이 그 행의 대각성분을 제외한 성분의 절대값의 합보다 크면, 즉 각각의 \\(i=1,\\ldots,\\,n\\) 행에 대해\n\\[\n|A_{ii}| \\ge \\sum_{j=1,\\, j\\ne i}^n |A_{ij}|, \\qquad i=1,\\ldots,\\,n\n\\]\n이면 이 행렬 \\(\\boldsymbol{A}\\) 를 행에 대한 대각 지배 행렬 (row-wise diagonally dominant matrix)이라 한다. 또한 각 열에대해\n\\[\n|A_{ii}| \\ge \\sum_{j=1,\\, j\\ne i}^n |A_{ji}|, \\qquad i=1,\\ldots,\\,n\n\\]\n이면 이 행렬 \\(\\boldsymbol{A}\\) 를 열에 대한 대각 지배 행렬 (column-wise diagonally dominant matrix)이라 한다. 행/열 에 대한 대각 지배 행렬의 조건에서 등호 조건을 제외하고 성립하면 행/열 에 대한 엄격한 대각 지배 행렬 (strictly row-wise/column-wise diagonally dominant matrix) 이라고 한다.\n\n\n\n\n\n\n\n명제 1 엄격한 대각 지배 행렬은 가역행렬이다.\n\n\n\n\n(증명). 행에 대해 엄격한 대각 지배 행렬 \\(\\boldsymbol{A}\\) 이 가역행렬이면, \\(\\boldsymbol{A}^T\\) 는 열에 대해 엄격한 대각 지배 행렬이며 가역행렬이다. 따라서 행에 대해 엄격한 대각 지배 행렬이 가역행렬임을 보이면 된다.\n\\(\\boldsymbol{A}\\in \\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 이 행에 대한 엄격한 대각 지배 행렬이라고 하자. \\(\\boldsymbol{A}\\) 가 가역행렬이 아니면 \\(\\boldsymbol{Ax}=\\boldsymbol{0}\\) 을 만족하는 \\(\\boldsymbol{x}\\ne \\boldsymbol{0}\\) 이 존재하지 않으므로 존재한다고 가정하고 모순이 생긴다는 것을 보이자. 이 \\(\\boldsymbol{x}\\) 의 성분 가운데 그 절대값이 가장 큰 \\(|x_k|\\ne 0\\) 을 찾을 수 있다. \\(\\boldsymbol{Ax}=0\\) 이므로, 각각의 \\(i=1,\\ldots,\\,n\\) 에 대해\n\\[\n\\sum_{j=1}^n A_{ij}x_j=0\n\\]\n이며, 따라서 \\(x_k\\) 의 \\(k\\) 에 대해\n\\[\nA_{kk}x_k = -\\sum_{j=1,\\,j \\ne k}^n A_{kj}x_j\n\\]\n이다. \\(\\boldsymbol{A}\\) 가 행에 대해 엄격한 대각 지배 행렬이므로 모든 대각성분은 \\(0\\) 이 아니다. 삼각부등식에 의해,\n\\[\n|A_{kk}| |x_k|  \\le \\sum_{j=1,\\,j\\ne k}^n |A_{kj}| |x_j|\n\\]\n이 성립하며 \\[\n|A_{kk}| \\le \\sum_{j= 1,\\, j \\ne k}^n \\dfrac{|x_j|}{|x_k|} |A_{kj}| &lt; \\sum_{j= 1,\\, j \\ne k}^n |A_{kj}|\n\\]\n이므로 \\(\\boldsymbol{A}\\) 가 행에 대해 엄격한 대각 지배 행렬이라는 가정에 위배된다. 따라서 \\(\\boldsymbol{A}\\) 는 가역행렬이다. \\(\\square\\)\n\n\n\n\n명제 2 행에 대해 엄격한 대각 지배 행렬은 피보팅 없이 가우스-요르단 소거법을 수행 할 수 있다.\n\n\n\n\n(증명). \\(\\boldsymbol{A}\\in\\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 가 행에 대해 엄격한 대각 지배 행렬일 때 induction 으로 증명한다. 우선 \\(n=1\\) 일 경우는 자명하다. \\(n\\) 에 대해 명제가 성립함을 가정하자. 가우스-요르단 소거법을 첫번째 행을 가준으로 하여 피보팅 없이 두번째 행부터 \\(n+1\\) 번째 행까지 첫번째 열을 소거한 행렬을 \\(\\boldsymbol{A}'\\) 이라 하면 \\[\nA'_{ij} = A_{ij}- \\dfrac{A_{i1}}{A_{11}}A_{1j},\\qquad i=2,\\ldots,\\,n+1 \\tag{1}\n\\]\n이다.\n\\[\n\\begin{aligned}\n\\sum_{j=2,\\, j\\ne i}^n |A'_{ij}| &= \\sum_{j=2,\\, j \\ne i} \\left|A_{ij}- \\dfrac{A_{i1}}{A_{11}}A_{1j}\\right| \\le \\sum_{j=2,\\, j \\ne i}^n |A_{ij}| + \\sum_{j=2,\\,j \\ne i} \\left|\\dfrac{A_{i1}}{A_{11}}A_{1j}\\right|\n\\end{aligned}\\tag{2}\n\\]\n이다. 행에 대한 엄격한 지배행렬이라는 조건으로 부터 다음을 얻는다.\n\\[\n\\begin{aligned}\n\\sum_{j=2,\\, j \\ne i}^n |A_{ij}| &lt; |A_{ii}| - |A_{i1}|,\\\\\n\\sum_{j=2,\\, j \\ne i}^n |A_{1j}| &lt; |A_{11}| - |A_{1i}|\n\\end{aligned} \\tag{3}\n\\]\n위 식을 이용하여 \\((3)\\) 를 보면 \\[\n\\sum_{j=2,\\, j\\ne i}^n |A'_{ij}| &lt; |A_{ii}|-|A_{i1}| + \\dfrac{|A_{i1}|}{|A_{11}|} \\left(|A_{11}| - |A_{1i}|\\right) = |A_{ii}| - \\dfrac{|A_{i1}|}{|A_{11}|} |A_{1i}| \\tag{4}\n\\]\n이다. \\((1)\\) 로 부터,\n\\[\n|A'_{ii}| = \\left|A_{ii}- \\dfrac{A_{i1}}{A_{11}}A_{1i}\\right| \\ge \\left|A_{ii}\\right|- \\left|\\dfrac{A_{i1}}{A_{11}}A_{1i}\\right| \\tag{5}\n\\]\n이므로, \\((4)\\) 와 \\((5)\\) 를 결합하면,\n\\[\n|A'_{ii}| &gt; \\sum_{j=2,\\, j\\ne i}^n |A'_{ij}|\n\\]\n이다. 즉 2행 2열부터 \\(n+1\\) 행 \\(n+1\\) 열까지의 \\(\\boldsymbol{A}'\\) 의 부분행렬은 행에 대해 엄격한 지배행렬이므로 가정에 의해 피보팅 없이 가우스-조르단 소거법을 수행 할 수 있다. 따라서 임의의 크기의 정사각 행렬이 행에 대해 엄격한 대각 지배 행렬일 때, 피보팅 없이 가우스-조르단 소거법을 수행 할 수 있다. \\(\\square\\)\n\n\n\n\nPositive Definite 행렬\n\n\n\n\n\n\n\n정의 2 (Positive definite 행렬) 행렬 \\(\\boldsymbol{A}\\in \\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 이 에르미트 행렬이며 모든 \\(\\boldsymbol{x}\\in \\mathcal{M}_n(\\mathbb{F})\\), \\(\\boldsymbol{x}\\ne \\boldsymbol{0}\\) 에 대해 \\(\\langle \\boldsymbol{Ax},\\boldsymbol{x}\\rangle &gt; 0\\) 일 경우, 즉 \\(\\boldsymbol{x}^T\\boldsymbol{Ax}&gt;0\\) 일 경우 \\(\\boldsymbol{A}\\) 를 positive definite 라 한다.\n\n\n\n\n\nPositive definite 행렬은 복소수체에서 정의할 수도 있으나 여기서는 실수체에서 정의된 행렬만 생각하기로 한다. Positive definite 행렬은 정의상 대칭행렬이므로 Interude : 수학에 관련된 표기법과 명제들 의 실수체에서 정의된 행렬의 스펙트럼 정리 를 만족한다. 즉 모든 \\(\\boldsymbol{x}\\in \\mathcal{M}_n(\\mathbb{R})\\) 은 \\(\\boldsymbol{A}\\) 의 고유벡터의 선형결합으로 표현 할 수 있다. 이제 positive definite 행렬에 대한 성질을 알아보자.\n\n\n\n명제 3 \\(\\boldsymbol{A}\\in \\mathcal{M}_{n \\times n}(\\mathbb{R})\\) 이 positive definite 일 경우 다음이 성립한다.\n  (\\(1\\)) \\(\\boldsymbol{A}\\) 의 모든 고유값은 양수이다.\n  (\\(2\\)) \\(\\det (\\boldsymbol{A}) &gt;0\\) 이다.\n  (\\(3\\)) \\(\\boldsymbol{A}\\) 는 가역행렬이다.\n  (\\(4\\)) \\(\\boldsymbol{A}\\) 의 대각성분은 모두 양수이다.\n  (\\(5\\)) \\(|A_{ij}| \\le \\max \\{|A_{ii}| : i=1,\\ldots,\\,n\\}\\).\n  (\\(6\\)) 모든 \\(i\\ne j\\) 에 대해 \\((A_{ij})^2 &lt; A_{ii} A_{jj}\\) 이다.\n\n\n\n\n(증명). (\\(1\\)) \\(\\lambda\\) 가 \\(\\boldsymbol{A}\\) 의 고유값이며 \\(\\boldsymbol{v}\\) 가 \\(\\lambda\\) 에 대한 고유벡터일 경우 \\(\\lambda = \\langle \\boldsymbol{Av}, \\boldsymbol{v}\\rangle &gt;0\\) 이어야 한다.\n(\\(2\\)) 대칭행렬 \\(\\boldsymbol{A}\\) 의 행렬식은 모든 고유값의 곱이므로 양수이다.\n(\\(3\\)) \\(\\boldsymbol{x}\\ne 0\\) 이며 \\(\\boldsymbol{Ax}=\\boldsymbol{0}\\) 일 경우 \\(\\langle \\boldsymbol{Ax}, \\boldsymbol{x}\\rangle = 0\\) 인데 이는 \\(\\boldsymbol{A}\\) 가 positive definite 가 아니라는 의미이다.\n(\\(4\\)) \\(A_{ii} = \\langle \\boldsymbol{A}\\hat{\\boldsymbol{e}}_i,\\, \\hat{\\boldsymbol{e}}_i\\rangle  &gt; 0\\)\n(\\(5\\)) \\(i\\ne j\\) 에 대해\n\\[\n\\begin{aligned}\n0&lt; \\langle \\boldsymbol{A}(\\hat{\\boldsymbol{e}}_i-\\hat{\\boldsymbol{e}}_j), (\\hat{\\boldsymbol{e}}_i-\\hat{\\boldsymbol{e}}_j)\\rangle = A_{ii}+ A_{jj} - 2 A_{ij} \\\\\n0&lt; \\langle \\boldsymbol{A}(\\hat{\\boldsymbol{e}}_i+\\hat{\\boldsymbol{e}}_j), (\\hat{\\boldsymbol{e}}_i+\\hat{\\boldsymbol{e}}_j)\\rangle = A_{ii}+ A_{jj} + 2 A_{ij} \\\\\n\\end{aligned}\n\\]\n이므로 \\[\n|A_{ij}| &lt; \\dfrac{A_{ii}+A_{jj}}{2} \\le \\max \\{|A_{ii}| : i=1,\\ldots,\\,n\\}\n\\]\n이다.\n(\\(6\\)) 임의의 실수 \\(t\\) 에 대해 \\(\\boldsymbol{x} = \\hat{\\boldsymbol{e}}_i + t \\hat{\\boldsymbol{e}}_j\\) 라고 하자. \\(\\langle \\boldsymbol{Ax},\\,\\boldsymbol{x}\\rangle = t^2A_{ii} + 2tA_{ij} + A_{jj} &gt; 0\\) 이므로 \\((A_{ij})^2-A_{ii}A_{ij}&lt;0\\) 이어야 한다. \\(\\square\\)\n\n\n\n\n\n\n\n\n\n정의 3 (부분 행렬과 선행 주 부분 행렬) 행렬 \\(\\boldsymbol{A}\\in \\mathcal{M}_{m\\times n}(\\mathbb{F})\\) 에 대해 임의의 중복되지 않은 행 \\(I=\\{i_1,\\ldots,\\,i_p: 1\\le i_k\\le m\\}\\) 과 중복되지 않은 열 \\(J=\\{j_1,\\ldots,\\,j_q: 1 \\le j_l \\le n \\}\\) 을 모아 만든 행렬을 \\(\\boldsymbol{A}\\) 의 부분 행렬 (submatrix)이라고 하고 \\(\\boldsymbol{A}[I, J]\\) 라고 쓴다. \\(I=J=\\{1,\\,2,\\ldots,\\,k\\}\\)일 때 \\(\\boldsymbol{A}[I, J]\\) 를 선행 주 부분 행렬 (leading principal submatrix) 이라고 한다.\n\n\n\n\n\n이제 정사각 행렬 \\(\\boldsymbol{A}\\) 가 positive definite 인 것과 \\(\\boldsymbol{A}\\) 의 모든 선행 주 부분행렬의 행렬식이 \\(0\\) 보다 큰 것이 동치임을 보이고자 한다. 이를 위해 몇가지 미리 보여야 할 것이 있다.\n\n\n보조정리 1 \\(\\boldsymbol{A}\\in \\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 이 에르미트행렬이고 \\(\\boldsymbol{Q} \\in \\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 이 가역행렬 일 때 다음은 동치이다.\n  (\\(1\\)) \\(\\boldsymbol{A}\\) 가 positive definite 이고 \\(\\boldsymbol{Q}^\\ast\\boldsymbol{AQ}\\) 가 에르미트행렬이다.\n  (\\(2\\)) \\(\\boldsymbol{Q}^\\ast \\boldsymbol{AQ}\\) 가 positive definte 이다.\n\n\n\n\n(증명). (\\(1 \\implies 2\\)) \\(\\boldsymbol{0}\\) 벡터가 아닌 \\(\\boldsymbol{v}\\in \\mathcal{M}_n(\\mathbb{F})\\) 에 대해 \\(\\boldsymbol{Qv}\\ne \\boldsymbol{0}\\) 이다. \\(\\boldsymbol{A}\\) 가 positive definite 이므로,\n\\[\n0 &lt; (\\boldsymbol{Qv})^\\ast \\boldsymbol{A}(\\boldsymbol{Qv}) = \\boldsymbol{v}^\\ast \\left(\\boldsymbol{Q}^\\ast\\boldsymbol{AQ}\\right)\\boldsymbol{v}\n\\]\n이므로 \\(\\boldsymbol{Q}^\\ast\\boldsymbol{AQ}\\) 는 positive definite 이다.\n(\\(2 \\implies 1\\)) \\(\\boldsymbol{A}\\) 가 에르미트행렬이므로 \\((\\boldsymbol{Q}^\\ast\\boldsymbol{AQ})^\\ast = \\boldsymbol{Q}^\\ast \\boldsymbol{A}^\\ast\\boldsymbol{Q} = \\boldsymbol{Q}^\\ast\\boldsymbol{AQ}\\) 이다. 즉 \\(\\boldsymbol{Q}^\\ast\\boldsymbol{AQ}\\) 는 에르미트행렬이다. \\(\\boldsymbol{Q}\\) 가 가역이므로 임의의 \\(\\boldsymbol{x}\\in \\mathcal{M}_n(\\mathbb{F})\\) 에 대해 \\(\\boldsymbol{x}=\\boldsymbol{Qy}\\) 를 만족하는 \\(\\boldsymbol{y}\\in \\mathcal{M}_n(\\mathbb{F})\\) 이 존재한다.\n\\[\n\\boldsymbol{x}^\\ast\\boldsymbol{Ax} =  (\\boldsymbol{Qy})^\\ast \\boldsymbol{A}\\boldsymbol{Qy} = \\boldsymbol{y}^\\ast\\boldsymbol{Q}^\\ast\\boldsymbol{AQ}\\boldsymbol{y} &gt; 0\n\\]\n이므로 \\(\\boldsymbol{A}\\) 는 positive defnite 이다. \\(\\square\\)\n\n\n\n\n명제 4 (실베스터 판정법 (Sylvester’s criterion)) 에르미트 행렬 \\(\\boldsymbol{A}\\) 에 대해 다음은 동치이다.\n  (\\(1\\)) \\(\\boldsymbol{A}\\) 의 모든 선행 주 부분 행렬의 행렬식이 양수이다.\n  (\\(2\\)) \\(\\boldsymbol{A}\\) 는 positive definite 이다.\n\n\n 명제 4 가 실베스터 판정법이라고 불리우는 것은 임의의 에르미트 행렬이 positive definite 인지 아닌지를 확인하는 방법이기 때문이다.\n\n(증명). \\(\\boldsymbol{A}\\) 의 \\(k\\) 행 \\(k\\) 열 까지의 선 주 부분행렬을 \\(\\boldsymbol{A}_k\\) 라고 쓰자.\n(\\(1\\implies 2\\)) Inductinon 을 통해 증명한다. \\(1 \\times 1\\) 행렬의 경우는 trivial 하다. 이제 \\(n\\times n\\) 행렬에 대해 성립한다고 가정한다. \\(\\boldsymbol{A}\\) 가 \\((n+1)\\times (n+1)\\) 행렬이라 하자.Carl P.Simon & Lawrence E. Blume 의 Mathematics for Economists 에 나오는 증명이다.\n우선 모든 \\(\\boldsymbol{A}_i\\), \\(i=1,\\ldots,\\,n\\) 의 행렬식이 양수이면 \\(\\boldsymbol{A}\\) 가 positive definite 임을 보이자. 우선 \\(\\boldsymbol{A}\\) 를 \\(\\boldsymbol{A}_n\\) 에 대하여 아래와 같이 분할하여 보자.\n\\[\n\\boldsymbol{A} = \\left[\\begin{array}{c|c} \\boldsymbol{A}_n & \\boldsymbol{a} \\\\ \\hline \\boldsymbol{a}^\\ast & a\\end{array}\\right].\n\\]\n여기서 \\(\\boldsymbol{a}=\\begin{bmatrix} A_{1, n+1} & \\cdots & A_{n, n+1}\\end{bmatrix}^T\\) 이고 \\(a=A_{n+1, n+1}\\) 이다. 또한 \\(\\boldsymbol{A}\\) 가 에르미트행렬이므로 \\(\\boldsymbol{A}_n\\) 도 에르미트행렬이며 따라서 \\((\\boldsymbol{A}^\\ast)^{-1}=\\boldsymbol{A}^{-1}\\) 이다. . 그렇다면,\n\\[\n\\boldsymbol{A} = \\left[\\begin{array}{c|c} \\boldsymbol{I}_n & \\boldsymbol{0} \\\\ \\hline (\\boldsymbol{A}_n^{-1}\\boldsymbol{a})^\\ast & 1\\end{array}\\right] \\left[\\begin{array}{c|c} \\boldsymbol{A}_n & \\boldsymbol{0}_n \\\\ \\hline (\\boldsymbol{0}_n)^\\ast & d\\end{array}\\right] \\left[\\begin{array}{c|c} \\boldsymbol{I}_n & \\boldsymbol{A}_n^{-1}\\boldsymbol{a} \\\\ \\hline (\\boldsymbol{0}_n)^\\ast & 1\\end{array}\\right] = \\boldsymbol{Q}^\\ast\\boldsymbol{BQ}\n\\]\n이며 이 때 \\(d=a-\\boldsymbol{a}^\\ast(\\boldsymbol{A}_n)^{-1}\\boldsymbol{a}\\) 이다. 우리는 \\(\\det (\\boldsymbol{Q}^\\ast) = \\det (\\boldsymbol{Q})=1\\) 이며 \\(\\det (\\boldsymbol{B})=d \\cdot \\det (\\boldsymbol{A}_n)\\) 임을 안다. 즉\n\\[\n\\det (\\boldsymbol{A}) =  d \\cdot \\det (\\boldsymbol{A}_n)\n\\]\n이다. \\(\\boldsymbol{A}\\) 가 positive definite 이며 \\(\\det (\\boldsymbol{A})&gt;0\\) 이므로 \\(d&gt;0\\) 이다. 즉 모든 선행 주 부분행렬식이 양수이면 그 행렬은 positive definite 이다.\n(\\(2 \\implies 1\\)) \\(\\boldsymbol{A}\\) 가 positive definite 임을 가정하자. 임의의 \\(\\boldsymbol{x}\\in \\mathcal{M}_{n+1}(\\mathbb{R})\\) 에 대해 \\(\\boldsymbol{x} = \\begin{bmatrix} \\boldsymbol{x}_0 & x \\end{bmatrix}^T\\), \\(\\boldsymbol{x}_0 \\in \\mathcal{M}_{n}(\\mathbb{R})\\) 이라 하면,\n\\[\n\\boldsymbol{x}^\\ast \\boldsymbol{Bx} = \\boldsymbol{x}^\\ast \\boldsymbol{A}_n \\boldsymbol{x} + d\\cdot x^2\n\\]\n이다. \\(\\boldsymbol{A}_n\\) 이 가정에 의해 positive definite 이며, \\(d&gt;0\\) 이므로 \\(\\boldsymbol{x}^\\ast\\boldsymbol{Bx}&gt;0\\) 이다. 따라서 보조정리 1 에 의해 \\(\\boldsymbol{B}=\\boldsymbol{Q}^\\ast\\boldsymbol{AQ}\\) 일 때 \\(\\boldsymbol{A}\\) 는 positive definite 이다. \\(\\square\\)",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "행렬의 분해"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/08_matrix_decomposition.html#숄레스키-분해",
    "href": "src/numerical_analysis_using_julia/08_matrix_decomposition.html#숄레스키-분해",
    "title": "행렬의 분해",
    "section": "2 숄레스키 분해",
    "text": "2 숄레스키 분해\n\n\\(\\boldsymbol{LL}^\\ast\\) 분해\n\n\n정리 1 Positive definite 행렬 \\(\\boldsymbol{A}\\in \\mathcal{M}_{n \\times n}(\\mathbb{F})\\)은 어떤 모든 대각성분이 양수인 하삼각행렬 \\(\\boldsymbol{L} \\in \\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 에 대해 \\(\\boldsymbol{A}= \\boldsymbol{LL}^\\ast\\) 이다.\n\n\n\n\n(증명). 수학적 귀납법으로 증명한다. \\(n=1\\) 일 때 경우 \\(\\boldsymbol{A}=\\begin{bmatrix}a \\end{bmatrix}\\) 라면 명제 3 의 (\\(4\\)) 에 의해 \\(a&gt;0\\) 이므로 \\(\\boldsymbol{L}=\\begin{bmatrix} \\sqrt{a}\\end{bmatrix}\\) 이다. \\(n\\) 일때 성립함을 가정하자. \\(\\boldsymbol{A}\\in \\mathcal{M}_{(n+1)\\times (n+1)}(\\mathbb{F})\\) 에 대해\n\\[\n\\boldsymbol{A} = \\left[\\begin{array}{c|c} \\boldsymbol{A}_n & \\boldsymbol{b} \\\\ \\hline \\boldsymbol{b}^\\ast & a\\end{array}\\right].\n\\]\n로 표현 할 수 있다. \\(\\boldsymbol{A}_n = \\boldsymbol{L}_n \\boldsymbol{L}_n^\\ast\\) 라면 일 때\n\\[\n\\boldsymbol{L} = \\left[\\begin{array}{c|c} \\boldsymbol{L}_n & \\boldsymbol{0} \\\\ \\hline \\boldsymbol{c}^\\ast & d\\end{array}\\right].\n\\]\n라 하자.\n\\[\n\\boldsymbol{LL}^\\ast = \\left[\\begin{array}{c|c} \\boldsymbol{L}_n\\boldsymbol{L}_n^\\ast & \\boldsymbol{L}_n \\boldsymbol{c} \\\\ \\hline (\\boldsymbol{L}_n \\boldsymbol{c})^\\ast & |d|^2\\end{array}\\right].\n\\]\n이므로 \\(\\boldsymbol{b}=\\boldsymbol{L}_n \\boldsymbol{c}\\), \\(d+ \\boldsymbol{c}^\\ast\\boldsymbol{c}=|a|^2\\) 을 만족하는 \\(\\boldsymbol{c}\\) 와 양수 \\(d\\) 가 존재한다면 \\(\\boldsymbol{A} = \\boldsymbol{LL}^\\ast\\) 이다.\n\\(\\boldsymbol{L}_n\\) 이 대각성분이 양수인 하삼각행렬이므로 가역행렬이다. 따라서 \\(\\boldsymbol{c}=(\\boldsymbol{L}_n)^{-1} \\boldsymbol{b}\\) 이다. 따라서 어쨋든 (그것이 양수가 아니고 복소수라고 하더라도) \\(d=\\sqrt{|a|^2-\\boldsymbol{c}^\\ast \\boldsymbol{c}}\\) 가 존재하며, \\(\\det(\\boldsymbol{A})=|\\det(\\boldsymbol{L}_n)|^2 d^2 &gt;0\\) 로부터 \\(d^2&gt;0\\) 임을 안다. 따라서 \\(d&gt;0\\) 를 얻는다. \\(\\square\\)\n\n\n\n\n\n\n\n\n\n정의 4 (숄레스키 분해) 정리 1 에 따라 Positive definite 행렬 \\(\\boldsymbol{A}\\in \\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 를 모든 대각성분이 양수인 하삼각 행렬 \\(\\boldsymbol{L}\\in \\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 에 대해 \\(\\boldsymbol{A}=\\boldsymbol{LL}^\\ast\\) 로 분해하는 것을 숄레스키 분해 (Cholesky decomposition) 라고 한다. \\(\\mathbb{F} =\\mathbb{R}\\) 인 경우 \\(\\boldsymbol{A}=\\boldsymbol{LL}^T\\) 이므로 \\(\\boldsymbol{LL}^T\\) 분해라고도 한다.\n\n\n\n\n\n\n\n구현\n\\(\\boldsymbol{A},\\,\\boldsymbol{L}\\in \\mathcal{M}_{n \\times n}(\\mathbb{F})\\) 을 생각하자. \\(\\boldsymbol{A} = \\boldsymbol{LL}^\\ast\\) 이므로,\n\\[\n\\begin{bmatrix} A_{11} & A_{12} & A_{13} & \\cdots & A_{1n} \\\\\nA_{21} & A_{22} & A_{23} & \\cdots & A_{2n}\\\\\n\\vdots & & & & \\vdots \\\\\nA_{n1} & A_{n2} & A_{n3} & \\cdots & A_{nn}\\end{bmatrix}\n= \\begin{bmatrix} L_{11} & 0 & 0 & \\cdots & 0 \\\\\nL_{21}& L_{22} & 0 & \\cdots & 0 \\\\\n\\vdots & & & & \\vdots \\\\\nL_{n1} & L_{n2} & L_{n3} & \\cdots & L_{nn} \\end{bmatrix}\n\\begin{bmatrix} L_{11} & \\overline{L_{21}} & \\overline{L_{31}} & \\cdots & \\overline{L_{n1}} \\\\\n0 & L_{22} & \\overline{L_{32}} & \\cdots & \\overline{L_{n2}}\\\\\n\\vdots & & & & \\vdots \\\\\n0 & 0 & 0 & \\cdots & \\overline{L_{nn}}\\end{bmatrix}\n\\]\n이다. 또한 \\(\\boldsymbol{L}\\) 이 하삼각행렬이므로 다음이 성립한다. \\[\nA_{ij} = \\boldsymbol{L}_{i:} (\\boldsymbol{L}^\\ast)_{:j} = \\sum_{k=1}^n L_{ik} \\overline{L_{jk}} = \\sum_{k=1}^{\\min (i, j)} L_{ik} \\overline{L_{jk}}\n\\]\n\\(A_{11}=|L_{11}|^2\\), \\(A_{i1} =  L_{i1}\\overline{L_{11}}=L_{i1}L_{11}\\) 이므로 \\(L_{11}= \\sqrt{A_{11}},\\, L_{i1} = A_{i1}/L_{11}\\) 으로 부터 \\(\\boldsymbol{L}\\) 의 1열을 얻을 수 있다. 이제 \\(\\boldsymbol{L}\\) 의 \\(j-1\\) 열까지 얻었다고 가정하자.\n\\[\n\\begin{aligned}\nA_{1, j} & = L_{11}\\overline{L_{j1}},\\\\\nA_{i, j} & = \\sum_{k=1}^{\\min (i, j)} L_{ik}\\overline{L_{jk}},\n\\end{aligned}\n\\]\n이다. \\(i\\le j\\) 인 경우,\n\\[\nA_{i, j} = L_{i1}\\overline{L_{j1}} + \\cdots + L_{ii}\\overline{L_{ji}}\n\\]\n이므로 다음을 얻는다.\n\\[\n\\begin{aligned}\n\\text{if }j \\ne i & &L_{ji} &= \\dfrac{1}{(\\overline{L_{ii}})}\\overline{A_{ij} - \\sum_{k=1}^{i-1} L_{ik}\\overline{L_{jk}}}, \\\\\n& &L_{jj} &= \\sqrt{A_{ij}- \\sum_{k=1}^{j-1} L_{jk}\\overline{L_{jk}}}\n\\end{aligned}\n\\]\n즉 \\(i\\le j\\) 일 경우 \\(L_{ji}\\) 는 \\(\\boldsymbol{L}\\) 의 \\(1\\) 열부터 \\(j-1\\) 열까지와 \\(j\\) 열의 \\(1\\) 행부터, \\(j-1\\) 행까지의 값을 이용하여 얻을 수 있다. Julia 로 구현한 것은 아래와 같다. 하지만 LinearAlgebra 모듈에 cholesky 함수로 존재하며(그래서 함수 이름을 굳이 mcholesky 로 붙였다), 앞으로 필요하다면 그것을 쓸 것이다.\n\nfunction mcholesky(A::Matrix{T}) where T&lt;:Number\n    M = size(A)[1]\n    L = zero(A)\n    L[1, 1] = sqrt(A[1, 1])\n    for i in 2:M\n        L[i, 1] = A[i, 1]/L[1, 1]\n    end\n    for j in 2:M, i in 1:j\n        if j == i \n            L[i, i] = sqrt(A[i, i] - dot(L[i, 1:i-1], L[i, 1:i-1]) )\n        else \n            L[j, i] = (A[i, j] - dot(L[j, 1:i-1], L[i, 1:i-1]))/L[i, i]\n        end\n    end\n    return L\nend\n\n\n\n\\(\\boldsymbol{LDL}^\\ast\\) 분해\n\n\n명제 5 대각성분이 모두 \\(0\\) 이 아닌 하삼각 행렬 \\(\\boldsymbol{L}\\) 은 어떤 대각행렬 \\(\\boldsymbol{\\Delta}\\) 와 대각성분이 \\(1\\) 인 하삼각 행렬 \\(\\boldsymbol{\\Lambda}\\) 에 대해 \\(\\boldsymbol{L}=\\boldsymbol{\\Lambda}\\boldsymbol{\\Delta}\\) 로 분해된다.\n\n\n\n\n(증명). \\(\\boldsymbol{\\Delta}\\) 를 \\(\\boldsymbol{L}\\) 의 대각성분만으로 이루어진 대각행렬이라고 하고 \\(\\boldsymbol{\\Lambda}\\) 를 \\(\\Lambda_{ij} = L_{ij}/\\Delta_{ii}\\) 라고 하면,\n\\[\n(\\boldsymbol{\\Lambda \\Delta})_{ij} = \\sum_{k=1}^i \\Lambda_{ik}\\Delta_{kj} = L_{ij}\n\\]\n이므로 \\(\\boldsymbol{L}=\\boldsymbol{\\Lambda \\Delta}\\) 이다. \\(\\square\\)\n\n\n우리는 positive definite 행렬이 하삼각 행렬과 그 하삼각행렬의 에르미트 conjugarte 의 곱으로 표현된다는 것을 안다(정리 1). 여기에 명제 5 를 같이 생각하면 positive definite 행렬은 어떤 대각행렬이 \\(1\\) 인 하삼각행렬 \\(\\boldsymbol{L}\\) 과 대각 행렬 \\(\\boldsymbol{D}_0\\) 에 대해\n\\[\n\\boldsymbol{A} = (\\boldsymbol{LD}_0) (\\boldsymbol{LD}_0)^\\ast = \\boldsymbol{L}(\\boldsymbol{D}_0\\boldsymbol{D}_0^\\ast) \\boldsymbol{L}^\\ast\n\\]\n이다. \\(\\boldsymbol{D}_0\\) 는 모든 성분이 양수인 대각행렬이므로 \\(\\boldsymbol{D}=(\\boldsymbol{D}_0\\boldsymbol{D}_0^\\ast)\\) 도 그러하다. 따라서 우리는 다음의 결론을 얻을 수 있다.\n\n명제 6 positive definite 행렬 \\(\\boldsymbol{A}\\) 는 어떤 대각성분이 모두 \\(1\\) 인 하삼각 행렬 \\(\\boldsymbol{L}\\) 과 대각성분이 모두 양수인 대각행렬 \\(\\boldsymbol{D}\\) 에 대해 \\(\\boldsymbol{A} = \\boldsymbol{LDL}^\\ast\\) 로 분해된다.\n\n\n\n\n크라우트 분해\n숄레스키 분해와는 유사한 분해로 크라우트 분해가 있다. 삼중대각행렬 을 하쌍대각행렬 \\(\\boldsymbol{L}\\) 과 대각성분이 모두 \\(1\\) 인 상쌍대각행렬 \\(\\boldsymbol{U}\\) 의 곱으로 분해하는 것을 크라우트 분해 (Crount decomposition) 라고 한다.",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "행렬의 분해"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/08_matrix_decomposition.html#qr-분해",
    "href": "src/numerical_analysis_using_julia/08_matrix_decomposition.html#qr-분해",
    "title": "행렬의 분해",
    "section": "3 QR 분해",
    "text": "3 QR 분해\n\n하우스홀더 행렬\n\n\n\n\n\n\n\n정의 5 (하우스홀더 행렬과 하우스홀더 변환) 벡터공간 \\(\\mathcal{M}_n(\\mathbb{C})\\) 에서의 벡터 \\(\\boldsymbol{v}\\) 에 대해 다음과 같이 정의된 \\(\\boldsymbol{H}_v\\) 를 하우스홀더 행렬 (Householder matrix) 이라 한다.\n\\[\n\\begin{aligned}\n\\boldsymbol{H}_{\\boldsymbol{v}} := I_n- \\dfrac{2\\boldsymbol{v}\\boldsymbol{v}^{\\ast}}{\\|\\boldsymbol{v}\\|^2}, \\qquad \\text{i. e. }\\quad\n(\\boldsymbol{H}_{\\boldsymbol{v}})_{ij} := \\delta_{ij} - \\dfrac{2 v_i \\overline{v_j}}{\\|\\boldsymbol{v}\\|^2}.\n\\end{aligned}\n\\tag{1}\\] 여기서 \\(\\boldsymbol{v}\\boldsymbol{v}^{\\ast}\\) 는 벡터의 내적이 아니라 \\(n\\times 1\\) 행렬 \\(\\boldsymbol{v}\\) 와 \\(1 \\times n\\) 행렬 \\(\\boldsymbol{v}^{\\ast}\\) 가 곱해진 \\(n \\times n\\) 행렬을 의미한다. 벡터 \\(\\boldsymbol{x}\\in \\mathbb{C}^n\\) 에 대해 \\(\\boldsymbol{H}_{\\boldsymbol{v}} \\boldsymbol{x}\\in \\mathbb{C}^n\\) 을 하우스홀더 변환 이라 한다. \\(\\boldsymbol{v}\\) 가 단위벡터일 경우, 즉 \\(\\|\\boldsymbol{v}\\|=1\\) 라면 좀 더 간단하게 쓸 수 있다.\n\\[\n\\boldsymbol{H}_{\\boldsymbol{v}} = I_n- 2\\boldsymbol{v}\\boldsymbol{v}^{\\ast},\\qquad \\text{where } \\|\\boldsymbol{v}\\|=1.\n\\tag{2}\\]\n\n\n\n\n\n\n\n명제 7 하우스홀더 행렬 \\(\\boldsymbol{H}_{\\boldsymbol{v}} \\in \\mathcal{M}_{n \\times n}(\\mathbb{C})\\) 은 다음의 특징을 가진다.\n  (\\(1\\)) 에르미트 행렬이다. 즉 \\(\\boldsymbol{H}_{\\boldsymbol{v}}=  \\boldsymbol{H}_{\\boldsymbol{v}}^\\ast\\).\n  (\\(2\\)) 유니타리 행렬이다. 즉 \\(\\boldsymbol{H}_{\\boldsymbol{v}} (\\boldsymbol{H}_{\\boldsymbol{v}})^\\ast = I\\).\n\n\n\n\n(증명). (\\(1\\)) \\(\\boldsymbol{v}\\) 가 단위벡터일 경우에만 보여도 된다. \\(\\boldsymbol{H} = \\boldsymbol{H}_{\\boldsymbol{v}}\\) 라 하면,\n\\[\n(\\boldsymbol{H}^\\ast)_{ij} = \\overline{H_{ji}}= \\delta_{ij}-2 \\overline{v_j \\overline{v_i}} = \\delta_{ij}-2 v_i \\overline{v_j} = (\\boldsymbol{H})_{ij}\n\\]\n이므로 \\(\\boldsymbol{H}_{\\boldsymbol{v}}\\) 는 에르미트 행렬이다.\n(\\(2\\)) 또한,\n\\[\n\\begin{aligned}\n\\left(\\boldsymbol{H} (\\boldsymbol{H}^\\ast)\\right)_{ij} &= \\left((\\boldsymbol{H})^2\\right)_{ij} = \\sum_{k}(\\delta_{ik}-2 v_i \\overline{v_k})(\\delta_{kj} -2 v_k \\overline{v_j}) \\\\\n&= \\sum_k \\delta_{ik}\\delta_{kj} - 2\\sum_k \\delta_{ik}v_k \\overline{v_j} - 2 \\sum_k \\delta_{kj} v_i \\overline{v_k} + 4 \\sum_{k} v_i \\overline{v_j} v_k \\overline{v_k} \\\\\n&= \\delta_{ij} - 2 v_i \\overline{v_{j}} - 2 v_i \\overline{v_j} + 4 v_i \\overline{v_j} = \\delta_{ij}\n\\end{aligned}\n\\]\n이다. \\(\\square\\)\n\n\n\n\n따름정리 1 실수성분의 하우스홀더 행렬 \\(\\boldsymbol{H}_{\\boldsymbol{v}} \\in \\mathcal{M}_{n \\times n}(\\mathbb{R})\\) 은 대칭행렬이며 직교행렬이다.\n\n\n\n\n\n\n하우스홀더 변환과 하우스홀더 반사\n하우스 홀더 변환이 리플렉션(reflection, 반사) 라고 불린다. 수학적으로 \\(\\mathbb{R}^n\\) 공간에서 벡터 \\(\\boldsymbol{v}\\) 만으로 \\(\\boldsymbol{v}\\) 와 수직이며 원점을 지나는 평면이 유일하게 정의될 수 있다. 임의의 벡터 \\(\\boldsymbol{x} \\in \\mathbb{F}^n\\) 에 대해,\n\\[\n\\begin{aligned}\n(\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x})_k &=  x_k - \\dfrac{2}{\\|\\boldsymbol{v}\\|^2}  \\sum_{j=1}^n v_k \\overline{v_j} x_j\\\\\n\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x} &= \\boldsymbol{x} - 2 \\dfrac{\\langle \\boldsymbol{x},\\,  \\boldsymbol{v} \\rangle \\boldsymbol{v}}{\\|\\boldsymbol{v}\\|^2}\n\\end{aligned}\n\\]\n이며, \\(\\boldsymbol{x}\\) 의 \\(\\boldsymbol{v}\\) 벡터에 대한 projection \\(\\text{Proj}_\\boldsymbol{v}\\boldsymbol{x}= \\langle \\boldsymbol{v},\\, \\boldsymbol{x}\\rangle \\boldsymbol{v}\\) 이므로,\n\\[\n\\begin{aligned}\n\\dfrac{1}{2 }(\\boldsymbol{x}+\\boldsymbol{Hx}) &= \\boldsymbol{x} - \\langle \\boldsymbol{v,\\,  x}\\rangle \\boldsymbol{v} = \\boldsymbol{x} - \\text{Proj}_{\\boldsymbol{v}} \\boldsymbol{x} \\\\\n\\boldsymbol{x}-\\boldsymbol{Hx} &= 2\\langle \\boldsymbol{v ,\\, x} \\rangle  \\boldsymbol{v} = 2\\, \\text{Proj}_{\\boldsymbol{v}}\\boldsymbol{x}\n\\end{aligned}\n\\]\n이다. 즉 \\(\\boldsymbol{x}\\) 와 \\(\\boldsymbol{Hx}\\) 는 \\(\\boldsymbol{v}\\) 에 의해 정의되는 평면에 대해 대칭이다.\n\n\n코드\n\\begin{tikzpicture}\n    \\draw [black, very thick, -&gt;](0, 0) -- (2, 2)  node[right] {$\\boldsymbol{v}$};\n    \\draw [red, very thick, -&gt;] (0, 0) -- (-2.646, 1 ) node[left] {$\\boldsymbol{H_v x}$};\n    \\draw [blue, very thick, -&gt;] (0, 0) -- (-0.646, 3 ) node[left] {$\\boldsymbol{x}$};\n    \\draw [green, dashed, thick] (1, -1) -- (-2, 2 ) node[left, black] {Plane normal to $\\boldsymbol{v}$};\n\\end{tikzpicture}\n\n\n\n\n\n\n\n그림 1: Householder 반사\n\n\n\n\n\\(\\boldsymbol{x}\\) 를 \\(\\boldsymbol{v}\\) 와 평행한 부분과 수직한 부분으로 분리하자. 즉 \\(\\boldsymbol{x}_{\\|} = \\text{Proj}_{\\boldsymbol{v}}\\boldsymbol{x}\\), \\(\\boldsymbol{x}_{\\perp} = \\boldsymbol{x}-\\text{Proj}_{\\boldsymbol{v}}\\boldsymbol{x}\\) 라 하면, \\(\\boldsymbol{x} = \\boldsymbol{x}_{\\|} + \\boldsymbol{x}_{\\perp}\\) 이며 \\(\\boldsymbol{x}\\cdot \\boldsymbol{v} = \\boldsymbol{x}_{\\|}\\cdot \\boldsymbol{v}\\) 이다.\n\\[\n\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x} = \\boldsymbol{x} - 2 \\boldsymbol{x}_{\\|} = \\boldsymbol{x}_{\\perp} - \\boldsymbol{x}_{\\|}\n\\]\n이다.\n\n\n\n하우스홀더 변환과 QR 분해\n\\(\\mathcal{M}_n (\\mathbb{F})\\) 에서의 벡터 \\(\\boldsymbol{x}\\) 과 표준 기저 \\(\\{\\hat{\\boldsymbol{e}}_1,\\ldots,\\,\\hat{\\boldsymbol{e}}_n\\}\\) 를 생각하자. \\(\\alpha\\) 를 \\(\\boldsymbol{x}\\) 의 첫번째 성분 \\(x_1 = re^{i\\theta}\\) 에 대해 다음과 같이 정의한다.\n\\[\n\\alpha = \\left\\{ \\begin{array}{ll} \\|\\boldsymbol{x}\\|_2  & \\text{where } \\mathbb{F}=\\mathbb{R}, \\\\ e^{i\\theta}\\|\\boldsymbol{x}\\|_2 \\qquad & \\text{where } \\mathbb{F} =\\mathbb{C}. \\end{array} \\right.\n\\]\n\\(\\boldsymbol{x}\\) 에 대해 \\(\\boldsymbol{v}\\) 를 다음과 같이 정하자.\n\\[\n\\boldsymbol{v} = \\boldsymbol{x} - \\alpha \\hat{\\boldsymbol{e}}_1, \\\\\n\\]\n이렇게 정해진 \\(\\boldsymbol{v}\\) 를 하우스홀더 벡터(householder vector) 라고 한다. 이 때 \\(\\boldsymbol{x}\\) 의 \\(\\boldsymbol{v}\\) 에 대한 하우스홀더 변환 \\(\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x}\\) 는 다음과 같다. (증명은 연습문제에)\n\\[\n\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x} = \\boldsymbol{x}-\\boldsymbol{v} = \\alpha \\hat{\\boldsymbol{e}}_1.\n\\tag{3}\\]\n\n식 1 에서 보듯이 \\(\\boldsymbol{v}\\) 에 스칼라곱을 해도 하우스홀더 변환은 변하지 않는다. 실제로 계산을 위해서는 주어진 \\(\\boldsymbol{v}\\) 에 대해 \\(\\overline{\\boldsymbol{v}}=\\dfrac{1}{v_1}\\boldsymbol{v}\\) 를 사용하여 변환을 하게되며 \\(\\overline{v}_1=1\\) 이 된다.\n\n\n\n정리 2 \\(\\boldsymbol{A}\\in \\mathcal{M}_{m \\times n}(\\mathbb{F})\\) 일 때 어떤 isometry \\(\\boldsymbol{Q}\\in \\mathcal{M}_{m \\times m}(\\mathbb{F})\\) 와 상삼각 행렬 \\(\\boldsymbol{R}\\in \\mathcal{M}_{m \\times n}(\\mathbb{F})\\) 에 대해 \\(\\boldsymbol{A}=\\boldsymbol{QR}\\) 이다.\n\n\n\n\n(증명). 하우스홀더 행렬은 isometry 이며 에르미트 행렬임을 생각하자. \\(n\\) 에 대한 induction 으로 증명한다.\n\\(n=1\\) 일 경우 \\(\\boldsymbol{x}=\\boldsymbol{A}\\) 라고 하면 \\(\\boldsymbol{Q} = \\boldsymbol{H}[\\boldsymbol{x}]\\) 에 대해 \\(\\boldsymbol{QA}=\\boldsymbol{R}\\) 은 2 행부터의 값이 \\(0\\) 인 \\(m \\times 1\\) 행렬이다. \\(\\boldsymbol{A}=\\boldsymbol{Q}^\\ast \\boldsymbol{R} = \\boldsymbol{QR}\\) 이므로 \\(n=1\\) 일 때 성립한다.\n이제 \\(n\\) 보다 작거나 같은 자연수에 대해 성립함을 가정하자. \\(\\boldsymbol{A}_1\\in \\mathcal{M}_{m\\times n}(\\mathbb{F})\\) 와 \\(\\boldsymbol{a}\\in \\mathcal{M}_{m\\times 1}(\\mathbb{F})\\) 에 대해 \\(\\boldsymbol{A}= \\begin{bmatrix} \\boldsymbol{A}_1 & \\boldsymbol{a} \\end{bmatrix}\\in \\mathcal{M}_{m \\times (n+1)}(\\mathbb{F})\\) 이다. Induction 의 가정에 의해 \\(\\boldsymbol{A}_1 = \\boldsymbol{Q}_1\\boldsymbol{R}_1\\) 을 만족하는 isometry \\(\\boldsymbol{Q}_1\\in \\mathcal{M}_{m \\times m}(\\mathbb{F})\\) 와 상삼각 행렬 \\(\\boldsymbol{R}_1 \\in \\mathcal{M}_{m \\times n}(\\mathbb{F})\\) 이 존재한다. \\(m &gt; n\\) 일 경우 \\(n\\) 보다 큰 \\(\\boldsymbol{R}_1\\) 의 행벡터는 모두 영벡터이다.\n\\(\\boldsymbol{a}\\) 에 대해 \\(\\boldsymbol{w} = \\boldsymbol{Q}_1^\\ast\\boldsymbol{a}\\) 라고 하자. \\(\\boldsymbol{Q}_1\\in \\mathcal{M}_{m \\times m}(\\mathbb{F})\\) 이다. \\(\\boldsymbol{w}\\) 는 첫행을 제외한 나머지 행이 \\(0\\) 인 열벡터이다. 이제 \\(\\boldsymbol{w}\\) 의 \\(1\\) 행부터 \\(n\\) 행까지를 \\(\\boldsymbol{w}_1\\), \\(n+1\\) 행부터 \\(m\\) 행 까지를 \\(\\boldsymbol{w}_2\\) 라고 하자. \\(\\boldsymbol{w}_2\\) 에 대해 \\(\\boldsymbol{w}_2 = \\boldsymbol{Q}_2 \\boldsymbol{r}_2\\) 를 만족하는 \\(\\boldsymbol{Q}_2 \\in \\mathcal{M}_{(m - n)\\times (m - n)}(\\mathbb{F})\\), \\(\\boldsymbol{r}_2\\in \\mathcal{M}_{(m-n)}(\\mathbb{F})\\) 가 존재한다.\n이제 \\(\\boldsymbol{A}_1=\\boldsymbol{Q}_1\\boldsymbol{R}_1\\) 이며 \\(\\boldsymbol{Q}_1\\) 은 \\(n \\times n\\) isomegtry 이고 \\(\\boldsymbol{R}_1\\) 은 \\(m \\times n\\) 상삼각행렬이라고 하자.\n\\[\n\\boldsymbol{Q} = \\boldsymbol{Q}_1 \\begin{bmatrix} \\boldsymbol{I}_{n} & \\boldsymbol{0} \\\\ \\boldsymbol{0} & \\boldsymbol{Q}_2\\end{bmatrix}\n\\]\n이라 하면,\n\\[\n\\boldsymbol{Q} \\left[\\begin{array}{c|c} \\boldsymbol{R}_1 & \\begin{array}{c}  \\boldsymbol{w}_1 \\\\ \\boldsymbol{r}_2 \\end{array} \\end{array}\\right]=\\boldsymbol{Q}_1 \\left[\\begin{array}{c|c} \\boldsymbol{R}_1 & \\begin{array}{c}  \\boldsymbol{w}_1 \\\\ \\boldsymbol{Qr}_2 \\end{array} \\end{array}\\right] = \\boldsymbol{A}\n\\]\n이다.\n\n\n이미 설명한 그람 슈미트 방법과 유사하게\n이제 \\(\\boldsymbol{Q}_1= \\boldsymbol{Q},\\, \\boldsymbol{A}=\\boldsymbol{A}_1\\) 이라 놓으면,\n\\[\n\\boldsymbol{Q}_1\\boldsymbol{A}_1 = \\begin{bmatrix}\\alpha _{1} & \\ast &\\cdots &\\ast \\\\0 & & &\\\\ \\vdots & & \\boldsymbol{A}_2 & \\\\ 0 & & & \\end{bmatrix}\n\\]\n꼴이 된다. 이제 행렬 \\(m \\times n\\) 행렬 \\(\\boldsymbol{A}_k\\) 가 \\(k\\) 번째 행까지는 상삼각 행렬의 모양을 따른다고 하자. 즉 \\(j\\le k\\) 이고 \\(i&gt;k\\) 이면 \\((\\boldsymbol{A}_k)_{ij}=0\\) 이라 하자. 이 때 \\(\\boldsymbol{A}_k\\) 의 \\(k\\) 번째 행부터 \\(m\\) 행, \\(k\\) 번째 열부터 \\(m\\) 열까지를 \\(\\boldsymbol{A}'_k\\) 라 하고,(julia 로 표현하면 Ak[k:end, k:end] 가 될 것이다) 이 \\(\\boldsymbol{A}'_k\\) 에 대해 앞서 \\(\\boldsymbol{A}\\) 에 했던 것과 똑같은 과정을 수행하는 하우스홀더 행렬을 \\(\\boldsymbol{Q}'_k\\) 라 하면 \\(\\boldsymbol{Q}'_k \\boldsymbol{A}'_k\\) 는 \\(\\boldsymbol{Q}_1\\boldsymbol{A}_1\\) 처럼 첫번째 열에서는 첫번째 행을 제외한 나며지 행의 값이 \\(0\\) 이 된다. 만약\n\\[\n\\boldsymbol{Q}_k = \\begin{bmatrix} \\boldsymbol{I}_{k-1} & 0 \\\\ 0 & \\boldsymbol{Q}_k'\\end{bmatrix}\n\\]\n이라 하면, \\((k-1)\\times (k-1)\\) 단위행렬 \\(I_{k-1}\\) 과 \\(\\boldsymbol{A}_k\\) 를 \\(k\\) 행 과 \\(k\\) 열 부터 잘라 \\(\\boldsymbol{A}_{k} = \\begin{bmatrix} B_{k} & C_{k} \\\\ 0 &\\boldsymbol{A}'_{k}\\end{bmatrix}\\) 로 만들자. \\(B_k\\) 는 \\((k-1) \\times (k-1)\\) 행렬이며 \\(\\boldsymbol{A}'_{k}\\) 는 \\((m-k+1)\\times (n-k+1)\\) 행렬이다. \\(\\boldsymbol{A}_k\\) 가 \\(k\\) 열까지 상삼각 행렬 모양이므로 \\(B_k\\) 아래는 \\(0\\) 행렬이다. 두 행렬의 곱은 \\[\n\\boldsymbol{Q}_k \\boldsymbol{A}_k = \\begin{bmatrix} \\boldsymbol{I}_{k-1} & 0 \\\\ 0 & \\boldsymbol{Q}_k' \\end{bmatrix} \\begin{bmatrix} B_{k} & C_{k} \\\\ 0 &\\boldsymbol{A}'_{k}\\end{bmatrix} = \\begin{bmatrix} B_k & C_k \\\\ 0 & \\boldsymbol{Q}'_k \\boldsymbol{A'}_k \\end{bmatrix}\n\\]\n이 되고 \\(\\boldsymbol{Q}'_k \\boldsymbol{A}'_k\\) 의 첫번째 열은 첫번째 행을 제외하면 모두 \\(0\\) 이므로 \\(\\boldsymbol{Q}_k \\boldsymbol{A}_k\\) 는 \\(k\\) 열까지 상삼각 행렬 꼴이 된다.\n\\(L = \\min\\{m,\\,n\\}\\) 이라 하면 \\(\\boldsymbol{Q}_L \\boldsymbol{Q}_{L-1} \\cdots \\boldsymbol{Q}_1 \\boldsymbol{A}\\) 는 상삼각행렬꼴이 된다. 이를 \\(\\boldsymbol{R}\\) 이라 하자. \\(\\boldsymbol{Q}'_k\\) 가 하우스홀더 행렬이므로\n\\[\n\\boldsymbol{Q}_k \\boldsymbol{Q}_k^\\ast = \\begin{bmatrix} \\boldsymbol{I}_{k-1} & 0 \\\\ 0 & \\boldsymbol{Q}_k'\\end{bmatrix} \\begin{bmatrix} \\boldsymbol{I}_{k-1} & 0 \\\\ 0 & (\\boldsymbol{Q}_k')^\\ast\\end{bmatrix} = \\begin{bmatrix} I_{k-1} & 0 \\\\0 & \\boldsymbol{Q}_k'\n(\\boldsymbol{Q}_k')^\\ast\\end{bmatrix} = I\n\\]\n이다. 즉 \\(\\boldsymbol{Q}_k\\) 도 직교행렬이다. \\(\\boldsymbol{Q}_k\\) 가 에르미트 행렬임은 쉽게 보일 수 있다. 이제,\n\\[\n\\boldsymbol{Q}_L \\cdots \\boldsymbol{Q}_1 \\boldsymbol{A} = \\boldsymbol{R} \\implies \\boldsymbol{A} = \\boldsymbol{Q}_1^\\ast \\cdots \\boldsymbol{Q}_L^\\ast \\boldsymbol{R}\n\\]\n임은 쉽게 보일 수 있다. 직교행렬의 곱은 직교행렬이므로 \\(\\boldsymbol{Q}_1^\\ast \\cdots \\boldsymbol{Q}_L^\\ast\\) 도 직교행렬이다. 따라서 QR 분해를 할 수 있다.",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "행렬의 분해"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/08_matrix_decomposition.html#연습문제",
    "href": "src/numerical_analysis_using_julia/08_matrix_decomposition.html#연습문제",
    "title": "행렬의 분해",
    "section": "4 연습문제",
    "text": "4 연습문제\n\n연습문제 1 위의 식 3 을 증명하라.\n\n\n(해답). \\(\\alpha \\overline{x}_1 = \\overline{\\alpha}x_1 = |x_1| \\|\\boldsymbol{x}\\|_2\\) 이며 \\(|\\alpha|^2 = \\|\\boldsymbol{x}\\|_2^2\\) 이다. \\(a=\\alpha\\overline{x}_1=\\overline{\\alpha}x_1\\) 이라 놓고 다음을 계산해 보자. \\[\n\\begin{aligned}\n\\langle \\boldsymbol{x},\\,\\boldsymbol{v}\\rangle & = \\langle \\, \\boldsymbol{x} , \\boldsymbol{x}-\\alpha \\hat{\\boldsymbol{e}}_1\\rangle = \\|\\boldsymbol{x}\\|_2^2-\\overline{\\alpha} x_1  = \\|\\boldsymbol{x}\\|_2^2 - a\\\\\n\\langle \\boldsymbol{v},\\,\\boldsymbol{v}\\rangle &= \\langle \\boldsymbol{x} -\\alpha \\boldsymbol{e}_1,\\, \\boldsymbol{x} -\\alpha \\hat{\\boldsymbol{e}}_1 \\rangle  = \\|\\boldsymbol{x}\\|^2 - \\overline{\\alpha} x_1 -\\alpha \\overline{x_1} + |\\alpha|^2 = 2(\\|\\boldsymbol{x}\\|_2^2 -a) \\\\\n&= 2 \\langle \\boldsymbol{x},\\, \\boldsymbol{v} \\rangle\n\\end{aligned}\n\\]\n이므로, (잠시 \\(\\|\\boldsymbol{x}\\|_2\\) 를 \\(\\|\\boldsymbol{x}\\|\\) 라 하자.)\n\\[\n\\boldsymbol{H}_\\boldsymbol{v} \\boldsymbol{x} = \\boldsymbol{x} - 2\\dfrac{\\langle \\boldsymbol{x},\\, \\boldsymbol{v}\\rangle}{\\|\\boldsymbol{v}\\|^2} \\boldsymbol{v} = \\boldsymbol{x}-\\boldsymbol{v} = \\alpha \\hat{\\boldsymbol{e}}_1\n\\]\n이다.",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "행렬의 분해"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/05_interpolation.html",
    "href": "src/numerical_analysis_using_julia/05_interpolation.html",
    "title": "다항식을 이용한 보간법",
    "section": "",
    "text": "이산적인 데이터 \\((x_1,\\,y_1),\\,(x_2,\\,y_2),\\ldots,\\, (x_N,\\, y_N)\\) 가 주어졌으며 \\(x_1&lt;x_2&lt;\\cdots &lt;x_N\\) 으로 정렬되어 있다고 하자. 이 때 주어진 데이터를 바탕으로 임의의 \\(x\\) 값을 추측할 경우, \\(x_1 \\le x \\le x_N\\) 의 \\(x\\) 값에 대해 추측하는 것을 보간법(interpolation) 이라 하고, \\(x&lt;x_1\\) 이거나 \\(x &gt;x_N\\) 일 경우 추축하는것을 외삽법(extrapolation) 이라 한다. 여기서는 보간법에 대해 다루기로 한다. 기본적으로 여기서 다루는 보간법은 데이터를 다항식으로 근사시키는데, 이 방법은 아래의 바이어스트라스 근사 정리(Weierstrass approximation theorem)로 정당화된다.\n\n\n\n정리 1 (바이어슈트라스 근사 정리) 함수 \\(f : X \\subset \\mathbb{R} \\to \\mathbb{R}\\) 가 \\([a,\\,b] \\subset I\\) 구간에서 연속일 때, 임의의 \\(\\varepsilon &gt; 0\\) 에 대해\n\\[\n|f(x)-P(x)|&lt;\\varepsilon,\\qquad \\forall x\\in [a,\\,b]\n\\]\n인 다항식 \\(P(x)\\) 가 항상 존재한다.\n\n\n\n이 정리에 대한 증명은 해석학(Analysis) 교과서(예를 들면, Terrence Tao의 해석학 교과서 2권) 를 참고하라.",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "다항식을 이용한 보간법"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/05_interpolation.html#바이어슈트라스-근사정리",
    "href": "src/numerical_analysis_using_julia/05_interpolation.html#바이어슈트라스-근사정리",
    "title": "다항식을 이용한 보간법",
    "section": "",
    "text": "이산적인 데이터 \\((x_1,\\,y_1),\\,(x_2,\\,y_2),\\ldots,\\, (x_N,\\, y_N)\\) 가 주어졌으며 \\(x_1&lt;x_2&lt;\\cdots &lt;x_N\\) 으로 정렬되어 있다고 하자. 이 때 주어진 데이터를 바탕으로 임의의 \\(x\\) 값을 추측할 경우, \\(x_1 \\le x \\le x_N\\) 의 \\(x\\) 값에 대해 추측하는 것을 보간법(interpolation) 이라 하고, \\(x&lt;x_1\\) 이거나 \\(x &gt;x_N\\) 일 경우 추축하는것을 외삽법(extrapolation) 이라 한다. 여기서는 보간법에 대해 다루기로 한다. 기본적으로 여기서 다루는 보간법은 데이터를 다항식으로 근사시키는데, 이 방법은 아래의 바이어스트라스 근사 정리(Weierstrass approximation theorem)로 정당화된다.\n\n\n\n정리 1 (바이어슈트라스 근사 정리) 함수 \\(f : X \\subset \\mathbb{R} \\to \\mathbb{R}\\) 가 \\([a,\\,b] \\subset I\\) 구간에서 연속일 때, 임의의 \\(\\varepsilon &gt; 0\\) 에 대해\n\\[\n|f(x)-P(x)|&lt;\\varepsilon,\\qquad \\forall x\\in [a,\\,b]\n\\]\n인 다항식 \\(P(x)\\) 가 항상 존재한다.\n\n\n\n이 정리에 대한 증명은 해석학(Analysis) 교과서(예를 들면, Terrence Tao의 해석학 교과서 2권) 를 참고하라.",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "다항식을 이용한 보간법"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/05_interpolation.html#sec-global_interpolation_using_polynomial",
    "href": "src/numerical_analysis_using_julia/05_interpolation.html#sec-global_interpolation_using_polynomial",
    "title": "다항식을 이용한 보간법",
    "section": "2 다항식을 이용한 전역적 보간법",
    "text": "2 다항식을 이용한 전역적 보간법\n전역적 보간법은 전체 데이터를 하나의 다항식으로 표현하는 방법이며, 후술할 국소적 보간법은 구하고자 하는 값 주위의 몇개의 데이터만을 이용하여 국소적으로 다항식으로 표현한다. 여기서는 \\(n+1\\) 개의 데이터 \\(\\{ (x_i,\\, y_i): i=1,\\ldots,\\,n\\}\\) 이 주어졌으며 \\(i\\ne j \\implies x_i \\ne x_j\\) 일 때, 즉 어떤 두 \\(x_i,\\,x_j\\) 도 같지 않을 경우에 대해, 이 점을 모두 지나는 \\(n-1\\) 차 다항식은 유일하게 정해진다는 사실을 이용하여 \\(n-1\\) 차 다항식을 구하는 방법을 설명한다. 이 다항식을 구하는 방법은 방데르몽드(Vandermond) 방법, 라그랑쥬(Lagrange) 방법, 뉴턴(Newton) 방법 등이 있다\n\n\n발데르몽드 방법\n다항식을 다음과 같이 놓는다. \\[\nV_{n} (x) = a_0 + a_1 x + \\cdots + a_{n-1}x^{n-1}\n\\]\n이 때 \\(V_{n} (x_i)= y_i\\) 이므로 아래와 같은 선형방정식 \\(\\boldsymbol{Va}=\\boldsymbol{y}\\) 을 통해 계수 \\(a_0,\\ldots,\\,a_{n-1}\\) 을 구할 수 있다.\n\\[\n\\underbrace{\\begin{bmatrix} 1 & x_1 & x_1^2 & \\cdots & x_1^{n-1} \\\\ 1 & x_2 & x_2^2 & \\cdots & x_2^{n-1} \\\\ \\vdots & & & & \\vdots \\\\ 1 & x_n & x_n^2 & \\cdots & x_n^{n-1}\\end{bmatrix}}_{{\\Large \\boldsymbol{V}}} \\underbrace{\\begin{bmatrix}a_0 \\\\ a_1 \\\\ \\vdots \\\\ a_{n-1}\\end{bmatrix}}_{{\\Large \\boldsymbol{a}}} = \\underbrace{ \\begin{bmatrix}y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_n\\end{bmatrix}}_{{\\Large\\boldsymbol{y}}}\n\\tag{1}\\]\n\n\n연습문제 1 위의 \\(\\boldsymbol{V}\\) 와 같이 주어진 발데르몽드 행렬의 행렬식은 다음과 같음이 잘 알려져 있다.\n\\[\n\\det(\\boldsymbol{V}) = \\prod_{1\\le i&lt;j\\le n} (x_j-x_i)\n\\]\n즉 어떤 두 \\(x_i,\\,x_j\\) 같지 않으면 행렬식은 \\(0\\) 이 아니므로 가역행렬이다.\n\n\n데이터로 부터 행렬 \\(\\boldsymbol{V}\\) 와 벡터 \\(\\boldsymbol{y}\\) 를 구할 수 있으며, 어떤 두 \\(x_i,\\,x_j\\) 도 같지 않으므로 선형방정식의 풀이를 통해 다항식의 계수 벡터 \\(\\boldsymbol{a}\\) 를 구할 수 있다.\n\n\n코드\n발데르몽드 행렬을 생성하는 가장 직관적이고 이해하기 쉬은 코드는 다음과 같다. xp 가 배열 \\(x_1,\\ldots,\\,x_n\\) 에 대한 변수라고 하자.\nV = Array{Float64}(undef, length(xp), length(xp))\n\nfor (i, x) in enumerate(xp), j in eachindex(xp)\n    V[i, j] = x^(j-1)\nend\n그러나 가장 효율적인 코드, 특히 xp 의 크기가 클 때 효율적인 코드는 array comprehension 을 사용하는 것이다.\nV = [x^(j-1) for x in xp, j in 1:length(xp)]\n이렇게 생성된 V 와 데이터로 알고 있는 \\(y_1,\\ldots,\\, y_n\\) 에 대한 배열 yp 에 대해 다항식은\nSimplePolynomial(V\\yp)\n로 구할 수 있다. 이것은 NAJ.jl 의 valdermond_polynomial 함수로 구현되었다.\nfunction valdermond_polynomial(\n    xp::AbstractVector{T1}, \n    yp::AbstractVector{T2}\n    ) where {T1&lt;:Number, T2&lt;:Number}\n    \n    N = length(xp)\n    @assert length(xp) == length(yp)\n    V = [x^(j-1) for x in xp, j in 1:length(xp)]\n    return SimplePolynomial(V\\yp)\nend\n\n\n\n\n라그랑쥬 다항식을 이용한 보간법\n가장 직관적으로 이해하기 쉬운 라그랑쥬 방법을 알아보자. \\(n\\) 개의 데이터 \\(\\{(x_i,\\,y_i):i=1,\\ldots\\, n\\}\\) 에 대해 함수 \\(l_k(x)\\) 를 다음과 같이 정의하자.\n\\[\n\\begin{aligned}\nl_k (x) &:= \\prod_{i=1,\\, i \\ne k}^n \\dfrac{(x-x_i)}{(x_k-x_i)} \\\\\n&= \\dfrac{(x-x_1)\\cdots (x-x_{k-1})(x-x_{k+1})\\cdots (x-x_n)}{(x_k-x_1)\\cdots (x_k-x_{k-1})(x_k-x_{k+1})\\cdots (x_k-x_n)}.\n\\end{aligned}\n\\tag{2}\\]\n이 다항식은 다음을 만족한다.\n\\[\nl_k (x_j) = \\delta_{xj} = \\left\\{ \\begin{array}{ll} 1 \\qquad & j=k,\\\\ 0 \\qquad &\\text{otherwise} \\end{array}\\right.\n\\]\n다항식 \\(L_n(x)\\) 를 다음과 같이 정의하자.\n\\[\nL_{n}(x) := \\sum_{k=1}^n y_k \\, l_k(x)\n\\tag{3}\\]\n그렇다면 \\(i=1,\\ldots,\\,n\\) 에 대해 \\(L_{n}(x_i)=y_i\\) 인 것은 쉽게 알 수 있다. 즉 \\(L_{n} (x)\\) 는 주어진 점들을 모두 지나는 다항식이다. 이 다항식 \\(L_{n}(x)\\) 를 라그랑쥬 다항식이라고 한다.\n\n코드\n라그랑쥬 다항식은 다음과 같이 구현 할 수 있다.\nfunction lagrange_polynomial(\n    xp::AbstractVector{T1}, \n    yp::AbstractVector{T2}) where {T1&lt;:Number, T2&lt;:Number}\n\n    N = length(xp)\n    @assert length(xp) == length(yp)\n    \n    r = SimplePolynomial([zero(T2), ])\n    for i in 1:N\n        coef = yp[i]\n        rt = one(T2)\n        for j in 1:N\n            if i ≠ j\n                @inbounds coef = coef/(xp[i]-xp[j])\n                @inbounds rt = rt*SimplePolynomial([-xp[j], 1.0])\n            end\n        end\n        r += rt*coef\n    end\n    return r\nend\n\n\n\n\n뉴턴 보간법\n뉴턴 보간법은 \\(n\\) 개의 데이터 \\(\\{ (x_i,\\, y_i): i=1,\\ldots,\\,n\\}\\) 를 지나는 \\(n-1\\) 차 다항식을 \\[\n\\begin{aligned}\nN_{n}(x) & = a_0 + a_1 (x-x_1)+ a_2 (x-x_1)(x-x_2)+ \\cdots \\\\\n& \\qquad + a_{n-1}(x-x_1)\\cdots (x-x_{n-1})\n\\end{aligned}\n\\tag{4}\\]\n으로 두고 그 계수 \\(a_0,\\,a_1,\\ldots,\\,a_{n-1}\\) 을 찾는다. 우선 \\(n_k(x)\\) 를 아래와 같이 정의하자. \\[\nn_k (x) := \\left\\{ \\begin{array}{ll} 1 & \\text{if }k=0 \\\\ \\displaystyle \\prod_{i=1}^k (x-x_i) &\\text{if }k\\ne 0\\end{array}\\right.\n\\tag{5}\\]\n이 \\(n_k(x)\\) 를 뉴턴 기저 다항식 이라 한다. 뉴턴 다항식 \\(N_n (x)\\) 는 다음과 같다.\n\\[\nN_{n}(x) = \\sum_{k=0}^{n-1} a_k n_k (x).\n\\]\n이 때 \\(N_n(x_1)=a_1= y_1\\) 이며, \\(k=1,\\ldots,\\, n-1\\) 에 대해\n\\[\na_k = \\dfrac{y_{k+1} - a_1 - a_2(x_{k+1}-x_1) - \\cdots - a_{k-1}(x_{k+1}-x_1)\\cdots (x_{k+1}-x_k)}{(x_{k+1}-x_1)\\cdots (x_{k+1}-x_k)}\n\\]\n임을 알 수 있다. 이것을 아래와 같은 선형방정식 \\(\\boldsymbol{Na}=\\boldsymbol{y}\\) 를 통해 표현 할 수 있다.\n\\[\n\\underbrace{\\begin{bmatrix} 1 & 0 & 0 & \\cdots & 0 \\\\ 1 & n_1(x_2) & 0 & \\cdots & 0 \\\\ 1 & n_1(x_3) & n_2(x_3) & \\cdots & 0 \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 1 & n_{n-1}(x_n) & \\cdots & \\cdots & n_{n-1}(x_n)  \\end{bmatrix}}\n_{{\\Large \\boldsymbol{N}}}\n\\underbrace{\\begin{bmatrix} a_0 \\\\ a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_{n-1}\\end{bmatrix}}_{{\\Large \\boldsymbol{a}}} =\n\\underbrace{\\begin{bmatrix} y_1 \\\\ y_2 \\\\ y_3 \\\\ \\vdots \\\\y_n \\end{bmatrix}}_{{\\Large \\boldsymbol{y}}}.\n\\tag{6}\\]\n뉴턴 보간법을 행렬로 표현하는 \\(\\boldsymbol{N}\\) 은 하삼각행렬로 방데르몽드 방법이나, 라그랑쥬 방법에 의한 보간법보다 그 계수를 구하는 것이 빠르고 수치해석적으로 안정적이다.\n\n\n코드\nfunction newton_polynomial(\n    xp::AbstractVector{T1}, \n    yp::AbstractVector{T2}) where {T1&lt;:Number, T2&lt;:Number}\n    n = length(xp)    \n    @assert n == length(yp)\n    T = promote_type(T1, T2)\n    N = LowerTriangular(ones(T, n, n))\n    for j in 2:n, i in j:n\n        @inbounds N[i, j] = N[i, j-1]*(xp[i] - xp[j-1]) \n    end\n    a = N\\yp\n    r = SimplePolynomial([a[1], ])\n    for i in 2:(n)\n        @inbounds r += a[i] * polynomial_from_roots(xp[1:i-1])\n    end\n    return r\n\nend\n\n\n\n세 방법의 비교\n주어진 점에 대해 보간하는 세가지 방법은 수학적으로 동등하지만 수치해석적으로는 뉴턴 방법을 권장하는데 그 이유는 다음과 같다.\n\n일반적으로 라그랑쥬 다항식보다 뉴턴 다항식을 빠르게 계산 할 수 있다.\n\\(n\\) 개의 데이터에 대해 다항식을 구한 후 데이터를 추가할 때 라그랑쥬 다항식은 모든 계수를 다시 계산해야 하지만 뉴턴 다항식은 위의 이미 알고 있는 계수와 점들을 를 이용하여 계산할 수 있다. 여기서는 새로운 점을 추가하는 것을 구현하지는 않았다.\n데이터가 어느 정도 많이 주어졌을 때 라그랑쥬 다항식보다 뉴턴 다항식이 수치해석적으로 안정하다.\n\n\n\n\n\n다항식을 이용한 보간법의 오차\n\n\n명제 1 \\(f\\in C^{n}[a,\\,b]\\) 이고 \\(\\{x_1,\\ldots,\\,x_n\\}\\subset [a,\\,b]\\) 이며 \\(i\\ne j \\implies x_i \\ne x_j\\) 라고 하자. \\(P_{n-1}(x)\\) 가 \\(P_{n-1}(x_i) = f(x_i)\\) (\\(i=1,\\ldots,\\,n\\)) 인 \\(n-1\\) 차 다항식이라면\n\\[\nf(x) - P_{n-1}(x) = \\dfrac{f^{(n)}(\\xi)}{n!} \\prod_{j=1}^n (x-x_j)\n\\]\n를 만족하는 \\(\\xi \\in [a,\\,b]\\) 가 존재한다.\n\n\n\n\n(증명). \\(F(t)\\) 를 다음과 같이 정의하자.\n\\[\nF(t) = f(t) - P_{n-1} (t) - (f(x)-P_{n-1} (x)) \\prod_{i=1}^n \\dfrac{(t-x_i)}{(x-x_i)} \\tag{1}\n\\]\n이 때 \\(t=x_k,\\, k=1,\\ldots,\\, n\\) 에 대해 \\(F(x_k)=0\\) 이다. 또한\n\\[\nF(x) = f(x)-P_{n-1}(x) - (f(x)-P_{n-1}(x)) = 0\n\\]\n이므로 \\(x,\\,x_1,\\ldots,\\,x_n\\) 의 \\(n+1\\) 개의 점에서 \\(F(t)=0\\) 이 된다. 일반화된 롤의 정리 를 이용하면 \\(n\\) 개의 점에서 \\(F'(t)=0\\) 이며, 이것을 반복하면 \\(F^{(n)}(\\xi)=0\\) 을 만족하는 \\(\\xi\\in [a,\\,b]\\) 가 존재한다. 그런데 \\(P_{n-1}(x)\\) 는 \\(n-1\\) 차 다항식이므로 \\(P_{n-1}^{(n)} (x)=0\\) 이며 (\\(1\\)) 의 \\(\\displaystyle \\prod_{i=1}^n \\dfrac{(t-x_i)}{(x-x_i)}\\) 에 대한 \\(n\\) 차 미분은\n\\[\n\\dfrac{d^n}{dt^n} \\left(\\prod_{i=1}^n \\dfrac{(t-x_i)}{(x-x_i)}\\right) = \\dfrac{n!}{\\prod_{i=1}^n (x-x_i)}\n\\]\n이므로,\n\\[\nF^{(n)}(\\xi) = f^{(n)}(\\xi) - (f(x)-P_{n-1} (x))\\dfrac{n!}{\\prod_{i=1}^n (x-x_i)} = 0\n\\]\n이다. 즉\n\\[\nf(x) = P_{n-1}(x) + \\dfrac{f^{(n)}(\\xi)}{n!}\\prod_{i=1}^n (x-x_i)\n\\]\n를 만족하는 \\(\\xi \\in [a,\\,b]\\) 가 존재한다. \\(\\square\\)\n\n\n\n\n전역적 보간법의 문제점\n데이터 갯수가 많을 경우 고차다항식으로 보간을 하게 되는데, 이 경우 다항식이 심하게 진동하는 경우가 있을 수 있다. 아래 그림의 데이터는 15개의 포인트로 가우스 분포 \\(e^{-(x-x_0)/2\\sigma^2}\\) 를 그린 것이며, 라그랑쥬나 뉴턴 방법을 통해 14차 다항식으로 보간한 결과를 같이 보여준다.\n\n\n\nOscilating behavior\n\n\n게다가 데이터 갯수가 상당히 많으면 수치적으로 불안정해 진다. 예를 들어, 25개의 데이터에 대한 가우스 분포를 다항식으로 보간하면 아래와 같이 더 이상 사용할 수 없는 결과가 발생한다.\n\n\n\nOscilating behavior2",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "다항식을 이용한 보간법"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/05_interpolation.html#sec-Neville_method",
    "href": "src/numerical_analysis_using_julia/05_interpolation.html#sec-Neville_method",
    "title": "다항식을 이용한 보간법",
    "section": "3 네빌 방법 (Neville’s Method)",
    "text": "3 네빌 방법 (Neville’s Method)\n다항식을 이용한 전역적인 보간법에서의 세 방법이 \\(\\{(x_i,\\,y_i): i=1,\\ldots,\\,n\\}\\) 를 모두 지나는 \\(n-1\\) 차 다항식을 구하는 방법이라면 네빌 방법은 다항식을 직접 구한다기 보다는 다항식으로 보간했을 때의 값만을 구하는 방법이다.\n\\(n\\) 개의 데이터 \\(\\{(x_i,\\,y_i): i=1,\\ldots,\\,n\\}\\) 가 주어졌을 때 한 다항식 \\(P_{1,\\ldots,\\,n-1}(x)\\) 는 \\(i=1,\\ldots,\\,n-1\\) 에서 데이터와 일치하며, 다른 다항식 \\(P_{2,\\ldots,\\,n}\\) 은 \\(i=2,\\ldots,\\,n\\) 에서 데이터가 일치한다고 하자. 이 때\n\\[\nP_{1,\\ldots,\\,n}(x) = \\dfrac{(x-x_1)P_{2,\\ldots,n}(x) - (x-x_n)P_{1,\\ldots,\\,n-1}(x)}{x_n-x_1}\n\\]\n은 모든 \\(i=1,\\ldots,\\,n\\) 에 대해 \\(P_{1,\\ldots,\\,n}(x_i) = y_i\\) 이다.\n4 개의 점으로 이루어진 데이터를 다항식으로 보간한다고 생각하자. 각 \\(P_i(x)\\) 는 \\(y_i\\) 의 값을 갖는 상수함수로 놓는다. \\(P_1,\\,P_2,\\,P_3,\\,P_4\\) 를 이용하여 \\(P_{1,\\,2}\\), \\(P_{2,\\,3}\\), \\(P_{3,4}\\) 를 계산하며, 이를 이용하여 \\(P_{1,2,3}\\) 와 \\(P_{2,3,4}\\) 를 계산한다. 마지막으로 이를 이용하여 \\(P_{1,2,3,4}\\) 를 계산하면 종료된다.\n\n\n\n\n\n\n\n\n\n\n회차\n1\n2\n3\n4\n\n\n\n\n\\(x_1\\)\n\\(P_1 (x)\\)\n\n\n\n\n\n\n\n\\(P_{1, 2} (x)\\)\n\n\n\n\n\\(x_2\\)\n\\(P_2 (x)\\)\n\n\\(P_{1, 2, 3} (x)\\)\n\n\n\n\n\n\\(P_{2, 3} (x)\\)\n\n\\(P_{1, 2, 3, 4} (x)\\)\n\n\n\\(x_3\\)\n\\(P_3 (x)\\)\n\n\\(P_{2, 3, 4} (x)\\)\n\n\n\n\n\n\\(P_{3, 4} (x)\\)\n\n\n\n\n\\(x_4\\)\n\\(P_4 (x)\\)\n\n\n\n\n\n\n\n\n코드\n네빌 방법에 대한 코드는 아래와 같다. Julia 의 배열 comprehension 방법을 사용하였기 때문에 한번에 이해하기 어려울 수 있다는 것에 주의하라.\nfunction neville(\n    xp::AbstractVector{T1}, \n    yp::AbstractVector{T2}, \n    x::Real) where {T1&lt;:Real, T2&lt;:Real}\n    @assert length(xp) == length(yp)\n    P = copy(yp)\n    for i in 1:(length(xp)-1)\n        P = [((x-xp[j+i])*P[j] - (x-xp[j])*P[j+1])/(xp[j]-xp[j+i]) for j in 1:(length(xp)-i)]\n    end\n    return P[1]\nend",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "다항식을 이용한 보간법"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/05_interpolation.html#sec-local_interpolation_using_polynomial",
    "href": "src/numerical_analysis_using_julia/05_interpolation.html#sec-local_interpolation_using_polynomial",
    "title": "다항식을 이용한 보간법",
    "section": "4 다항식을 이용한 구간별 보간법",
    "text": "4 다항식을 이용한 구간별 보간법\n앞서의 전역적 보간법은 주어진 전체 데이터를 이용한 보간법인데 반해 지금 소개하는 보간법은 구하고자 하는 독립변수값 근처의 소수의 점만을 이용하여 다항식으로 보간한다. 따라서 전역적 보간법에서 보이는 진동이 없으며, 데이터가 많더라도 사용 할 수 있다.\n\n\n최근접 보간법 (Nearest Neighbor Interpolation)\n가장 간단한 보간법 은 최근접 보간법 (nearest neighbor interpolation) 으로 \\(x_1,\\ldots,\\,x_N\\) 가운데 \\(x\\) 값에 가장 가까운 값을 취하는 방법이다. 즉 \\(x_i\\le x&lt;x_{i+1}\\) 일 때 \\(x_i\\) 와 \\(x_{i+1}\\) 중 \\(x\\) 와의 거리가 더 가까운 값을 \\(f(x)\\) 로 선택하는 방법이다. 가장 단순하면서도 빠르지만 보간법의 결과로 나온 함수는 연속함수가 아니다.\n\n\n\n선형 보간법 (Linear Interpolation)\n\\(x_{i}\\le x &lt; x_{i+1}\\) 일 때 \\((x_i,\\,y_i)\\) 와 \\((x_{i+1},\\, y_{i+1})\\) 의 두 점을 지나는 직선 \\(l_i (x)\\) 는 다음과 같다.\n\\[\nl_i (x) = \\dfrac{y_{i+1}-y_i}{x_{+1}-x_i} (x-x_i) + y_i\n\\tag{7}\\]\n이 직선 \\(l_i(x)\\) 값으로 \\(f(x)\\) 값을 추산하는 것을 선형보간법이라 한다. 선형 보간법으로 구한 함수는 연속이지만 일반적으로 미분가능하지 않다.\n\n\n\n삼차함수 보간법 (Cubic interpolation)\n\\(x_{i}\\le x&lt; x_{i+1}\\) 일 때 \\((x_{i-1},\\, y_{i-1})\\), \\((x_i,\\,y_{i})\\), \\((x_{i+1},\\,y_{i+1})\\), \\((x_{i+2},\\, y_{i+2})\\) 를 이용하여 3차함수를 구하여 보간한다. 보간하는 함수는 앞서 언급한 발데르몽드, 라그랑쥬, 뉴턴 방식중에 사용할 수 있으며, 여기서는 뉴턴 다항식을 이용하여 보간하도록 한다. \\((x_{i-1},\\, y_{i-1})\\), \\((x_i,\\,y_{i})\\), \\((x_{i+1},\\,y_{i+1})\\), \\((x_{i+2},\\, y_{i+2})\\) 를 이용하여 구한 3차 다항식을 \\(N_i(x)\\) 라고 하면 \\(x_1\\le x&lt;x_2\\) 일 경우에는 \\(x_0\\) 가 없으므로 \\(N_1(x)\\) 를 이용하며, \\(x_{N-1}\\le x \\le x_{N}\\) 일 경우에는 \\(N_{N-2}\\) 를 이용하여 보간한다. 삼차함수 보간법을 사용하여 구한 함수는 연속이며 선형 보간법보다 나은 결과를 보여주지만 역시 미분 가능하지 않다.\n일단 위의 세가지를 julia 로 구현해 보자. \\(x_1,\\ldots,\\,x_n\\) 과 \\(y_1,\\ldots,\\,y_n\\) 이 각각 벡터 xp, yp 라고 하고 \\(x_1 &lt; x_2 &lt; \\cdots &lt; x_n\\) 임을 가정하자.\n\"\"\"\n    nearest neighbor interpolation\n\"\"\"\nfunction interp_nearest(\n    xp::AbstractVector{T}, \n    yp::Vector{S}, \n    x::AbstractVector{R}\n    ) where {T&lt;:Real, S&lt;:Real, R&lt;:Real}\n    \n    @assert length(xp) == length(yp)\n    N = length(xp)\n    result = zeros(x)\n    for (i, v) in enumerate(x)\n        if v&lt;xp[1] || v&gt;xp[end]\n            result[i] = zero(T)\n        else \n            ind = findfirst(xs-&gt;(xs&gt;=v), xp)-1\n            if ind == 0\n                result[i]=yp[1]\n            elseif v-xp[ind] &gt; xp[ind+1]-v\n                result[i] = yp[ind+1]\n            else \n                result[i] = yp[ind]\n            end\n        end\n    end\n    return result\nend\n\n\"\"\"\n    linear interpolation\n\"\"\"\nfunction interp_linear(xp::AbstractVector{T}, yp::Vector{S}, x::AbstractVector{R}) where {T&lt;:Real, S&lt;:Real, R&lt;:Real}\n    @assert length(xp) == length(yp)\n    N = length(xp)\n    result = zero(x)\n    for (i, v) in enumerate(x)\n        if v&lt;xp[1] || v&gt;xp[end]\n            result[i] = zero(T)\n        else \n            ind = findfirst(xs-&gt;(xs&gt;=v), xp)-1\n            if ind == 0\n                result[i] = yp[1]\n            else\n                result[i] = (yp[ind+1]-yp[ind])/(xp[ind+1]-xp[ind])*(v-xp[ind]) + yp[ind]\n            end\n        end\n    end\n    return result\nend\n\n\"\"\"\n    cubic interpolation\n\"\"\"\nfunction interp_cubic(xp::AbstractVector{T}, yp::Vector{S}, x::AbstractVector{R}) where {T&lt;:Real, S&lt;:Real, R&lt;:Real}\n    @assert length(xp) == length(yp)\n    N = length(xp)\n    result = zero(x)\n    for (i, v) in enumerate(x)\n        \n        if v&lt;xp[1] || v&gt;xp[end]\n            result[i] = zero(T)\n        else \n            ind = findfirst(xs-&gt;(xs&gt;=v), xp)-1\n            if ind ∈ (0, 1)\n                xs, ys = xp[1:4], yp[1:4]\n            elseif ind ∈ (N, N-1)\n                xs, ys = xp[end-3:end], yp[end-3:end]\n            else \n                xs, ys = xp[ind-1:ind+2], yp[ind-1:ind+2]\n            end\n            result[i] = newton_polynomial(xp, yp)(v)\n        end\n    end\n    return result\nend\n\n이것을 다음 코드로 확인해 보았다.\nusing Plots\nxp = 0.0:1.0:15.0 \nyp = cos.(xp) .* exp.(-xp/10.0)\nxt = collect(0.0:0.1:15.0) \nscatter(xp, yp, label = L\"\\cos \\theta\", dpi=300)\nplot!(xt, interp_nearest(xp, yp, xt), lw=2, lc=:red, label=L\"\\mathrm{Nearest}\")\nplot!(xt, interp_linear(xp, yp, xt), lw=2, lc=:blue, label=L\"\\mathrm{Linear}\")\nplot!(xt, interp_cubic(xp, yp, xt), lw=2, lc=:green, label=L\"\\mathrm{Cubic}\")\n\n\n\n\nInterpolation\n\n\n\n\n\nCubic Spline Interpolation\n위에서 설명한 세가지 보간법은 연속이 아니거나 미분 가능하지 않았다. Spline 보간법은 보간하고자 하는 구간 내에서 미분가능한 함수를 구해준다.\n\\(n\\) 개의 데이터 \\(\\{(x_i,\\,y_i): i=1,\\ldots,\\,n\\}\\) 에 대해 \\([x_i,\\,x_{i+1}]\\) 구간을 보간하는 다항식을 \\(s_i(x)\\) 라 하자. 이 때 각각의 \\(s_i(x)\\) 를 3차 다항식으로 하고\n\\[\n\\begin{aligned}\ns_i(x_{i}) & = y_{i}\\\\\ns_i(x_{i+1}) &= y_{i+1}\\\\\ns'_i(x_{i+1}) &= s'_{i+1}(x_{i+1}) \\\\\ns''_i(x_{i+1}) &= s''_{i+1}(x_{i+1})\n\\end{aligned}\n\\tag{8}\\] 을 만족하도록 보간하는 것을 cubic spline interpolation 이라 한다. \\([x_i,\\,x_{i+1}]\\) 구간에서의 삼차함수 \\(s_i(x)\\) 를 \\[\ns_{i}(x) = a_i + b_i x + c_ix^2 + d_i x^3\n\\]\n이라 하자. \\(s_i(x)\\) 에 대한 일계 도함수와 이계 도함수는\n\\[\n\\begin{aligned}\ns'_i (x) &= b_i + 2c_i x + 3d_i x^2,\\\\\ns''_{i}(x) &= 2c_i + 6d_ix\n\\end{aligned}\n\\]\n이므로, \\(a_{i-1},\\,b_{i-1},\\, c_{i-1},\\, d_{i-1}\\) 로부터\n\\[\n\\begin{array}{c}\na_i + b_i x_{i}+ c_i(x_{i})^2+ d_{i} (x_{i})^3 = y_{i} \\\\\na_i + b_i x_{i+1}+ c_i(x_{i+1})^2+ d_{i} (x_{i+1})^3 = y_{i+1} \\\\\nb_i + 2c_i (x_{i+1})+ 3d_i (x_{i+1})^2 =b_{i+1} + 2c_{i+1} (x_{i+1})+ 3d_{i+1} (x_{i+1})^2 \\\\\n2c_i + 6d_ix_{i+1} = 2c_{i+1}+ 6d_{i+1}x_{i+1}\n\\end{array}\n\\tag{9}\\]\n의 조건을 얻었으며, 이를 통해 \\(a_i,\\,b_i,\\,c_i,\\,d_i\\) 를 구할 수 있다. 위 식에서 아래의 두 식은 \\(i=1\\) 일 때 사용 할 수 없으므로 우리는 추가로 조건을 두어야 한다. 이 때 보통 아래와 같은 2가지의 경계조건 가운데 선택한다.\n\nFree or natural boundary: \\(s''_1 (x_1) = s''_{n-1} (x_n) = 0\\)\nClamped boundary: \\(s'_1(x_1) = f'(x_0),\\, s'_{n-1} (x_n) = f'(x_n)\\)\n\nClampled boundary 일 경우 \\(f'(x_0),\\, f'(x_n)\\) 값은 주어져야 한다.\n\n\\(n-1\\) 개의 구간에 대해 각각 4 개의 변수를 결정해야 하므로 미지수 행렬을 \\(4(n-1)\\times 1\\) 행렬 \\(\\boldsymbol{a}\\) 으로 두자. \\(j=1,\\ldots,\\,n-1\\) 에 대해\n\\[\na_{4j-3} = a_j, \\, a_{4j-2} = b_j, \\, a_{4j-1} = c_j,\\, a_{4j} = d_j\n\\]\n라고 하면 미지수 전체에 대한 행렬이다. 이제 주어진 데이터와 미지수와의 관계를 이용하여 선형방정식 \\(\\boldsymbol{Ma}=\\boldsymbol{b}\\) 를 만들자. 이 때 \\(\\boldsymbol{M}\\) 은 \\(4(n-1) \\times 4(n-1)\\) 행렬이다. \\(j=1,\\ldots,\\, n-1\\) 에 대해 \\(\\boldsymbol{M}\\) 의 \\(4(j-1)+1\\) 행부터 \\(4(j-1)+4\\) 행까지, \\(4(j-1)+1\\) 열부터 \\(4(j-1)+8\\) 열까지의 \\(4 \\times 8\\) 부분행렬을 \\(\\boldsymbol{M}_j\\) 라고 하자. 위의 조건 식 9 으로부터 \\(\\boldsymbol{M}_j\\) 가 포함하지 않는 성분은 모두 \\(0\\) 임을 알 수 있다. \\(i=1,\\ldots, n-2\\) 에 대해 \\(\\boldsymbol{M}_i\\) 는 다음과 같다. \\[\n\\boldsymbol{M}_j = \\begin{bmatrix}\n1 & x_i & (x_i)^2 & (x_i)^3 & 0 & 0 & 0 & 0\\\\\n1 & x_{i+1} & (x_{i+1})^2 & (x_{i+1})^3 & 0 & 0 & 0 & 0\\\\\n0 & 1 & 2x_{i+1} & 3(x_{i+1})^2 & 0 & -1 & -2 x_{i+1} & -3(x_{i+1})^3\\\\\n0 & 0 & 2 & 6x_{i+1} & 0 & 0 & -2 & -6x_{i+1}\n\\end{bmatrix}\n\\]\n\\(x_{n+1}\\) 은 주어져 있지 않으므로 \\(\\boldsymbol{M}_{n-1}\\) 은 \\(2 \\times 8\\) 행렬이며 다음과 같다.\n\\[\\boldsymbol{M}_{n-1} = \\begin{bmatrix}\n1 & x_{n-1} & (x_{n-1})^2 & (x_{n-1})^3 & 0 & 0 & 0 & 0\\\\\n1 & x_{n} & (x_{n})^2 & (x_{n})^3 & 0 & 0 & 0 & 0\\\\\n\\end{bmatrix}\n\\]\n또한 역시 식 9 로 부터 \\(4(n-1)\\times 1\\) 행렬 \\(\\boldsymbol{y}\\) 는 \\(i=1,\\ldots,\\,n\\) 에 대해 다음과 같이 정할 수 있다.\n\\[\nb_{4j-3}= y_i, \\, b_{4j-2}= y_{i+1},\\, b_{4j-1} = 0,\\, b_{4j}= 0\n\\]\n이제 \\(\\boldsymbol{M}\\) 의 마지막 두 행을 경계조건에 따라 정해야 한다.\n\n\nFree boundary\n우선 첫번째 경계조건이 주어졌을 경우 \\[\n\\begin{aligned}\ns''_1 (x_1)=0 &\\implies 2c_1+ 6 d_1 (x_1)=0, \\\\\ns''_{n-1}(x_n) = 0 &\\implies 2c_{n-1} + 6d_{n-1}(x_n) = 0\n\\end{aligned}\n\\]\n를 얻는다. 이 조건으로부터,\n\\[\nM_{4n-5, 3}=2,\\, M_{4n-5, 4}= 6x_1,\\, M_{4n-4, 4n-5} = 2,\\, M_{4n-4, 4n-4} = 6x_n\n\\]\n을 얻는다.\n\n\n\nClamped boundary\n\\[\n\\begin{aligned}\ns'_1 (x_1)=f'(x_0) &\\implies b_1 + 2c_1(x_1)+ 3d_1 (x_1)^2=f'(x_0), \\\\\ns'_{n-1}(x_n) = f'(x_n) &\\implies b_{n-1}+ 2c_{n-1}(x_n) + 3d_{n-1}(x_n)^2 = f'(x_n)\n\\end{aligned}\n\\]\n를 얻는다. 이 조건으로부터,\n\\[\n\\begin{aligned}\nM_{4n-5, 2}=1,\\, M_{4n-5, 3}=2x_1,\\, M_{4n-5, 4} = 3(x_1)^2,\\, b_{4n-5}=f'(x_0), \\\\\nM_{4n-4, 4n-6}=1,\\, M_{4n-4, 4n-5}=2x_n,\\, M_{4n-4,4n-4}=3(x_n)^2,\\, b_{4n-4}=f'(x_n)\n\\end{aligned}\n\\]\n을 얻는다.\n\n이제 행렬 \\(\\boldsymbol{M}\\) 과 벡터 \\(\\boldsymbol{b}\\) 를 얻었으므로 \\(\\boldsymbol{Ma}=\\boldsymbol{b}\\) 를 만족하는 \\(\\boldsymbol{a}\\) 를 구할 수 있다. \\(\\boldsymbol{a}\\) 는 이 보간법의 각 구간에서의 3차 다항식의 계수를 결정하기 때문에 우리는 보간법을 사용하여 정해진 구간 내의 모든 값을 계산 할 수 있다.\n여기에 사용된 모든 보간법은 interpolation.jl 에 Interpolation1D 객체로 구현되었다.\nusing Plots, LaTeXStrings, LinearAlgebra, Plots, SparseArrays, Printf\ninclude(\"../lib/interpolation.jl\")\n\nxp = 0.0:0.75:15.0 # change step to vector\nyp = cos.(3 .* xp) .* exp.(-xp/10.0)\nyp[8:9]=[-0.15 -0.3]# \nxt = 0.0:0.05:15.0 # change step to vector\n\ninterp1=Interpolator1D(xp, yp, :cubic)\ninterp2=Interpolator1D(xp, yp, :cubic_spline_naturalbc)\ninterp3=Interpolator1D(xp, yp, :cubic_spline_clampedbc, [0.0, 0.0])\n\nscatter(xp, yp, label = L\"\\mathrm{Data}\", dpi=300)\nplot!(xt, interp1.(xt), lw=2, lc=:green, label=L\"\\mathrm{Cubic}\")\nplot!(xt, interp2.(xt), lw=2, lc=:red, ls = :dash, label=L\"\\mathrm{Cubic\\;Spline\\;with\\;natural\\;BC}\")\nplot!(xt, interp3.(xt), lw=2, lc=:blue, ls = :dot, label=L\"\\mathrm{Cubic\\;Spline\\;with\\;clamped\\;BC}\")\n이 결과로 다음의 그래프를 얻었다.\n\n\n\nCubic Spline Interpolation",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "다항식을 이용한 보간법"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/03_linear_system.html",
    "href": "src/numerical_analysis_using_julia/03_linear_system.html",
    "title": "수치해석 입문 : 선형시스템과 다항식",
    "section": "",
    "text": "이번 장에서는 본격적인 수치해석에 들어가기에 앞서 선형 시스템을 코딩을 통해 푸는 방법, 코딩에서 이루어지는 계산의 성능 분석과 다항식에 관한 객체를 만들어본다. 수학적 내용을 코드로 만들어 보고 이를 이용하여 문제를 풀어 보면서 선형대수학과 julia 언어에 대한 지식을 습득하게 된다. 그리고 다항식에 대한 객체는 이후 계속 사용하게 될 것이다.",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "수치해석 입문 : 선형시스템과 다항식"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/03_linear_system.html#선형-시스템과-선형-방정식",
    "href": "src/numerical_analysis_using_julia/03_linear_system.html#선형-시스템과-선형-방정식",
    "title": "수치해석 입문 : 선형시스템과 다항식",
    "section": "1 선형 시스템과 선형 방정식",
    "text": "1 선형 시스템과 선형 방정식\n어떤 시스템이 \\(n\\) 개의 독립변수 \\(x_1,\\ldots,\\,x_n\\) 에 대해 아래와 같은 방정식으로 기술될 때 이 시스템을 선형 시스템이라고 한다. \\[\n\\begin{aligned}\nf_1 (x_1,\\ldots,\\,x_n ) &= A_{11}x_1 + \\cdots + A_{1n}x_n \\\\\n& \\vdots \\\\\nf_m (x_1,\\ldots,\\,x_n ) &= A_{m1}x_1 + \\cdots + A_{mn}x_n \\\\\n\\end{aligned}\n\\]\n이 시스템은 \\(m \\times n\\) 행렬 \\(\\boldsymbol{A}\\) 와 \\(n \\times 1\\) 행렬 \\(\\boldsymbol{x}\\) 를 이용해 다음과 같은 식으로 정리 할 수 있다.\n\\[\nf_i(\\boldsymbol{x})=\\boldsymbol{Ax},\\qquad \\boldsymbol{A} = \\begin{bmatrix} A_{11} & \\cdots & A_{1n} \\\\ \\vdots & \\ddots & \\vdots \\\\ A_{m1} & \\cdots &A_{mn} \\end{bmatrix},\\qquad \\boldsymbol{x} = \\begin{bmatrix} x_1 \\\\ \\vdots \\\\ x_n \\end{bmatrix}\n\\]\n이 시스템이 선형시스템이라고 불리는 이유는 \\(\\boldsymbol{x}_1,\\,\\boldsymbol{x}_2 \\in \\mathcal{M}_n(\\mathbb{F})\\) 이며 \\(a\\) 가 상수 일 때,\n\\[\nf_i(\\boldsymbol{x}_1 + a \\boldsymbol{x}_2) = f_i(\\boldsymbol{x}_1) + af_i(\\boldsymbol{x}_2) = \\boldsymbol{Ax}_1 + a\\boldsymbol{Ax}_2\n\\]\n를 만족하기 때문이다.\n주어진 \\(m \\times n\\) 행렬 \\(\\boldsymbol{A}\\) 에 대해 \\(\\boldsymbol{A}\\) 의 커널 \\(\\ker (\\boldsymbol{A})\\) 와 이미지 \\(\\text{im}(\\boldsymbol{A})\\) 를 다음과 같이 정의한다.\n\\[\n\\begin{aligned}\n\\ker (\\boldsymbol{A}) &:= \\left\\{\\boldsymbol{x}\\in \\mathcal{M}_n(\\mathbb{F}) : \\boldsymbol{Ax}=\\boldsymbol{0} \\right\\}, \\\\\n\\text{im}(\\boldsymbol{A}) &:= \\left\\{\\boldsymbol{Ax}: \\boldsymbol{x} \\in \\mathcal{M}_n(\\mathbb{F})\\right\\}\n\\end{aligned}\n\\]\n만약 \\(\\boldsymbol{b}\\in \\text{im}(\\boldsymbol{A})\\) 라면 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 를 만족하는 \\(\\boldsymbol{x}\\) 가 존재하며 이 \\(\\boldsymbol{x}\\) 를 선형방정식 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 의 해(solution) 라고 한다. \\(\\boldsymbol{x}_0 \\in \\ker (\\boldsymbol{A})\\) 라면 \\(\\boldsymbol{A}(\\boldsymbol{x}+\\boldsymbol{x}_0) = \\boldsymbol{Ax}\\) 이다.\n\\(\\boldsymbol{A}\\) 가 \\(n \\times n\\) 정사각 행렬이며 \\(\\det (\\boldsymbol{A}) \\ne 0\\) 이면, 즉 \\(\\boldsymbol{A}\\) 의 역행렬이 존재한다면 선형방정식의 해는 유일하게 존재하며 \\(\\boldsymbol{x}=\\boldsymbol{A}^{-1}\\boldsymbol{b}\\) 를 통해 구할 수 있다. 역행렬이 존재하지 않는 정사각 행렬을 특이 행렬 (singular matrix) 라고 한다. \\(\\boldsymbol{A}\\) 가 특이행렬이라면 선형방정식의 해는 존재하지 않거나, 그 해가 무수히 많이 존재한다. 예를 들어\n\\[\n\\boldsymbol{A}=\\begin{bmatrix} 1 & 1 \\\\ 0 & 0 \\end{bmatrix}, \\qquad \\boldsymbol{b}=\\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}\n\\]\n의 해는 \\(\\begin{bmatrix} x \\\\ 1-x\\end{bmatrix},\\, x\\in \\mathbb{F}\\) 인 모든 행렬이다.\n\n\n\n\n\n\n\n노트\n\n\n\n다음부터 소개할 여러가지 방법은 LinearAlgebra 모듈에 그 기능이 거의 포함되어 있기으며 아마 직접 코딩하는 것보다 처리속도가 더 빠를 것이다. 그러나 우리가 배워야 할 것은 모듈과 함수의 사용법 뿐만 아니라, 생각하는 알고리즘을 코드로 만들어 정확하게 구현하는 것이기에 앞으로 나올 여려 방법들을 직접 구현해보고자 한다.",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "수치해석 입문 : 선형시스템과 다항식"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/03_linear_system.html#상삼각-행렬과-하삼각-행렬과-선형방정식",
    "href": "src/numerical_analysis_using_julia/03_linear_system.html#상삼각-행렬과-하삼각-행렬과-선형방정식",
    "title": "수치해석 입문 : 선형시스템과 다항식",
    "section": "2 상삼각 행렬과 하삼각 행렬과 선형방정식",
    "text": "2 상삼각 행렬과 하삼각 행렬과 선형방정식\n선형 시스템 가운데 비교적 단순한 상삼각 행렬과 하삼각 행렬에 대해 알아보자. 상삼각 행렬이나 하삼각 행렬의 선형방정식은 단순하지만 복잡한 선형 시스템을 푸는 기반이 된다. 이에 관련된 것은 LU 분해 에서 다루기로 한다\n\\(n\\times n\\) 정사각 행렬에 대해 상삼각 행렬(upper triangular matrix)은 (대각성분을 포함하지 않은) 대각 성분의 아랫부분이 모두 \\(0\\) 인 행렬을 말한다, 하삼각 행렬(lower triangular matrix)은 대각성분의 윗부분이 모두 \\(0\\) 인 행렬을 말한다. 예를 들어 \\[\n\\boldsymbol{U}=\\left[\\begin{array}{rrr} 1 & 3 & 4 \\\\ 0 & 2 & 1 \\\\ 0 & 0 & -1\\end{array}\\right], \\qquad \\boldsymbol{L}=\\left[\\begin{array}{rrr} 4 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ -1 & 0 & -3\\end{array} \\right]\n\\]\n에서 \\(\\boldsymbol{U}\\) 는 상삼각행렬, \\(\\boldsymbol{L}\\) 은 하삼각행렬이다. 두 삼각행렬에 대해 다음이 성립한다.\n\n명제 1 행렬 \\(\\boldsymbol{A} \\in\\mathcal{M}_{n\\times n}(\\mathbb{F})\\) 가 상삼각 행렬 혹은 하삼각 행렬일 때 다음은 동치이다.\n\n\\(\\det (\\boldsymbol{A}) = \\prod_{i=1}^n A_{ii} \\ne 0\\)\n\\(\\boldsymbol{A}\\) 는 가역행렬이다.\n\\(\\boldsymbol{b}\\in\\mathcal{M}_n(\\mathbb{F})\\) 에 대해 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 를 만족하는 \\(\\boldsymbol{x}\\) 가 유일하게 정해진다.\n\n\n\n\n하삼각 행렬에서의 선형방정식의 풀이\n\\(\\boldsymbol{L}\\in \\mathcal{M}_{n\\times n}(\\mathbb{F})\\) 과 \\(\\boldsymbol{b}\\in \\mathcal{M}_n(\\mathbb{F})\\) 에 대해 \\(\\boldsymbol{Lx}=\\boldsymbol{b}\\) 를 만족하는 \\(\\boldsymbol{x}\\in \\mathcal{M}_n(\\mathbb{F})\\) 을 구해보자.\n\\[\n\\begin{bmatrix} L_{11} & & & \\\\ L_{21} & L_{22}  & & \\\\ \\vdots & & \\ddots & \\\\ L_{n1} & L_{n2} & \\cdots & L_{nn} \\end{bmatrix} \\begin{bmatrix} x_1\\\\ x_2 \\\\ \\vdots \\\\x_n \\end{bmatrix} = \\begin{bmatrix} b_1 \\\\ b_2 \\\\ \\vdots \\\\ b_n \\end{bmatrix}\n\\]\n에 대해,\n\\[\n\\begin{aligned}\nL_{11} x_1 &= b_1, \\\\\nL_{21} x_1 + L_{22} x_2 &= b_2, \\\\\n\\vdots \\\\\nL_{k1} x_k + L_{k2}x_2 + \\cdots + L_{kk}x_k &= b_k,\\\\\n\\vdots \\\\\nL_{n1}x_1 + L_{n2}x_2 + \\cdots + L_{nn}x_n &= b_n\n\\end{aligned}\n\\] 를 얻는다. 첫번째 식으로부터 \\(x_1\\) 을 구할 수 있으며, 두번째 식에서는 이미 구한 \\(x_1\\) 을 이용하여 \\(x_2\\) 를 구할 수 있다. 즉 \\(x_1,\\ldots,\\,x_k\\) 까지 구했다면 이미 알고 있는 \\(\\boldsymbol{L}\\) 과 \\(\\boldsymbol{b}\\) 의 성분을 이용하여 \\(x_{k+1}\\) 을 구할 수 있다. 이를 정리하면 다음과 같다. \\[\n\\begin{aligned}\nx_1 &= \\dfrac{b_1}{L_{11}}, \\\\\nx_k &= \\dfrac{1}{L_{kk}} \\left( b_k - \\sum_{i=1}^{k-1} L_{ki}x_{i}\\right),\\,k=2,\\ldots,\\,n\n\\end{aligned}\n\\]\n\n\n\n상삼각 행렬의 선형방정식의 풀이\n상삼각 행렬 \\(\\boldsymbol{U}\\in \\mathcal{M}_{n\\times n}(\\mathbb{F})\\) 와 \\(\\boldsymbol{b}\\in\\mathcal{M}_n(\\mathbb{F})\\) 에 대해 \\(\\boldsymbol{Ux}=\\boldsymbol{b}\\) 를 만족하는 \\(\\boldsymbol{x}\\in \\mathcal{M}_n(\\mathbb{F})\\) 을 구해보자.\n\\[\n\\begin{bmatrix} U_{11} & U_{12} &\\cdots & U_{11} \\\\  & U_{22}  &\\cdots  & U_{21} \\\\  & & \\ddots & \\vdots\\\\  & &  & U_{nn} \\end{bmatrix} \\begin{bmatrix} x_1\\\\ x_2 \\\\ \\vdots \\\\x_n \\end{bmatrix} = \\begin{bmatrix} b_1 \\\\ b_2 \\\\ \\vdots \\\\ b_n \\end{bmatrix}\n\\]\n에 대해,\n\\[\n\\begin{aligned}\nU_{nn} x_n &= b_n, \\\\\nU_{n-1,n-1} x_{n-1} + U_{n-1,n} x_n &= b_{n-1}, \\\\\n\\vdots \\\\\nU_{kk} x_k + U_{k,k+1}x_{k+1} + \\cdots + U_{kn}x_n &= b_k,\\\\\n\\vdots \\\\\nU_{11}x_1 + U_{12}x_2 + \\cdots + U_{1n}x_1 &= b_1\n\\end{aligned}\n\\] 를 얻는다. 첫번째 식으로부터 \\(x_n\\) 을 구할 수 있으며, 두번째 식에서는 이미 구한 \\(x_{n}\\) 을 이용하여 \\(x_{n-1}\\) 를 구할 수 있다. 즉 \\(x_{n},\\ldots,\\,x_{k}\\) 까지 구했다면 이미 알고 있는 \\(\\boldsymbol{L}\\) 과 \\(\\boldsymbol{b}\\) 의 성분을 이용하여 \\(x_{k-1}\\) 을 구할 수 있다. 이를 정리하면 다음과 같다. \\[\n\\begin{aligned}\nx_n &= \\dfrac{b_n}{U_{nn}}, \\\\\nx_k &= \\dfrac{1}{U_{kk}} \\left( b_k - \\sum_{i=k+1}^{n} U_{ki}x_{i}\\right),\\,k=n-1,\\,n-2,\\ldots,\\,1\n\\end{aligned}\n\\]\n임을 안다.\n\n\n\n코드 분석\nJulia 의 장점중의 하나는 알고리즘을 코드로 구현 했을 때 코드에서 알고리즘을 명확히 표현할 수 있다는 것이다. 또한 Julia 의 코드 실행 속도가 빠르기 때문에 많은 경우 알고리즘을 그대로 코드화 한 경우라도 상당한 속도를 낸다는 것이다.\n상삼각행렬에 대해서는 Us(), 하삼각행렬에 대해서는 Ls() 함수로 구현하였다.\n\"\"\"\n    Ls(A, b)\n\n하삼각행렬 A 에 대해 Ax=b 의 해 x 를 구한다.\n\"\"\"\nfunction Ls(L::Matrix, b::Vector) \n    m, n = size(L)        \n    x = zeros(n)\n    x[1] = b[1]/L[1, 1]\n    for i in 2:n\n        x[i] = b[i]\n        for j in 1:1:(i-1)\n            x[i] -= L[i, j]*x[j]\n        end\n        x[i] = x[i]/L[i, i]\n    end\n    return x\nend\n\n\"\"\"\n    Us(A, b)\n\n상삼각행렬 A 에 대해 Ax=b 의 해 x 를 구한다.\n\"\"\"\nfunction Us(U::Matrix, b::Vector) \n    m, n = size(U)       \n    x = zeros(n)\n    x[n] = b[n]/U[n, n]\n\n    for i in (n-1):-1:1\n        x[i] = b[i]\n        for j in (i+1):1:n\n            x[i] -= U[i, j] * x[j]\n        end\n        x[i] = x[i]/U[i, i]\n    end\n    return x\nend\nsize(L) 은 인자로 주어지는 배열(Array) L 의 차원을 튜플(tuple) 로 반환한다.\n\n이제 \\(\\boldsymbol{L}=\\begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 2 & 2 & 0 & 0 \\\\3 & 1 & -3 & 0 \\\\5 & -2 & 3 & 7 \\end{bmatrix}\\) 와 \\(\\boldsymbol{b}= \\begin{bmatrix} 3.1 \\\\  5.3 \\\\ -2.2 \\\\ 6.0 \\end{bmatrix}\\) 에 대해 풀어보면\nL = [1. 0. 0. 0.; 2. 2. 0. 0.; 3. 1. -3. 0.; 5. -2. 3. 7.]\nb = [3.1; 5.3; -2.2; 6.0]\nx = Ls(L, b) \n를 통해 \\(\\boldsymbol{x}\\) 를 구할 수 있다. 이제 \\(\\boldsymbol{L\\cdot x}\\) 가 \\(\\boldsymbol{b}\\) 와 같은지 확인하기 위해 L*x 를 실행해보면,\n4-element Vector{Float64}:\n  3.1\n  5.3\n -2.2\n  6.0\n의 결과가 나오므로 \\(\\boldsymbol{b}\\) 를 잘 구했다.\n\n\nRoundoff 에러의 예\n이제 약간 극단적인 경우를 살펴 보자. 하삼각 행렬에서 대각성분이 0 이 아닌 다른 성분에 비해 매우 작은 경우이다.\nA1= [1.0 0 0; 1.0e8 1 0; 1.0e8 1.0e8 1]\nb1 = [1; 1; 1.0]\nx1 = Ls(A1, b1)\n이 때 구한 x1 은 다음과 같다.\n3-element Vector{Float64}:\n  1.0\n -9.9999999e7\n  9.9999998e15\n이 경우 A1*x1 을 수행하면,\n3-element Vector{Float64}:\n 1.0\n 1.0\n 0.0\n가 나와 실제 b1 값과 차이가 남을 알 수 있다. 이것은 64 비트 부동소수의 유효자리수 때문이다. 직접 손으로 계산해 보면 알겠지만 x1 은 정확히 계산이 되었다. 다만 A1*x1 의 세번째 성분은 다음 식을 통해 계산되는데\n\\[\n1.0\\times 10^8 \\times 1 - 9.9999999\\times 10^{15} + (1- 1.0\\times 10^8 \\times 1 + 9.9999999\\times 10^{15})\n\\]\n뒤의 괄호 안을 계산 할 때 \\(9.9999999\\times 10^{15}\\) 라는 숫자가 너무 커서 1 정도의 차이를 표현 할 수 없다. Float64 에서 9.9e15+1 은 9.9e15 과 구별 할 수 없다. 즉 Roundoff 에러가 발생한 것이다. 이런 문제는 BigFloat 와 같은 타입을 사용하면 어느 정도 해소되지만 여기서는 일단은 다루지 않는다.\n\n\n\n\n계산 복잡도 분석\n하삼각 행렬의 경우 \\(x_1\\) 을 계산하는데흔 한번의 나눗셈, \\(k\\ne 1\\) 일 때 \\(x_k\\) 를 계산하는데 스칼라곱이 \\(k-1\\) 번, 덧셈과 뺄셈이 \\(k\\) 번, 나눗셈 \\(1\\) 번이 필요하므로 모두 \\(2k\\) 번의 계신이 필요하다. \\(n \\times n\\) 하삼각 행렬의 행렬식에 대해서\n\\[\nT(n) = 1 + \\sum_{k=2}^n 2k = n^2 + n -1 = O(n^2)\n\\]\n이다.",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "수치해석 입문 : 선형시스템과 다항식"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/03_linear_system.html#sec-gauss_jordan_elimination",
    "href": "src/numerical_analysis_using_julia/03_linear_system.html#sec-gauss_jordan_elimination",
    "title": "수치해석 입문 : 선형시스템과 다항식",
    "section": "3 가우스-요르단 소거법",
    "text": "3 가우스-요르단 소거법\n\\(m \\times n\\) 행렬 \\(\\boldsymbol{A}\\) 와 \\(n \\times k\\) 행렬 \\(\\boldsymbol{X}\\), \\(m \\times k\\) 행렬 \\(B\\) 가 \\(\\boldsymbol{AX}=\\boldsymbol{B}\\) 를 만족하며 \\(\\boldsymbol{L}\\) 이 \\(n \\times n\\) 가역행렬 일 때 다음이 성립한다.\n\\[\n\\boldsymbol{AX}=\\boldsymbol{B} \\iff  \\boldsymbol{LAX} = \\boldsymbol{LB}\n\\]\n만약 \\(k=1\\) 이라면, 즉 \\(n \\times 1\\) 행렬 \\(\\boldsymbol{x}\\),, \\(m \\times 1\\) 행렬 \\(\\boldsymbol{b}\\) 에 대해,\n\\[\n\\boldsymbol{Ax}=\\boldsymbol{b} \\iff  \\boldsymbol{LAx} = \\boldsymbol{Lb}\n\\]\n가 성립한다. 즉 주어진 \\(\\boldsymbol{A}\\) 와 \\(\\boldsymbol{b}\\) 에 대해 가역 행렬 \\(\\boldsymbol{L}\\) 을 통해 \\(\\boldsymbol{LA}\\) 를 매우 간단하게 만든다면 \\(\\boldsymbol{LAx}=\\boldsymbol{Lb}\\) 를 만족하는 \\(\\boldsymbol{x}\\) 를 쉽게 구할 수 있으며, 이 \\(\\boldsymbol{x}\\) 가 우리가 구하고자하는 선형방정식의 해이다.\n\n\n행 사다리꼴 행렬, 행 간소 사다리꼴 행렬과 행 기본 연산\n\n행 사다리꼴과 행 간소 사다리꼴\n행 사다리꼴 행렬(row echelon form matrix)은 다음의 조건을 만족하는 행렬이다.\n\n영벡터가 존재할 경우 이 영벡터는 영벡터가 아닌 행벡터의 아래에 위치한다.\n행렬의 행벡터가 영벡터가 아닐 때, 처음으로 나타나는 0 이 아닌 성분을 선행 성분이라 한다. 윗 행의 선행 성분은 아래 행 전체의 각각의 선행성분보다 앞서 존재한다.\n\n아래의 행렬 \\(\\boldsymbol{A}_1,\\,\\boldsymbol{A}_2\\) 는 각각 1, 2 번 조건을 거스르는 행렬이므로 행사다리꼴이 아니다. (선행 성분을 밑줄로 표시하였다.)\n\\[\n\\begin{aligned}\n\\boldsymbol{A}_1 &= \\begin{bmatrix} \\underline{1} & 2 & 0 \\\\0 & 0 & 0 \\\\ 0 & \\underline{1} & 0\\end{bmatrix}, \\\\\n\\boldsymbol{A}_2 &= \\begin{bmatrix} 0 & 0 & \\underline{1} \\\\ \\underline{1} & 0 & 2\\end{bmatrix}.\n\\end{aligned}\n\\]\n\n행 간소 사다리꼴 행렬(row-reduced echelon form matrix)은 행 사다리꼴 행렬의 조건에 더해 다음의 조건이 추가된다.\n\n각 행의 선행성분은 \\(1\\) 이다. 이를 선행 1 성분 이라 하자.\n선행 1 성분이 존재하는 열은 선행성분을 제외한 모든 성분이 \\(0\\) 이다.\n\n\n\n\n기본 행 연산\n우리는 선형대수학으로부터 모든 행렬은 세가지의 기본 행 연산(elementary row operation)을 통해 행 사다리꼴과 행 간소 사다리꼴 행렬로 만들 수 있으며, 행렬의 행 간소 사다리꼴은 유일하다는 것을 안다. 이때의 기본 행 연산은 다음과 같다.\n\n두 행의 위치를 서로 바꾼다. (\\(\\hat{L}_1\\) 연산)\n특정 행에 \\(0\\) 이 아닌 스칼라를 곱한다. (\\(\\hat{L}_2\\) 연산)\n한 행에 다른 행의 스칼라곱을 더한다. (\\(\\hat{L}_3\\) 연산)\n\n\n\\(m \\times n\\) 행렬에 대한 행 기본 연산은 \\(m \\times m\\) 행렬로 표현된다. \\(k\\) 번째 행과 \\(l\\) 번째 행의 위치를 서로 바꾸는 행렬 \\(\\boldsymbol{L}_1 (k, l)\\) 는 \\[\n[\\boldsymbol{L}_1(k,\\,l)]_{i,\\, j} = \\left\\{\\begin{array}{ll} 1 \\qquad &\\text{if } i = j \\ne k, \\text{ and }i = j \\ne l \\\\ 1 & \\text{if } i = k,\\, j = l,\\\\ 1 & \\text{if } j = k,\\, i = l, \\\\ 0 & \\text{otherwise}\\end{array} \\right.\n\\]\n이며 \\(4 \\times 4\\) 행렬에서 1 행과 3행을 교환하는 행렬 \\(\\boldsymbol{L}_1 (1, 3)\\) 은 다음과 같다.\n\\[\n\\boldsymbol{L}_1(1, 3)\n=\\begin{bmatrix}\n0 & 0 & 1 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 1 & 0 & 0 & 0\\\\  0 & 0 & 0 & 1\n\\end{bmatrix} .\n\\]\n\\(k\\) 번째 행에 스칼라 \\(c\\) 를 곱하는 연산을 나타내는 행렬 \\(\\boldsymbol{L}_2(k, c)\\) 는\n\\[\n[\\boldsymbol{L}_2(k,\\, c)]_{i,\\,j}= \\left\\{\\begin{array}{ll} 1 \\qquad & \\text{if } i=j\\ne k,\\, \\\\ c &\\text{if } i=j=k,\\,\\\\ 0 &\\text{otherwise}\\end{array}\\right.\n\\]\n이며 \\(4\\times 4\\) 행렬에서 2행에 스칼라 \\(c\\) 를 곱하는 행렬은 \\(\\boldsymbol{L}_2 (2, c)\\) 는 다음과 같다.\n\\[\n[\\boldsymbol{L}_2 (2,\\,c)] = \\begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 2 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix}.\n\\]\n\\(l\\) 번째 행에 \\(c\\) 를 곱한 것을 \\(k\\) 번째 행에 더하는 행렬 \\(\\boldsymbol{L}_3 (k, l, c)\\) 은\n\\[\n[\\boldsymbol{L}_3 (k,\\,l,\\,c)]_{i,\\,j} = \\left\\{ \\begin{array}{ll}1 \\qquad & \\text{if } i=j \\,,\\\\\nc & \\text{if } i = k, j = l\\,, \\\\ 0 &\\text{oterwise}  \\end{array}\\right.\n\\]\n이며 \\(4 \\times 4\\) 행렬에서 3 행에 \\(c\\) 를 곱해 \\(1\\) 행에 더하는 행렬 \\(\\boldsymbol{R}\\) 은 다음과 같다.\n\\[\n\\boldsymbol{L}_3 (1, 3, c) = \\begin{bmatrix} 1 & 0 & c & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1\\end{bmatrix}.\n\\]\n모든 행 기본 연산은 \\(\\boldsymbol{L}_1,\\,\\boldsymbol{L}_2,\\,\\boldsymbol{L}_3\\) 가역행렬이며 그 역행렬은 다음과 같다.\n\\[\n\\begin{aligned}\n\\left[\\boldsymbol{L}_1(k, l) \\right]^{-1} &= \\boldsymbol{L}_1(k, l), \\\\\n\\left[\\boldsymbol{L}_2(k, c) \\right]^{-1} &= \\boldsymbol{L}_2(k, 1/c), \\\\\n\\left[\\boldsymbol{L}_3(k, l, c) \\right]^{-1} &= \\boldsymbol{L}_3(k, l, -c),\n\\end{aligned}\n\\]\n\n\n\n\n가우스-요르단 소거 과정 (Gauss-Jordan elimination method)\n가우스 소거법은 기본 행 연산을 유한번 시행하여 행렬을 행 사다리꼴(Row echelon form) 행렬로 변환시키는 것을 말한다. 목적이 사다리꼴이 아닌 행 간소 사다리꼴(Row-reduced echelon form) 일 경우 가우스-요르단 소거법이라 한다. 사람에 따라 가우스-요르단 소거법을 가우스 소거법이라고 하는데 여기서는 둘을 구분하기로 하자. 정사각행렬의 경우 가우스 소거법에 의해 상삼각행렬로 변환되며, 가역행렬일 경우 가우스-요르단 소거법의 결과는 단위행렬이다.\n이제 \\(m\\times n\\) 행렬 \\(\\boldsymbol{A}\\) 에 대한 가우스 소거법을 생각해보자. \\(\\boldsymbol{A}\\) 가 영행렬이면 의미가 없으므로 영행렬이 아닐 때만 생각한다.\nP1-1. 영벡터가 아닌 첫번째 열벡터를 찾는다. 그 열벡터의 첫번째 행이 \\(0\\) 이거나 절대값이 작을 경우 그 열벡터에서 적당한 \\(0\\) 이 아닌 행을 찾아 그 행과 첫번째 행을 교환한다(\\(\\hat{L}_1\\) 연산). 이것을 피보팅 (pivoting) 이라 한다. 보통 첫번째 행이 \\(0\\) 이 아니더라도 절대값이 가장 큰 값을 찾아 교환한다. 예를 들어\n\\[\n\\boldsymbol{A}=\\begin{bmatrix} 1 & 3 & 2 \\\\ 0 & 2 & 4 \\\\ 4 & 1 & 3\\end{bmatrix}\n\\]\n일 경우, 첫번째 열벡터가 영벡터가 아니며, 이 열벡터의 첫번째 행이 \\(0\\) 이 아니지만 이 열벡터에 절대값이 가장 큰 \\(4\\) 가 성분으로 존재하므로 첫번째 행과 마지막 행을 교환한다. 이를 \\(\\boldsymbol{A}_{1-1}\\) 이라 하자. 이 때 선행 성분은 \\(4\\) 이다. \\[\n\\boldsymbol{A}_{1-1}=\\begin{bmatrix} \\underline{4} & 1 & 3\\\\ 1 & 3 & 2 \\\\ 0 & 2 & 4\\end{bmatrix}\n\\]\nP1-2. 선행성분으로 첫번째 행벡터를 나누어준다(\\(\\hat{L}_2\\) 연산). 이제 첫번째 행의 첫번째 성분은 1이다(선행 1 성분). 여기까지 수행한 행렬을 \\(\\boldsymbol{A}_{1-2}\\) 라고 하면 다음과 같다.\n\\[\n\\boldsymbol{A}_{1-2}=\\begin{bmatrix} \\underline{1} & 1/4 & 3/4 \\\\ 1 & 3 & 2 \\\\ 0 & 2 & 4\\end{bmatrix}.\n\\]\nP1-3. 첫번째 행벡터의 선행 1 성분의 열 위치를 \\(l_1\\) 이라 하자. \\(j=2,\\ldots,\\,m\\) 에 대해 \\(\\hat{L}_3 (j, i, -A_{j,l_1})\\) 를 적용하면 \\(l_1\\) 열은 첫번째 성분을 제외하면 모두 \\(0\\) 이 된다. 첫번째 행에 대한 마지막 과정이므로 \\(\\boldsymbol{A}_1\\) 이라 하면 다음과 같다.\n\\[\n\\boldsymbol{A}_1=\\begin{bmatrix} \\underline{1} & 1/4 & 3/4 \\\\ 0 & 3/4 & 5/4 \\\\ 0 & 2 & 4\\end{bmatrix}.\n\\]\n\n이제 행렬 \\(\\boldsymbol{A}_k\\) 가 1) \\(1\\) 행부터 \\(k\\) 행까지는 1) 행 간소 사다리꼴 행렬이며, 2) \\(k\\) 행의 선행 1 성분의 위치가 \\(l_k\\) 열일 때 \\(k\\) 행 아래의 모든 행이 1열부터 \\(l_k\\) 열까지 \\(0\\) 이라고 하자. 이에 다음 Pk-1-1., Pk-1-2., Pk-1-1. 과정을 수행한다.\nPk+1-1. \\(k+1\\) 행부터 \\(m\\) 행까지만 생각한다. 여기서 첫번째 \\(0\\) 벡터가 아닌 열벡터를 찾는다. 당연히 이 열벡터는 \\(l_k\\) 열보다 오른쪽의 열이다. 이것을 \\(l_{k+1}\\) 열이라고 하자. 이 열에서 가장 절대값이 큰 성분의 행과 \\(k+1\\) 행을 교환한다 (\\(\\hat{L}_1\\) 연산). 만약 존재하지 않는다면 \\(k+1\\) 행부터 마지막 행 까지의 모든 행벡터가 영벡터이므로 과정을 더 이상 진행시키지 않는다.\nPk+1-2. 교환된 \\(k+1\\) 행을 가장 처음 \\(0\\) 이 아닌 성분으로 나눈다 (\\(\\hat{L}_2\\) 연산). 이제 첫번째 행의 첫번째 성분은 1이다.(선행 1 성분)\nPk+1-3. \\(k+1\\) 행이 마지막 행이라면 더 이상 진행하지 않는다. 그렇지 않다면 \\(j=1, \\ldots, \\, k, k+2,\\ldots,\\,m\\) 에 대해 \\(\\hat{L}_3 (j, k+1, -A_{j,l_1})\\) 를 적용하면 \\(l_{k+1}\\) 열 의 \\(k+2\\) 행 이하는 모두 \\(0\\) 이 된다.\n이 과정을 수행한 후 \\(1\\) 행부터 \\(k+1\\) 행까지 행 간소 사다리꼴 형태가 됨을 알 수 있다. 이제 \\(m \\times n\\) 행렬에 대해 1 행부터 \\(m\\) 행에 대해 위의 과정을 수행한다면 행렬의 행 간소 사다리꼴 형태를 얻을 수 있다.\n우리는 가역행렬의 행 간소 사다리꼴이 항등행렬임을 안다. \\(n \\times n\\) 가역행렬 \\(\\boldsymbol{A}\\) 와 \\(n\\) 차원 열벡터 \\(\\boldsymbol{b}\\) 에 대해 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 를 만족하는 열벡터 \\(\\boldsymbol{x}\\) 를 찾는다고 하자. \\(\\boldsymbol{A}\\) 가 기본 행 연산 \\(\\boldsymbol{E}_1, \\ldots,\\,\\boldsymbol{E}_N\\) 에 대해 행 간소 사다리꼴이 된다고 하면\n\\[\n\\begin{aligned}\n&\\boldsymbol{E}_N \\cdots \\boldsymbol{E}_1 \\boldsymbol{Ax} = \\boldsymbol{E}_N \\cdots \\boldsymbol{E}_1 \\boldsymbol{b} \\\\\n\\implies &\\boldsymbol{x} = \\boldsymbol{E}_N \\cdots \\boldsymbol{E}_1 \\boldsymbol{b}\n\\end{aligned}\n\\]\n이다. 이 때 \\(\\boldsymbol{E}=\\boldsymbol{E}_N \\cdots \\boldsymbol{E}_1\\) 라고 하면, \\(\\boldsymbol{EA}=\\boldsymbol{I}\\) 이므로,\n\\[\n\\boldsymbol{E} = \\boldsymbol{E}_N \\cdots \\boldsymbol{E}_1 = \\boldsymbol{A}^{-1}\n\\]\n이다. 즉 우리는 가우스-요르단 소거법을 통해 선형방정식을 풀 수 있을 뿐만 아니라, 역행렬도 구할 수 있다.\n이제 가우스-요르단 소거법을 수행하는 함수를 만들어 보자. 행렬 \\(\\boldsymbol{A}\\) 와 열행렬 혹은 행렬 \\(\\boldsymbol{B}\\) 에 대해 \\(\\boldsymbol{A}\\) 를 행 간소 사다리꼴로 만드는 프로세스를 \\(\\begin{bmatrix}\\boldsymbol{A} & \\boldsymbol{B}\\end{bmatrix}\\) 에 대해 수행하도록 한다. 다만 \\(\\boldsymbol{B}\\) 는 선택적으로 입력 가능하다. 함수 gauss_jordan_elimination 을 아래에 구현하였다. 여기서 eptols 는 절대값이 작은 수로 피보팅 할 때 절대값이 이 수보다 작다면 0 과 차이가 없도록 간주한다.\nfunction gauss_jordan_elimination(A::Matrix, b::Union{Nothing, Vector, Matrix}=nothing; eptols = 1.0e-10)\n    m, n = size(A)\n\n    if b ≠ nothing\n        @assert m == size(b)[1]\n        B = [A b]\n    else\n        B = A\n    end\n    \n    ld = 0 #선행 1 성분의 column index\n\n    for i in 1:m\n        termination = true # 종료 조건\n        for j in (ld+1):n\n            p = argmax(abs.(B[i:end, j])) + i -1\n            \n            if abs(B[p, j]) &gt; eptols\n                B[i,:], B[p, :] = B[p, :], B[i,:]\n                ld = j\n                termination = false\n                break\n            end\n        end\n\n        if termination \n            break\n        end\n        \n        B[i, :] .= B[i, :]./B[i, ld]\n        \n        # 선행 1 성분의 열을 자신을 제외하고는 제거\n        for k in 1:m\n            if k ≠ i \n                B[k, :] .= B[k, :] .- (B[k, ld].* B[i, :])\n            end\n        end\n    end\n\n    if b ≠ nothing \n         return B[:, 1:n], B[:,(n+1):end]\n    else \n         return B\n    end\nend\n\n\n\n계산 복잡도 분석\n우선 피보팅 없이 \\(n \\times n\\) 행렬 \\(\\boldsymbol{A}\\) 와 \\(n\\) 차원 벡터 \\(\\boldsymbol{b}\\) 에 대해 \\(\\boldsymbol{Ax}=b\\) 를 만족하는 \\(\\boldsymbol{x}\\) 를 가우스-요르단 소거법을 통해 구하는 데 필요한 계산복잡도를 알아보자. 우선 \\(n\\times (n+1)\\) 행렬 \\(\\begin{bmatrix} \\boldsymbol{A} & \\boldsymbol{b}\\end{bmatrix}\\) 에 대해 수행하므로,\n우선 \\(k\\) 번째 행에 대해\n\n\\(k\\) 행을 대각성분 \\(A_{k,k}\\) 으로 나누어 주는데 \\(n-k+2\\) 번의 연산이 필요하며,\n\\(k\\) 행 아래의 \\(n-k\\) 개의 행에 대해 \\(\\hat{L}_3\\) 연산을 통해 \\(k\\) 열의 성분을 대각성분을 제외하고 모두 \\(0\\) 으로 만드는데, 각각 나누기 한번과 빼기 한번, 두번의 연산이 소요되므로, \\(2(n-k)(n-k+2)\\) 번의 스칼라 사칙연산이 필요하다\n\n따라서\n\\[\nT(n) = \\sum_{k=1}^n (n-k+2) + 2(n-k)(n-k+2) = O\\left( \\frac{2}{3}n^3 \\right) = O(n^3)\n\\]\n이다.",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "수치해석 입문 : 선형시스템과 다항식"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/03_linear_system.html#sec-lu_decomposition",
    "href": "src/numerical_analysis_using_julia/03_linear_system.html#sec-lu_decomposition",
    "title": "수치해석 입문 : 선형시스템과 다항식",
    "section": "4 LU 분해",
    "text": "4 LU 분해\n선형방정식 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 의 해를 수치해석적으로 얻는 가장 기본적인 방법이 LU 분해(LU decomposition, LU factorization) 이다. 또한 행렬의 행렬식과 역행렬을 구하는 가장 기본적인 방법이 LU 분해를 통해 구하는 것이다.\n\n\nLU 분해 (LU decomposition)\n행렬 \\(\\boldsymbol{A}\\) 를 어떤 하삼각행렬 \\(\\boldsymbol{L}\\) 과 상삼각행렬 \\(\\boldsymbol{U}\\) 의 곱으로 다음과 같이 나타내는 것을 LU 분해 (LU decomposition 혹은 LU factorization) 이라고 한다. LU 분해 자체는 정사각 행렬이 아니더라도 가능하다.\n\\[\n\\boldsymbol{A}=\\boldsymbol{LU}\n\\]\n\\(2 \\times 2\\) 행렬의 예를 보자.\n\\[\n\\boldsymbol{A}=\\begin{bmatrix} 2 & 3 \\\\ 2 & 4 \\end{bmatrix} =\\boldsymbol{LU}=\\begin{bmatrix} l_{11} & 0 \\\\ l_{21} & l_{22} \\end{bmatrix} \\begin{bmatrix} u_{11} & u_{12} \\\\ 0 & u_{22} \\end{bmatrix}\n\\]\n이 경우,\n\\[\n\\begin{aligned}\nl_{11}u_{11} & = 2, \\\\\nl_{11}u_{12} &= 3 , \\\\\nl_{21}u_{11} &= 2 , \\\\\nl_{21}u_{12} + l_{22}u_{22} & = 4,\n\\end{aligned}\n\\]\n의 네 개의 식이 나온다. 미지수 6개에 식이 4개이므로 미지수를 결정 할 수 없다. 만약 \\(l_{11}= l_{22}=1\\) 의 제한조건을 걸어 놓고 계산을 하면,\n\\[\n\\boldsymbol{L} = \\begin{bmatrix} 1 & 0 \\\\ 1 & 1\\end{bmatrix},\\qquad \\boldsymbol{U} = \\begin{bmatrix} 2 & 3 \\\\ 0 &1\\end{bmatrix}\n\\]\n이라는 것을 알 수 있다. 일반적인 LU 분해에서도 하삼각행렬 \\(\\boldsymbol{L}\\) 의 대각성분을 1로 고정시켜 구한다.\n다음 행렬에 대한 \\(LU\\) 분해를 생각하자.\n\\[\n\\boldsymbol{B}=\\begin{bmatrix} 0 & 3 \\\\ 2 & 4 \\end{bmatrix} =\\boldsymbol{LU}=\\begin{bmatrix} l_{11} & 0 \\\\ l_{21} & l_{22} \\end{bmatrix} \\begin{bmatrix} u_{11} & u_{12} \\\\ 0 & u_{22} \\end{bmatrix}\n\\]\n이 경우,\n\\[\n\\begin{aligned}\nl_{11}u_{11} & = 0, \\\\\nl_{11}u_{12} &= 3 , \\\\\nl_{21}u_{11} &= 2 , \\\\\nl_{21}u_{12} + l_{22}u_{22} & = 4,\n\\end{aligned}\n\\]\n이며, \\(u_{11}=0\\) 이므로 \\(l_{21}\\) 값을 정할 수 없다. \\(l_{11}=l_{22}=1\\) 이라는 제한조건을 푼다고 해도 마찬가지 이다. 이 경우 우리가 가우스 소거법에서 수행했던 행 교환 연산인 피보팅을 한다. 1행과 2행을 바꾼 행렬을 \\(\\boldsymbol{B}\\) 라고 하면,\n\\[\n\\boldsymbol{B}'=\\begin{bmatrix} 2 & 4 \\\\ 0 & 3 \\end{bmatrix} =\\boldsymbol{LU}=\\begin{bmatrix} l_{11} & 0 \\\\ l_{21} & l_{22} \\end{bmatrix} \\begin{bmatrix} u_{11} & u_{12} \\\\ 0 & u_{22} \\end{bmatrix}\n\\]\n이 경우,\n\\[\n\\begin{aligned}\nl_{11}u_{11} & = 2, \\\\\nl_{11}u_{12} &= 4 , \\\\\nl_{21}u_{11} &= 0 , \\\\\nl_{21}u_{12} + l_{22}u_{22} & = 3,\n\\end{aligned}\n\\]\n이므로\n\\[\n\\boldsymbol{L} =  \\begin{bmatrix}1 &  0 \\\\ 0 & 1 \\end{bmatrix},\\qquad \\boldsymbol{U} =  \\begin{bmatrix} 2 & 4 \\\\ 0 & 3 \\end{bmatrix}\n\\]\n로 LU 분해가 가능하다. 즉 \\(\\boldsymbol{P} =\\begin{bmatrix} 0 & 1 \\\\ 1 & 0\\end{bmatrix}\\) 에 대해 \\(\\boldsymbol{PB}\\) 가 LU 분해가 가능하다. 이렇게 피보팅까지 포함하여 LU 분해를 수행하는 것을 PLU 분해라고 하며 보통 LU 분해를 구현하는 경우 PLU 분해를 포함하여 구현할 수 밖에 없다. 이제부터는 LU 분해는 항상 PLU 분해를 의미한다.\n\n\n\nLU 분해를 이용한 선형방정식의 풀이 및 행렬식\n\\(\\boldsymbol{A}\\) 가 LU 분해 가능이고 \\(\\boldsymbol{PA}=\\boldsymbol{LU}\\) 로 분해되었다고 하자. \\(\\boldsymbol{A}\\) 가 가역행렬이 아니라면 분해가 의미가 없으므로 가역행렬일 때만 생각한다. 치환행렬 \\(\\boldsymbol{P}\\) 는 가역행렬이므로\n\\[\n\\boldsymbol{Ax}=\\boldsymbol{b} \\iff \\boldsymbol{PAx}=\\boldsymbol{Pb} \\iff \\boldsymbol{LUx}=\\boldsymbol{Pb}\n\\]\n가 성립한다. 여기서 우리는 \\(\\boldsymbol{y}=\\boldsymbol{Ux}\\) 라고 놓고 우선 \\(\\boldsymbol{Ly}=\\boldsymbol{Pb}\\) 를 통해 \\(\\boldsymbol{y}\\) 를 구한 후, \\(\\boldsymbol{Ux}=\\boldsymbol{y}\\) 를 풀어서 우리가 구하고자 하는 \\(\\boldsymbol{x}\\) 를 구한다. 가우스-요르단 소거법으로 선형 시스템을 풀기 위해서는 \\(\\boldsymbol{b}\\) 값이 바뀔 때마다 소거법을 수행해야 하지만, LU 분해나 PLU 분해는 \\(\\boldsymbol{A}\\) 에 대해서만 분해 한 후 삼각행렬에 대한 식을 풀면 되기 때문에 훨씬 간단하다. 또한 뒤에 보겠지만 대각성분으로 나눠주는 항이 없기 때문에 roundoff 에러로부터 더 안전하다.\n행렬식 \\(\\det\\) 를 구하는 데도 사용된다. LU 분해 시 \\(\\boldsymbol{L}\\) 의 모든 대각성분을 \\(1\\) 로 고정시키기 때문에,\n\\[\n\\det(\\boldsymbol{A}) = \\det (\\boldsymbol{P}) \\det(\\boldsymbol{U}) = (-1)^n(P) \\prod_{i=1}^n U_{ii}\n\\]\n이다. 여기서 \\(n(P)\\) 는 \\(\\boldsymbol{P}\\) 에 나타나는 치환의 횟수이다.\n\n\n\nPLU 분해\n\\(n \\times n\\) 행렬 \\(\\boldsymbol{A}\\) 가 어떤 행교환 행렬 \\(\\boldsymbol{P}\\) 와 하삼각 행렬 \\(\\boldsymbol{L}\\), 상삼각 행렬 \\(\\boldsymbol{U}\\) 에 대해 \\(\\boldsymbol{PA} = \\boldsymbol{LU}\\) 라 하자. \\(\\boldsymbol{P}\\), \\(\\boldsymbol{L}\\), \\(\\boldsymbol{U}\\) 는 모두 \\(n \\times n\\) 행렬이다. \\(\\boldsymbol{A}\\) 의 첫번째 열벡터에서 절대값이 최대값인 행과 1행을 교환하는 행교환 행렬을 \\(\\boldsymbol{P}_1\\) 이라고 하고 \\(\\boldsymbol{B}_1=\\boldsymbol{P}_1\\boldsymbol{A}\\) 라 하자. 행렬 \\(\\boldsymbol{B}_1\\) 과 \\(\\boldsymbol{L},\\,\\boldsymbol{U}\\) 를 1행, 1열과 나머지 부분행렬로 아래와 같이 구분한다.\n\\[\n\\boldsymbol{B}_1=\\left[\\begin{array}{cc} b_1 & \\boldsymbol{r}_1^T \\\\ \\boldsymbol{c}_1 & \\boldsymbol{C}_1\\end{array}\\right],\\qquad \\boldsymbol{L}=\\begin{bmatrix} 1 & 0 \\\\ \\boldsymbol{l}_1 & \\boldsymbol{L}_1\\end{bmatrix}, \\qquad \\boldsymbol{U} = \\begin{bmatrix} v_1 & \\boldsymbol{u}_1^T \\\\ 0 & \\boldsymbol{U}_1\\\\\\end{bmatrix}\n\\]\n\\(\\boldsymbol{P}_1\\boldsymbol{A} =\\boldsymbol{B}_1=\\boldsymbol{LU}\\) 라 하면 다음을 얻는다. \\[\n\\begin{aligned}\nv_1 & = b_1, \\\\\n\\boldsymbol{u}_1 &= \\boldsymbol{r}_1, \\\\\nu_1 \\boldsymbol{l}_1 &= \\boldsymbol{c}_1, \\\\\n\\boldsymbol{l}_1 \\cdot \\boldsymbol{u}_1^T + \\boldsymbol{L}_1 \\boldsymbol{U}_1 &= \\boldsymbol{C}_1\n\\end{aligned}\n\\]\n이를 통해 \\(\\boldsymbol{L}\\) 과 \\(\\boldsymbol{U}\\) 의 1행과 1열이 결정되며, \\((n-1)\\times (n-1)\\) 행렬인 \\(\\boldsymbol{L}_1\\boldsymbol{U}_1\\) 이 결정된다. \\(\\boldsymbol{A}\\) 의 첫번째 열벡터가 영벡터라면 \\(b_1=0,\\, \\boldsymbol{c}_1=\\boldsymbol{0}\\) 이며, 따라서 \\(u_1=0\\) 으로 \\(\\boldsymbol{l}_1\\) 은 어떤 벡터를 놓아도 계산에 영향을 주지 않기 때문에 가장 간단하게 \\(\\boldsymbol{0}\\) 으로 놓는다.\n이제 \\(\\boldsymbol{A}_1=\\boldsymbol{L}_1\\boldsymbol{U}_1 = \\boldsymbol{C}-\\boldsymbol{l} \\cdot \\boldsymbol{u}^T\\) 이라 놓고, \\(\\boldsymbol{A}_1\\) 에 대해 행교환 행렬 \\(\\boldsymbol{Q}_2\\) 위의 과정을 똑같이 수행하여\n\\[\n\\boldsymbol{Q}_2\\boldsymbol{A}_1=\\boldsymbol{B}_2 = \\left[\\begin{array}{cc} b_2& \\boldsymbol{r}_2^T \\\\ \\boldsymbol{c}_2 & \\boldsymbol{C}_2\\end{array}\\right] = \\begin{bmatrix} 1 & 0 \\\\ \\boldsymbol{l}_2 & \\boldsymbol{L}_2\\end{bmatrix}\\begin{bmatrix} v_2 & \\boldsymbol{u}_2^T \\\\ 0 & \\boldsymbol{U}_2\\\\\\end{bmatrix}\n\\]\n을 얻는다. 여기서 \\(\\boldsymbol{l}_2,\\, v_2,\\, \\boldsymbol{u}_2\\) 와 \\(\\boldsymbol{L_2}\\boldsymbol{U}_2 = \\boldsymbol{C}_2-\\boldsymbol{l}_2 \\cdot \\boldsymbol{u}_2^T\\) 라는 것을 안다. \\(\\boldsymbol{P}_2 = \\begin{bmatrix} 1 & \\boldsymbol{0}^T \\\\ \\boldsymbol{0} & \\boldsymbol{Q}_2\\end{bmatrix}\\) 라고 하면,\n\\[\n\\boldsymbol{P}_2 \\boldsymbol{P}_1 \\boldsymbol{A} = \\begin{bmatrix} 1 &  &  \\\\\\vdots  & 1 &  \\\\ \\boldsymbol{Q}_2 \\boldsymbol{l}_1 & \\boldsymbol{l}_2 & \\boldsymbol{L}_2\\end{bmatrix} \\begin{bmatrix} v_1 & \\cdots & \\boldsymbol{u}_1^T \\\\  & v_2 & \\boldsymbol{u}_2^T \\\\ & & \\boldsymbol{U}_2 \\end{bmatrix}\n\\] 이 된다. 여기서 행렬의 \\(~\\vdots~\\) 는 \\(\\boldsymbol{Q}_2 \\boldsymbol{l}_2\\) 의 연장이며 , \\(\\cdots\\) 는 \\(\\boldsymbol{u}_1^T\\) 의 연장이다. \\(\\boldsymbol{L}_1\\boldsymbol{U}_1\\) 에 대해 위의 과정을 반복적으로 수행하면, 결국 \\(\\boldsymbol{P}\\), \\(\\boldsymbol{L}\\), \\(\\boldsymbol{U}\\) 를 얻을 수 있다. 이것을 수행하는 코드는 다음과 같다.\nfunction PLU(A::Matrix{T}; eptols = 1.0e-10) where T&lt;:Real\n    M, N = size(A)\n    @assert M == N\n\n    L, P, U = one(A), one(A), zero(A)\n    B = copy(A)\n    \n    for i in 1:(M-1)\n        p = argmax(abs.(B[i:end, i])) + i -1\n        \n        if abs(B[p, i]) &lt; eptols\n            error(\"Singularity error\")    \n        end\n\n        P[i,:], P[p, :] = P[p, :], P[i, :]\n        B[i,:], B[p, :] = B[p, :], B[i, :]\n        \n        if i&gt;1\n            L[i,1:i-1], L[p, 1:i-1] = L[p, 1:i-1], L[i, 1:i-1]\n        end\n        \n        U[i, i] = B[i, i]\n        U[i, (i+1):end] = B[i, (i+1):end]\n        L[(i+1):end, i] = B[(i+1):end, i] / B[i, i]\n        B[(i+1):end, (i+1):end] = B[(i+1):end, (i+1):end] - (L[(i+1):end, i:i] * U[i:i, (i+1):end])\n    end\n    U[M, M] = B[M, M]\n    return P, L, U\nend\n\n\n\n\n\n\n경고\n\n\n\n이 코드는 이해를 돕기 위한 코드로, PLU 를 정상적으로 계산 해 주지만 효율적인 코드는 아니다.\n\n\n\n\n\n복잡도 분석\n피봇을 고려하지 않은 복잡도를 분석해보자. \\(m\\times m\\) 행렬에 대해 첫번째 열의 각 열에 대한 연산은 \\(m\\) 번의 곱하기(코딩상으로는 나누기) 와 \\(m\\) 번의 더하기(코딩상으로는 빼기) 가 이루어지며 총 \\(m-1\\) 번의 행에 대해 이루어지기 때문에 \\(2m(m-1)\\) 번의 연산이 이루어진다. \\(n\\times n\\) 행렬에 대해서라면 \\(m\\) 값이 \\(2\\) 부터 \\(n\\) 까지 변할때의 합이므로\n\\[\nT(n) = \\sum_{m=2}^{n} 2m(m-1) = \\sum_{m=1}^n 2m(m-1)= O\\left(\\dfrac{2n^3}{3}\\right)\n\\]\n이다. 즉 가\n\n\n\n왜 LU 인가?\n가우스 소거법과 LU 분해는 복잡도가 같다. 그러나 많은 경우 선형시스템을 푼다는 것은 시스템 행렬 \\(\\boldsymbol{A}\\) 가 주어진 상태에서 \\(\\boldsymbol{b}\\) 가 변함에 따라 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 를 만족하는 \\(\\boldsymbol{x}\\) 를 찾는다. 가우스 소거법을 이용하는 경우라면 매번 \\(O(n^3)\\) 복잡도의 계산을 해 주어야 한다. LU 분해의 경우 \\(\\boldsymbol{A}=\\boldsymbol{LU}\\) (혹은 \\(\\boldsymbol{A}=\\boldsymbol{P}^{-1}\\boldsymbol{LU}\\)) 에 대해 \\(\\boldsymbol{L}\\), \\(\\boldsymbol{U}\\) 가 정해져 있기 때문에 각각 한번의 상삼각행렬과 하삼각행렬에 대해 풀어주면 된다. 상삼각 행렬과 하삼각 행렬의 복잡도는 \\(O(n^2)\\) 이므로 주어진 시스템 행렬에 대해 많은 계산을 할 때는 LU 분해가 훨씬 유리하다.\n\n\n\nLDU 분해\nLU 분해에서 상삼각해렬 \\(\\boldsymbol{U}\\) 를 대각행렬 \\(\\boldsymbol{D}\\) 와 대각성분이 \\(1\\) 인 상삼각행렬 \\(\\boldsymbol{U}'\\) 의 곱으로 나타 낼 수 있다. 이를 LDU 분해라고 한다. \\[\n\\underbrace{\\begin{bmatrix} U_{11} & U_{12} & \\cdots & U_{1n} \\\\ 0 & U_{22} & \\cdots & U_{2n} \\\\ & & \\ddots & \\\\ 0 & 0 & \\cdots & U_{nn}\\end{bmatrix}}_{\\Large\\boldsymbol{U}} = \\underbrace{\\begin{bmatrix} U_{11} &  &  & 0 \\\\   & U_{22} &  &  \\\\ & & \\ddots & \\\\ 0& & & U_{nn}\\end{bmatrix}}_{\\Large{\\boldsymbol{D}}} \\underbrace{\\begin{bmatrix} 1 & U_{12}/U_{11}& \\cdots & U_{1n}/U_{11} \\\\ 0 & 1 & \\cdots & U_{2n}/U_{22} \\\\ & & \\ddots & \\\\ 0 & 0 & \\cdots & 1\\end{bmatrix}}_{\\Large\\boldsymbol{U}'}\n\\]",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "수치해석 입문 : 선형시스템과 다항식"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/03_linear_system.html#qr-분해-qr-factorization",
    "href": "src/numerical_analysis_using_julia/03_linear_system.html#qr-분해-qr-factorization",
    "title": "수치해석 입문 : 선형시스템과 다항식",
    "section": "5 QR 분해 (QR-Factorization)",
    "text": "5 QR 분해 (QR-Factorization)\n\\(m \\times n\\) 행렬 \\(\\boldsymbol{A}\\) 을 \\(m \\times m\\) 행렬 \\(\\boldsymbol{Q}\\) 와 \\(m\\times n\\) 상 삼각행렬 \\(\\boldsymbol{R}\\) 분해하여 \\(\\boldsymbol{A}=\\boldsymbol{QR}\\) 로 나타내는 것을 QR 분해라 한다. 이 때 \\(\\boldsymbol{Q}\\) 행렬의 각 열벡터는 서로 직교하며, 그 크기가 \\(1\\) 이다. \\(m=n\\) 이면 \\(\\boldsymbol{Q}\\) 가 유니터리행렬(unitary matrix) 로 \\(\\boldsymbol{Q}\\boldsymbol{Q}^\\ast = \\boldsymbol{I}\\) 가 된다. 행렬 \\(\\boldsymbol{A}\\) 가 실수체에서 정의되었다면 \\(\\boldsymbol{Q}\\) 행렬은 직교행렬로 \\(\\boldsymbol{Q}\\boldsymbol{Q}^T = \\boldsymbol{I}\\) 이다.\n보통 이론적으로 QR 분해를 설명할 때는 그람-슈미트 과정(Gram-Schmidt process)을 사용하지만, 실제 수치해석적으로 구할 때는 Householder reflection 방법을 사용하거나 기븐스 회전(Givens rotation)을 사용한다.\n\n\n정사영 (Projection)\n\\(\\mathbb{F}\\) 에서 정의된 내적 벡터공간 \\(V\\) 의 기저 \\(\\{\\boldsymbol{u}_1,\\,\\boldsymbol{u}_2,\\ldots,\\boldsymbol{u}_n\\}\\) 이 \\(\\langle \\boldsymbol{u}_i,\\,\\boldsymbol{u}_j \\rangle=\\delta_{ij}\\) 를 만족할 때 이 기저를 정규직교기저 (orthonormal basis) 라 한다. 내적이 정의되면 임의의 기저로부터 항상 정규직교기저를 구할 수 있으며, 이중 가장 유명한 방법이 그람-슈미트 방법이다.\n벡터 \\(\\boldsymbol{v}\\) 의 \\(\\boldsymbol{u}\\) 에 대한 정사영 \\(\\textrm{Proj}_\\boldsymbol{u} \\boldsymbol{v}\\) 는 다음과 같이 정의된다.\n\\[\n\\textrm{Proj}_{\\boldsymbol{u}}\\boldsymbol{v} := \\dfrac{\\langle\\boldsymbol{v},\\, \\boldsymbol{u}\\rangle}{\\langle \\boldsymbol{u,\\, u}\\rangle} \\boldsymbol{u}\n\\]\n\\(\\text{Proj}_\\boldsymbol{u}\\boldsymbol{v}\\) 는 \\(\\boldsymbol{u}\\) 에 평행하며 \\(\\boldsymbol{v}-\\text{Proj}_{\\boldsymbol{u}}\\boldsymbol{v}\\) 는 \\(\\boldsymbol{u}\\) 에 수직하다. 즉\n\\[\n\\langle  \\boldsymbol{u} , \\,\\boldsymbol{v}-\\text{Proj}_{\\boldsymbol{u}}\\boldsymbol{v} \\rangle  = \\boldsymbol{0}\n\\]\n이다. \\(\\boldsymbol{v} = \\text{Proj}_\\boldsymbol{u}\\boldsymbol{v} + (\\boldsymbol{v} - \\text{Proj}_{\\boldsymbol{u}}\\boldsymbol{v})\\) 이므로 \\(\\boldsymbol{v}\\) 를 \\(\\boldsymbol{u}\\) 와 평행한 성분과 \\(\\boldsymbol{u}\\) 에 수직한 성분으로 분리할 수 있다는 것을 알게 되었다. 단위벡터 \\(\\boldsymbol{e} = \\dfrac{\\boldsymbol{u}}{\\|\\boldsymbol{u}\\|}\\) 를 생각하면,\n\\[\n\\text{Proj}_{\\boldsymbol{u}}\\boldsymbol{v} = \\langle \\boldsymbol{v },\\,\\boldsymbol{e}\\rangle\\, \\boldsymbol{e}\n\\]\n이다.\n\n\n\n그람-슈미트 과정\n그람-슈미트 과정을 통해 유한차원 내적 벡터공간에서 주어진 독립 벡터를 이용하여 같은 갯수의 정규 직교 벡터를 얻을 수 있다. \\(N\\) 차원 내적 벡터 공간 \\(V\\) 에서 \\(M\\) 개의 독립벡터 \\(\\{\\boldsymbol{v}_1,\\ldots,\\boldsymbol{v}_M\\}\\) 가 주어졌다고 하자. (당연히 \\(M \\le N\\) 이다). 다음을 이용하여 \\(\\hat{\\boldsymbol{u}}_1,\\ldots,\\,\\hat{\\boldsymbol{u}}_M\\) 을 얻을 수 있다. 이를 그람-슈미트 과정이라고 한다.\n\\[\n\\begin{aligned}\n\\boldsymbol{u}_1 &=  \\boldsymbol{v}_1, \\hat{\\boldsymbol{u}}_1 = \\dfrac{\\boldsymbol{u}_1}{\\|\\boldsymbol{u}_1\\|}, \\\\\n\\boldsymbol{u}_i &= \\boldsymbol{v}_{i} - \\sum_{j=1}^{i-1} \\text{Proj}_{\\boldsymbol{u}_j} \\boldsymbol{v}_i = \\boldsymbol{v}_i-\\sum_{j=1}^{i-1} \\left\\langle \\boldsymbol{v}_i,\\,\\hat{\\boldsymbol{u}}_j \\right\\rangle\\hat{\\boldsymbol{u}}_j,\\qquad \\hat{\\boldsymbol{u}}_i = \\dfrac{\\boldsymbol{u}_i}{\\|\\boldsymbol{u}_i\\|}\n\\end{aligned}\n\\]\n그람 슈미트 과정에 대해 다음 명제가 성립함을 안다.\n\n연습문제 1 독립벡터의 집합 \\(\\{\\boldsymbol{v}_1,\\ldots,\\boldsymbol{v}_M\\}\\) 로부터 그람 슈미트 과정을 통해 얻은 \\(\\{\\hat{\\boldsymbol{u}}_1,\\ldots,\\,\\hat{\\boldsymbol{u}}_M\\}\\) 는 각각 단위행렬이며 서로 직교한다. 즉 \\(\\hat{\\boldsymbol{u}}_i \\cdot \\hat{\\boldsymbol{u}}_j = \\delta_{ij}\\) 이다.\n\n\n연습문제 2 벡터의 집합 \\(\\{\\boldsymbol{v}_1,\\ldots,\\boldsymbol{v}_M\\}\\) 에서 \\(\\boldsymbol{v}_k\\) 를 \\(\\boldsymbol{v}_1,\\ldots,\\boldsymbol{v}_{k-1}\\) 의 선형결합으로 표현할 수 있을 때 그람-슈미트 과정을 통해 얻은 벡터는 영벡터이다.\n\n\n\n\n그람 슈미트 과정을 이용한 QR 분해 (QR decomppsition)\n이제 우리는 주어진 독립벡터들로 정규직교벡터를 구성하는 법을 배웠다. 여기서는 \\(m \\times n\\) 행렬 \\(\\boldsymbol{A}\\) 의 열벡터 \\(\\boldsymbol{A}_{:1},\\ldots\\), \\(\\boldsymbol{A}_{:n}\\) 에 대해 그람-슈미트 과정을 수행한다고 하자. \\[\n\\begin{aligned}\n\\boldsymbol{u}_1 &=  \\boldsymbol{A}_{:1},\\qquad \\hat{\\boldsymbol{u}}_1 = \\dfrac{\\boldsymbol{u}_1}{\\|\\boldsymbol{u}_1\\|}, \\\\\n\\boldsymbol{u}_j &= \\boldsymbol{A}_{:j} - \\sum_{k=1}^{j-1} \\text{Proj}_{\\boldsymbol{u}_k} \\boldsymbol{A}_{:j} = \\boldsymbol{A}_{:j}-\\sum_{k=1}^{j-1} \\left\\langle \\boldsymbol{A}_{:j},\\,\\hat{\\boldsymbol{u}}_k \\right\\rangle\\hat{\\boldsymbol{u}}_k,\\qquad \\hat{\\boldsymbol{u}}_j = \\dfrac{\\boldsymbol{u}_j}{\\|\\boldsymbol{u}_j\\|}\n\\end{aligned}\n\\] 라 하면,\n\\[\nA_{ij}=(\\boldsymbol{A}_{:j})_i = \\sum_{k=1}^n \\left(\\langle \\boldsymbol{A}_{:j},\\,\\hat{\\boldsymbol{u}}_k\\rangle \\hat{\\boldsymbol{u}}_k \\right)_i\n\\] 이다. 이 때 \\(\\boldsymbol{Q},\\, \\boldsymbol{R}\\) 을 다음과 같이 정의하면 \\(\\boldsymbol{A}= \\boldsymbol{QR}\\) 이 된다.\n\\[\nQ_{ik} := (\\hat{\\boldsymbol{u}}_k)_i,\\qquad R_{kj} := \\langle \\boldsymbol{A}_{:j},\\,\\hat{\\boldsymbol{u}}_k\\rangle\n\\]\n즉 \\(\\boldsymbol{Q}\\) 의 \\(i\\) 번째 열벡터는 \\(\\boldsymbol{A}\\) 의 각각의 열벡터에 대해 그람-슈미트 과정을 수행했을 때의 단위벡터 혹은 영벡터(연습문제 2) 이며 \\(\\boldsymbol{R}\\) 은 그람-슈미트 과정에서의 계수이다. 아래는 그람-슈미트 과정에 의한 QR 분해를 구현한 코드이다.\nfunction qr_gram_schmidt(A::AbstractMatrix{T}, normeps=1.0e-14) where T&lt;:Number\n    M, N = size(A)\n    Q = zeros(Float64, (M, N))\n    R = zeros(Float64, (N, N))\n    \n    Q[:,1] = A[:,1]/norm(A[:,1])\n    R[1,1] = dot(A[:,1], Q[:,1])\n\n    for j = 2:N\n        Uj = A[:,j] \n        for k = 1:j-1\n            R[k, j] = dot(A[:,j], Q[:, k])\n            Uj = Uj .- R[k, j] .* Q[:,k]\n        end\n        if norm(Uj)&gt;normeps\n            Q[:,j]= Uj/norm(Uj)\n            R[j, j] = dot(A[:,j], Q[:, j])\n        end \n    end\n    return Q, R\n\nend\n\n여기서 norm(A) 는 벡터의 노름을 구하는데 사용되었으며, 정확히는 norm(A, p::Real=2) 의 형태로 벡터, 혹은 행렬의 \\(p\\)-노름을 구하는데 사용되는 함수이다. 앞선 벡터들의 선형결합인 벡터는 영벡터가 되어야 하지만 Roundoff 에러로 인해 0 이 아닌 작은 노름을 가질 수 있으므로, 함수의 normeps 보다 작은 값을 가질 경우 영벡터로 간주한다.\n실제로는 그람-슈미트 방법을 이용한 QR-분해는 잘 사용되지 않는데, round-off 에러가 발생하여 수치해석적으로 불안정하기 때문이다. 보통은 밀집 행렬의 경우 하우스홀더 변환을 통한 방법을 사용한다. 하우스홀더 변환을 통한 QR 분해는 –to be done– 를 참고하라.",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "수치해석 입문 : 선형시스템과 다항식"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/11_polynomial.html",
    "href": "src/introduction_to_julia/11_polynomial.html",
    "title": "Julia & Numerical Anlaysis",
    "section": "",
    "text": "이제 일변수 다항식 (\\(x\\) 에 대한 다항식)을 특별한 자료형으로 Julia 언어에서 구현해보자. 다항식은 기본적인 함수일 뿐만 아니라 수치해석에도 널리 사용된다. 여기서는 다항식에 대한 객체를 만들어 앞으로도 사용하고자 한다. Julia 자체는 다항식에 대한 자료구조나 객체를 포함하지 않지만 2022 년 현재 Polynomials.jl 이라는 라이브러리가 널리 사용된다. 그러나 여기서는 이 책에서 계속 사용할 다항식 객체를 만들고자 한다.\n\n\n\nJulia 에서 함수는 1급 객체로, 변수에 할당 될 수 있으며, 타입을 가질 수 있고, 함수의 리턴값으로 사용 될 수 있다. 이를 이용하면 계수를 1차원 배열인 벡터로 전달하여 익명 함수를 리턴하는 함수를 작성 할 수 있다. 다음 poly1 함수는 다항식의 전체 계수 벡터 coeff 를 인자로 받아 coeff[i] 가 다항식의 \\(i-1\\) 차 계수가 되는 함수를 리턴한다.\nfunction poly1(coeff::Vector{T}) where T&lt;:Number\n    return x -&gt; sum(coeff .* (x .^ (0:(length(coeff)-1))))\nend\n우리는 이 함수가 잘 작동함을 확인 할 수 있다.\nIn [2]: ff = poly1([1.0, -2.0, 1.0])\nOut[2]: #3 (generic function with 1 method)\n\nIn [3]: ff(1.0)\nOut[3]: 0.0\n함수 시그니쳐의 poly1(coeff::Vector{T}) where T&lt;:Number 에서 poly1(coeff::Vector{T}) 는 poly1 함수가 T 타입의 벡터를 인자로 받는다는 뜻이며 뒤의 where T&lt;:Number 는 T 가 Number 의 서브타입만을 허락한다는 의미이다. Number 는 추상 타입(abstract type) 이므로 변수에 할당 될 수 없다. 따라서 coeff 가 벡터가 아니거나, 수 타입에 대한 벡터가 아니면 에러가 발생한다.\nIn [4]: poly1(3)\nERROR: MethodError: no method matching poly1(::Int64)\n\nIn [5]: poly1([sin, 1])\nERROR: MethodError: no method matching poly1(::Vector{Any})\nreturn 뒤의 x -&gt; sum(coeff .* (x .^ (0:(length(coeff)-1)))) 구문은 익명함수를 만드는 구문이다. 수를 받아 다항식을 계산하는 익명 함수를 반환한다. 이렇게 하면 ff = poly1([1.0, -2.0, 1.0]) 라 하면 ff(x) 는 \\(1-2x+x^2\\) 를 나타내는 다항식이다. 이 다항식의 함수에서 리턴 타입은 coeff 와 x 의 타입의 연산 규칙에 다라 결정된다.\n때에 따라서는 이것도 충분하며, 타입을 고려하지 않는다면 심지어 이것보다 간단한 버젼도 가능하다. 그러나 보통 다항식을 나타내는 자료구조를 생각하면, 최소한 다항식간의 덧셈, 뺄셈, 곱셈이 가능하면 좋을 것이다. 그리고 행렬의 다항식도 가능하다면 구현하면 좋을 것이다.\n익명 함수로는 이것이 힘들다. structure 를 이용하여 다항식 객체를 만들어 보자. 이미 널리 사용되는 Polynomials.jl 패키지가 있으므로 SimplePolynomial 이라는 객체를 만들도록 하자.\n\n\n\n\nstruct SimplePolynomial{T} \n    coeffs :: Vector{T}\n    \n    function SimplePolynomial(a::AbstractVector{P}) where P &lt;: Number\n        if length(a) == 0 \n            return new{P}(zeros(T, 1))\n        else \n            last_nz = findlast(!iszero, a)\n            a_last = max(1, isnothing(last_nz) ? 0 : last_nz)\n            return new{P}(a[1:a_last])\n        end\n    end\n\n    function SimplePolynomial{T}(a::AbstractVector{P}) where {T &lt;: Number, P&lt;:Number}\n        if length(a) == 0 \n            return new{T}(zeros(T, 1))\n        else \n            last_nz = findlast(!iszero, a)\n            a_last = max(1, isnothing(last_nz) ? 0 : last_nz)\n            return new{T}(convert.(T, a[1:a_last]))\n        end\n    end\n\nend\nSimplePolynomial 은 immutable 한 객체로 구현되었다. 즉 coeffs 속성은 변경 될 수 없다.\nIn [1]: a = SimplePolynomial([1, 3])\nOut[1]: SimplePolynomial{Int64}([1, 3])\n\nIn [2]: a.coeffs = [3.0, 4.0]\nERROR: setfield!: immutable struct of type SimplePolynomial cannot be changed\nstruct 구문 내부의 function SimplePolynomial 로 시작하는 구문은 내부생성자 (inner constructor) 구문이다. SimplePolynomial 자체가 타입매개변수 T 를 정할수 있는 타입이기 때문에 하나는 타입매개변수가 지정되지 않았을 때 타입을 계수로 주어진 인자 a 의 성분의 타입으로 정하고, 남은 하나는 a 를 타입 인자 T 로 주어지는 타입으로 변환시켜 다항식을 만들어 내게 된다.\n이제 SimplePolynomial 객체를 이용하여 수 형식, 혹은 정사각 행렬에 대한 다항식을 계산하는 함수를 만들자.\nusing LinearAlgebra\n\nfunction (p::SimplePolynomial)(x::Number)\n    return evalpoly(x, p.coeffs)\nend\n\nfunction (p::SimplePolynomial)(x::T) where T &lt;: Matrix{N} where N&lt;:Number\n    r = UniformScaling(p.coeffs[1])\n\n    @assert size(x)[1] == size(x)[2] # 정사각 행렬에 대해서만 가능하다.\n    for i in 2:length(p.coeffs)\n        @inbounds r +=  p.coeffs[i]*x^(i-1)\n    end\n    return r\nend\n단위행렬의 상수배를 나타내는 연산자 UniformScaling을 위해 LinearAlgebra 모듈을 임포트 했다. 정사각 행렬임을 확인하기 위해 @assert size(x)[1] == size(x)[2] 를 삽입하였다. REPL 에서의 아래의 결과를 보면 정확히 구현되었음을 알 수 있다.\nIn [1]: a1 = SimplePolynomial([1.0, 2.0, 3.0])\nOut[1]: SimplePolynomial{Float64}([1.0, 2.0, 3.0])\n\nIn [2]: a1(1.0)\nOut[2]: 6.0\n\nIn [3]: a1([4 3; 2 4])\nOut[3]: 2×2 Matrix{Float64}:\n 75.0  78.0\n 52.0  75.0\n\nIn [4]: a1([4 3 3; 2 4 3])\nERROR: AssertionError: (size(x))[1] == (size(x))[2]\n다항식의 덧셈, 뺄셈, 곱셈을 정의하기 전에 다항식의 차수에 관련된 값을 리턴하는 함수를 만들자. 일반적으로 배열은 length 함수로 원소의 갯수를 알 수 있는데, 다항식에서는 계수의 갯수-1 이 차수가 된다. Base.length 함수에 대한 디스패치를 작성하여 이 함수를 이용하자.\nfunction Base.:length(b::P) where {P&lt;: SimplePolynomial}\n    return length(b.coeffs)\nend\n이제 SimpllePolynomial 객체 사이에 혹은 SimplePolynomial 객체와 상수간의 +, -, *, / 연산을 정의 할 수 있다. / 의 경우 일단은 다항식/상수 만을 정의한다. 이것에 대한 구현은 polynomial.jl 파일에 존재한다. Julia REPL 이나 Jupyter notebook 등에서 include 명령을 통해 사용 할 수 있다.\ninclude(\"path_to_polynomial.jl\")\n다항식 \\(p(x) = a_0 + a_1 x + \\cdots + a_n x^n\\) 일 때,\n\\[\n\\begin{aligned}\n\\dfrac{d}{dx}p(x) &= a_1 + 2a_2 x + \\cdots + na_n x^{n-1},\\\\\n\\int_x p(t)\\, dt &=a_0 x + \\dfrac{a_1}{2}x^2 + \\cdots + \\dfrac{a_n}{n+1}x^{n+1} + \\text{const.}\n\\end{aligned}\n\\]\n임을 안다. 이것을 이용하여 다항식을 미분하는 함수 differentiate(p::Polynomial{T}) 와 정적분 함수 integrate(p::Polynomial{T}, c) 함수를 구현하였다. 여기서 c 는 정적분의 상수항이다.\n\n\n\n\n다항식 \\(p(x)\\) 의 전체 근이 \\(x_1,\\,x_2,\\ldots,\\,x_n\\) 라고 하면 이 다항식은 상수 \\(c\\) 에 대해\n\\[\np(x) = c \\prod_{i=1}^n (x-x_i)\n\\]\n의 꼴을 갖는다. 우리는 이미 다항식의 곱셈을 구현했으므로 이를 쉽게 구현 할 수 있다. 여기서는 \\(c=1\\) 로 정해진 다항식을 리턴한다.\nfunction polynomial_from_roots(xp::Vector{T}) where T&lt;:Number\n    r = one(T)\n    for i in 1:length(xp) \n        @inbounds r = r* SimplePolynomial([-xp[i],  1])\n    end\n    return r\nend\n그렇다면,\njulia&gt; pp3 = polynomial_from_roots([1.0, 1.0, 2.0])\nSimplePolynomial :  + 1.0 x^3 - 4.0 x^2 + 5.0 x^1 - 2.0 \n의 결과가 나온다. \\((x-1)^2(x-2)= x^3-4x^2+5x-2\\) 이므로 정확한 결과가 나왔다."
  },
  {
    "objectID": "src/introduction_to_julia/11_polynomial.html#일변수-다항식의-julia-구현",
    "href": "src/introduction_to_julia/11_polynomial.html#일변수-다항식의-julia-구현",
    "title": "Julia & Numerical Anlaysis",
    "section": "",
    "text": "이제 일변수 다항식 (\\(x\\) 에 대한 다항식)을 특별한 자료형으로 Julia 언어에서 구현해보자. 다항식은 기본적인 함수일 뿐만 아니라 수치해석에도 널리 사용된다. 여기서는 다항식에 대한 객체를 만들어 앞으로도 사용하고자 한다. Julia 자체는 다항식에 대한 자료구조나 객체를 포함하지 않지만 2022 년 현재 Polynomials.jl 이라는 라이브러리가 널리 사용된다. 그러나 여기서는 이 책에서 계속 사용할 다항식 객체를 만들고자 한다.\n\n\n\nJulia 에서 함수는 1급 객체로, 변수에 할당 될 수 있으며, 타입을 가질 수 있고, 함수의 리턴값으로 사용 될 수 있다. 이를 이용하면 계수를 1차원 배열인 벡터로 전달하여 익명 함수를 리턴하는 함수를 작성 할 수 있다. 다음 poly1 함수는 다항식의 전체 계수 벡터 coeff 를 인자로 받아 coeff[i] 가 다항식의 \\(i-1\\) 차 계수가 되는 함수를 리턴한다.\nfunction poly1(coeff::Vector{T}) where T&lt;:Number\n    return x -&gt; sum(coeff .* (x .^ (0:(length(coeff)-1))))\nend\n우리는 이 함수가 잘 작동함을 확인 할 수 있다.\nIn [2]: ff = poly1([1.0, -2.0, 1.0])\nOut[2]: #3 (generic function with 1 method)\n\nIn [3]: ff(1.0)\nOut[3]: 0.0\n함수 시그니쳐의 poly1(coeff::Vector{T}) where T&lt;:Number 에서 poly1(coeff::Vector{T}) 는 poly1 함수가 T 타입의 벡터를 인자로 받는다는 뜻이며 뒤의 where T&lt;:Number 는 T 가 Number 의 서브타입만을 허락한다는 의미이다. Number 는 추상 타입(abstract type) 이므로 변수에 할당 될 수 없다. 따라서 coeff 가 벡터가 아니거나, 수 타입에 대한 벡터가 아니면 에러가 발생한다.\nIn [4]: poly1(3)\nERROR: MethodError: no method matching poly1(::Int64)\n\nIn [5]: poly1([sin, 1])\nERROR: MethodError: no method matching poly1(::Vector{Any})\nreturn 뒤의 x -&gt; sum(coeff .* (x .^ (0:(length(coeff)-1)))) 구문은 익명함수를 만드는 구문이다. 수를 받아 다항식을 계산하는 익명 함수를 반환한다. 이렇게 하면 ff = poly1([1.0, -2.0, 1.0]) 라 하면 ff(x) 는 \\(1-2x+x^2\\) 를 나타내는 다항식이다. 이 다항식의 함수에서 리턴 타입은 coeff 와 x 의 타입의 연산 규칙에 다라 결정된다.\n때에 따라서는 이것도 충분하며, 타입을 고려하지 않는다면 심지어 이것보다 간단한 버젼도 가능하다. 그러나 보통 다항식을 나타내는 자료구조를 생각하면, 최소한 다항식간의 덧셈, 뺄셈, 곱셈이 가능하면 좋을 것이다. 그리고 행렬의 다항식도 가능하다면 구현하면 좋을 것이다.\n익명 함수로는 이것이 힘들다. structure 를 이용하여 다항식 객체를 만들어 보자. 이미 널리 사용되는 Polynomials.jl 패키지가 있으므로 SimplePolynomial 이라는 객체를 만들도록 하자.\n\n\n\n\nstruct SimplePolynomial{T} \n    coeffs :: Vector{T}\n    \n    function SimplePolynomial(a::AbstractVector{P}) where P &lt;: Number\n        if length(a) == 0 \n            return new{P}(zeros(T, 1))\n        else \n            last_nz = findlast(!iszero, a)\n            a_last = max(1, isnothing(last_nz) ? 0 : last_nz)\n            return new{P}(a[1:a_last])\n        end\n    end\n\n    function SimplePolynomial{T}(a::AbstractVector{P}) where {T &lt;: Number, P&lt;:Number}\n        if length(a) == 0 \n            return new{T}(zeros(T, 1))\n        else \n            last_nz = findlast(!iszero, a)\n            a_last = max(1, isnothing(last_nz) ? 0 : last_nz)\n            return new{T}(convert.(T, a[1:a_last]))\n        end\n    end\n\nend\nSimplePolynomial 은 immutable 한 객체로 구현되었다. 즉 coeffs 속성은 변경 될 수 없다.\nIn [1]: a = SimplePolynomial([1, 3])\nOut[1]: SimplePolynomial{Int64}([1, 3])\n\nIn [2]: a.coeffs = [3.0, 4.0]\nERROR: setfield!: immutable struct of type SimplePolynomial cannot be changed\nstruct 구문 내부의 function SimplePolynomial 로 시작하는 구문은 내부생성자 (inner constructor) 구문이다. SimplePolynomial 자체가 타입매개변수 T 를 정할수 있는 타입이기 때문에 하나는 타입매개변수가 지정되지 않았을 때 타입을 계수로 주어진 인자 a 의 성분의 타입으로 정하고, 남은 하나는 a 를 타입 인자 T 로 주어지는 타입으로 변환시켜 다항식을 만들어 내게 된다.\n이제 SimplePolynomial 객체를 이용하여 수 형식, 혹은 정사각 행렬에 대한 다항식을 계산하는 함수를 만들자.\nusing LinearAlgebra\n\nfunction (p::SimplePolynomial)(x::Number)\n    return evalpoly(x, p.coeffs)\nend\n\nfunction (p::SimplePolynomial)(x::T) where T &lt;: Matrix{N} where N&lt;:Number\n    r = UniformScaling(p.coeffs[1])\n\n    @assert size(x)[1] == size(x)[2] # 정사각 행렬에 대해서만 가능하다.\n    for i in 2:length(p.coeffs)\n        @inbounds r +=  p.coeffs[i]*x^(i-1)\n    end\n    return r\nend\n단위행렬의 상수배를 나타내는 연산자 UniformScaling을 위해 LinearAlgebra 모듈을 임포트 했다. 정사각 행렬임을 확인하기 위해 @assert size(x)[1] == size(x)[2] 를 삽입하였다. REPL 에서의 아래의 결과를 보면 정확히 구현되었음을 알 수 있다.\nIn [1]: a1 = SimplePolynomial([1.0, 2.0, 3.0])\nOut[1]: SimplePolynomial{Float64}([1.0, 2.0, 3.0])\n\nIn [2]: a1(1.0)\nOut[2]: 6.0\n\nIn [3]: a1([4 3; 2 4])\nOut[3]: 2×2 Matrix{Float64}:\n 75.0  78.0\n 52.0  75.0\n\nIn [4]: a1([4 3 3; 2 4 3])\nERROR: AssertionError: (size(x))[1] == (size(x))[2]\n다항식의 덧셈, 뺄셈, 곱셈을 정의하기 전에 다항식의 차수에 관련된 값을 리턴하는 함수를 만들자. 일반적으로 배열은 length 함수로 원소의 갯수를 알 수 있는데, 다항식에서는 계수의 갯수-1 이 차수가 된다. Base.length 함수에 대한 디스패치를 작성하여 이 함수를 이용하자.\nfunction Base.:length(b::P) where {P&lt;: SimplePolynomial}\n    return length(b.coeffs)\nend\n이제 SimpllePolynomial 객체 사이에 혹은 SimplePolynomial 객체와 상수간의 +, -, *, / 연산을 정의 할 수 있다. / 의 경우 일단은 다항식/상수 만을 정의한다. 이것에 대한 구현은 polynomial.jl 파일에 존재한다. Julia REPL 이나 Jupyter notebook 등에서 include 명령을 통해 사용 할 수 있다.\ninclude(\"path_to_polynomial.jl\")\n다항식 \\(p(x) = a_0 + a_1 x + \\cdots + a_n x^n\\) 일 때,\n\\[\n\\begin{aligned}\n\\dfrac{d}{dx}p(x) &= a_1 + 2a_2 x + \\cdots + na_n x^{n-1},\\\\\n\\int_x p(t)\\, dt &=a_0 x + \\dfrac{a_1}{2}x^2 + \\cdots + \\dfrac{a_n}{n+1}x^{n+1} + \\text{const.}\n\\end{aligned}\n\\]\n임을 안다. 이것을 이용하여 다항식을 미분하는 함수 differentiate(p::Polynomial{T}) 와 정적분 함수 integrate(p::Polynomial{T}, c) 함수를 구현하였다. 여기서 c 는 정적분의 상수항이다.\n\n\n\n\n다항식 \\(p(x)\\) 의 전체 근이 \\(x_1,\\,x_2,\\ldots,\\,x_n\\) 라고 하면 이 다항식은 상수 \\(c\\) 에 대해\n\\[\np(x) = c \\prod_{i=1}^n (x-x_i)\n\\]\n의 꼴을 갖는다. 우리는 이미 다항식의 곱셈을 구현했으므로 이를 쉽게 구현 할 수 있다. 여기서는 \\(c=1\\) 로 정해진 다항식을 리턴한다.\nfunction polynomial_from_roots(xp::Vector{T}) where T&lt;:Number\n    r = one(T)\n    for i in 1:length(xp) \n        @inbounds r = r* SimplePolynomial([-xp[i],  1])\n    end\n    return r\nend\n그렇다면,\njulia&gt; pp3 = polynomial_from_roots([1.0, 1.0, 2.0])\nSimplePolynomial :  + 1.0 x^3 - 4.0 x^2 + 5.0 x^1 - 2.0 \n의 결과가 나온다. \\((x-1)^2(x-2)= x^3-4x^2+5x-2\\) 이므로 정확한 결과가 나왔다."
  },
  {
    "objectID": "src/introduction_to_julia/09_composite_types.html",
    "href": "src/introduction_to_julia/09_composite_types.html",
    "title": "복합 타입",
    "section": "",
    "text": "복합 타입(composite type) 은 필드(field)라고 불리는 하위 변수를 갖는 타입이며, 필드는 정수나 실수 타입 뿐만 아니라 함수 타입이나 다른 복합 타입이 될 수 있습니다. 아주 간단한 복합 타입으로 2차원 평면 상의 점에 대한 복합타입을 다음과 같이 정의 할 수 있습니다.\nstruct Point\n    x\n    y\nend\n복합타입의 정의는 struct 로부터 시작하여 end 로 끝납니다. 위에서 Point 는 구체적 타입의 이름이 되며, x, y 라는 두개의 필드를 가질 수 있습니다.\nIn [2]: isconcretetype(Point)\nOut[2]: true\nPoint 타입의 변수는 p1 = Point(1, 2) 와 같이 생성할 수 있으며 각 필드는 p1.x, p1.y 와 같이 접근합니다.\nIn [3]: p1 = Point(1, 2)\nOut[3]: Point(1, 2)\n\nIn [4]: println(\"Point p1.x=$(p1.x), p1.y=$(p1.y)\")\nPoint p1.x=1, p1.y=2\n\nIn [5]: typeof(p1) # `Point` is a name of type\nOut[5]: Point\n복합 타입 인스턴스는 특별히 따로 정하지 않았다면 타입이름을 함수처럼 사용하여 생성합니다. 인자는 타입 정의에서 나열된 필드순으로 입력하면 됩니다. 즉 p1=Point(1, 2) 는 x 필드는 1, y 필드는 2 의 값을 갖는 Point 객체 인스턴스를 생성하라는 뜻입니다. 이렇게 타입 인스턴스를 만드는 함수를 생성자(constructor) 라고 합니다. 생성자는 별도로 정의할수도 있지만 위에서처럼 타입 이름을 함수로 사용하여 인자로 필드 값을 나열하는 생성자를 기본 생성자(default constructor) 라고 합니다.\n\n\n\n\n복합타입을 정의 할 때 아래와 같이 타입 매개 변수를 사용하여 정의 할 수 있습니다.\nstruct OneValue{T}\n    val::T\nend\nIn [8]: x=OneValue(3)\nOut[8]: OneValue{Int64}(3)\n\nIn [9]: y=OneValue{Float64}(4)\nOut[9]: OneValue{Float64}(4.0)\n\nIn [10]: typeof(x) == typeof(y)\nOut[10]: false\n\nIn [11]: typeof(x) == typeof(OneValue{Int64}(5))\nOut[11]: true\nstruct OneValue{T} 에서 OneValue 는 타입 이름이며 {T} 에서 {T} 가 타입에 대한 매개변수입니다. 타입에 대한 매개변수는 타입 이름일 수도 있으며 정수, 실수, Symbol 이나 Bool 과 같은 bit 타입의 값이 올 수 있습니다. 일단 매개변수로 받으면 필드의 정의나 생성자의 정의에서 사용 할 수 있습니다. 이 때 x 와 y 의 타입 즉 OneValue{Int64} 와 OneValue{Float64} 는 다른 타입입니다.\nIn [8] 을 봅시다. 매개변수 T 는 필드 val 의 타입으로 정의되었습니다. x=OneValue(3) 처럼 매개변수를 사용하지 않고 인스턴스를 만들면 val 의 타입이 자연스럽게 T 가 됩니다. In [9] 의 경우처럼 y=OneValue{Float64}(4) 와 같이 매개변수를 명시적으로 지정했을 경우에는 필드 val 의 타입이 T==Float64 로 강제로 변환됩니다.\n이렇게 타입 매개변수로 타입을 만들면 그 매개변수를 이후에도 사용 할 수 있습니다. 아래의 isIntType(o::OneValue{T}) 함수는 OneValue{T} 의 T 가 Integer 의 하위타입인지를 확인하는 함수입니다. 물론 o.val 의 타입을 확인할 수도 있지만 아래의 것이 훨씬 깔끔합니다.\nfunction isIntType(o::OneValue{T}) where T\n    if T&lt;:Integer\n        return true\n    else\n        return false\n    end\nend\nOut[13]: isIntType (generic function with 1 method)\n\nIn [14]: isIntType(x)\nOut[14]: true\n\nIn [15]: isIntType(y)\nOut[15]: false\n\n\n\n\n이제 우선 우리에게 아마도 익숙할 복소수 타입을 봅시다. Julia 는 복소수를 다루기 위한 Complex{T} 타입을 내장하고 있습니다. Complex{T} 는 필드로 실수부와 허수부를 가지며 다음과 같이 정의됩니다.\nstruct Complex{T&lt;:Real} &lt;: Number\n    re::T\n    im::T\nend\n\nComplex(x::Real, y::Real) = Complex(promote(x,y)...)\nComplex(x::Real) = Complex(x, zero(x))\n\n&lt;:Number 를 통해 Complex 객체는 Number 의 하위타입으로 정의됩니다.\nComplex{T&lt;:Real} 은 매개변수 T 를 통해 re 와 im 필드의 타입을 제한합니다. T&lt;:Real 이며 re::T, im::T 이므로 두 필드 는 Real 의 동일한 하위타입이어야 합니다. 두 개 이상의 타입이 필요할 경우는 {T1&lt;:Real, T2&lt;:Integer} 와 같이 { } 안에 , 로 분리하여 나열하면 됩니다.\n생성자가 타입 정의 외부에 존재합니다. 이를 외부생성자라고 합니다.\n첫번째 생성자는 x 와 y 가 Real 타입의 하위 타입일 때 타입을 일치시키기 위한 생성자입니다. promote(x, y) 는 x 와 y 변수의 타입을 두 변수를 공통적으로 표현할 수 있는 타입으로 변환시켜 튜플로 반환합니다. 이렇게 다른 타입의 둘 이상의 값을 같은 타입이 되도록 변환하는 것을 julia 에서는 promotion 이라고 합니다. promote(2, 3.0) == (2.0, 3.0) 입니다. 그런데 Complex(promote(2, 3.0)) 은 Complex(2.0, 3.0) 이 아니라 Complex((2.0, 3.0)) 으로 튜플 인자 하나만 주어지며, 따라서 에러가 발생합니다. Complex(promote(2, 3.0)...) 는 promote(2, 3.0) 의 결과로 주어지는 튜플을 풀어서 함수의 인자로 넣도록 합니다. 즉, Complex(promote(2, 3.0)...) 은 결과적으로 Complex(2.0, 3.0) 입니다. 함수를 실행시킬때 인자에서의 사용법 을 참고하시기 바랍니다.\n두번째 생성자는 인자가 하나만 주어졌을 때 im 필드를 인자 re 필드와 같은 타입의 0 으로 간주하여 생성하도록 하는 생성자입니다.\n\nComplex{T&lt;:Real} 은 다음과 같이 사용 할 수 있습니다.\nIn [1]: com1 = Complex{Float32}(3.3, 2.3) #Float32 타입의 필드를 갖는 복소수\nOut[1]: 3.3f0 + 2.3f0im\n\nIn [2]: com2 = Complex(3.3, 2.3) # 3.3, 2.3 이 Float64 이므로 타입의 필드를 갖는 복소수\nOut[2]: 3.3 + 2.3im\n\nIn [3]: com3 = 3.3 + 2.3im # 복소수를 선언하는 두번째 방법\nOut[3]: 3.3 + 2.3im\n\nIn [4]: com2 == com3 # 둘은 같다\nOut[4]: true\ntrue\n\n복합타입 변수의 필드에 접근하기 위해서는 . 를 사용합니다.\nIn [6]: c1 = Complex{Float64}(2.0, 3.0)\nOut[6]: 2.0 + 3.0im\n\nIn [7]: c1.re\nOut[7]: 2.0\n\nIn [8]: c1.im\nOut[8]: 3.0\n\nIn [9]: c1.im = 4.0\nERROR: setfield!: immutable struct of type Complex cannot be changed\n\n복합타입의 경우는 기본적으로 immutable 입니다. 즉 필드의 값을 직접적으로 바꿀 수 없으며 In [9] 에서와 같이 직접적으로 변경하고자 하면 에러가 발생합니다. 복합타입의 필드의 값을 바꿀 수 있는 복합타입은 mutable 이라고 하며 뒤에 변경할 수 있는 복합 타입 에서 다루겠습니다.\n\n\n\n\n복합 타입 선언 내부에서 정의된 생성자를 내부생성자 (inner constructor) 라고 하며 반대로 앞서의 Complex{T&lt;:Real} 처럼 생성자가 복합 타입 선언 밖에서 정의된 생성자를 외부 생성자 (outer constructor) 라고 합니다. 내부생성자에는 new 함수를 사용 할 수 있는데 new 함수는 생성자를 찾지 않고 즉각적으로 멤버에 접근하여 복합 타입을 만들게 해 줍니다. new 함수는 외부생성자에서는 사용 할 수 없습니다.\n코드 유지보수의 관점에서는 아무래도 외부생성자가 편리합니다. 그러나 내부생성자만이 할 수 있는 일은 기본생성자를 변경하는 것입니다. 다음의 예를 봅시다.\nstruct A\n    m::Int64\n    function A(x, y)\n        return new(Int64(x+y))\n    end\nend\n\nstruct B\n    m::Int64\nend\n\nfunction B(x, y)\n    return B(Int64(x+y))\nend\nA 와 B 는 모두 m 이라는 필드 하나만 가지고 있습니다. 이 때 B(3) 은 기본생성자가 호출되어 B.m==3 인 객체가 만들어지지만 A(3) 은 기본생성자가 교체되었으므로 에러가 발생합니다.",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "복합 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/09_composite_types.html#복합-타입",
    "href": "src/introduction_to_julia/09_composite_types.html#복합-타입",
    "title": "복합 타입",
    "section": "",
    "text": "복합 타입(composite type) 은 필드(field)라고 불리는 하위 변수를 갖는 타입이며, 필드는 정수나 실수 타입 뿐만 아니라 함수 타입이나 다른 복합 타입이 될 수 있습니다. 아주 간단한 복합 타입으로 2차원 평면 상의 점에 대한 복합타입을 다음과 같이 정의 할 수 있습니다.\nstruct Point\n    x\n    y\nend\n복합타입의 정의는 struct 로부터 시작하여 end 로 끝납니다. 위에서 Point 는 구체적 타입의 이름이 되며, x, y 라는 두개의 필드를 가질 수 있습니다.\nIn [2]: isconcretetype(Point)\nOut[2]: true\nPoint 타입의 변수는 p1 = Point(1, 2) 와 같이 생성할 수 있으며 각 필드는 p1.x, p1.y 와 같이 접근합니다.\nIn [3]: p1 = Point(1, 2)\nOut[3]: Point(1, 2)\n\nIn [4]: println(\"Point p1.x=$(p1.x), p1.y=$(p1.y)\")\nPoint p1.x=1, p1.y=2\n\nIn [5]: typeof(p1) # `Point` is a name of type\nOut[5]: Point\n복합 타입 인스턴스는 특별히 따로 정하지 않았다면 타입이름을 함수처럼 사용하여 생성합니다. 인자는 타입 정의에서 나열된 필드순으로 입력하면 됩니다. 즉 p1=Point(1, 2) 는 x 필드는 1, y 필드는 2 의 값을 갖는 Point 객체 인스턴스를 생성하라는 뜻입니다. 이렇게 타입 인스턴스를 만드는 함수를 생성자(constructor) 라고 합니다. 생성자는 별도로 정의할수도 있지만 위에서처럼 타입 이름을 함수로 사용하여 인자로 필드 값을 나열하는 생성자를 기본 생성자(default constructor) 라고 합니다.\n\n\n\n\n복합타입을 정의 할 때 아래와 같이 타입 매개 변수를 사용하여 정의 할 수 있습니다.\nstruct OneValue{T}\n    val::T\nend\nIn [8]: x=OneValue(3)\nOut[8]: OneValue{Int64}(3)\n\nIn [9]: y=OneValue{Float64}(4)\nOut[9]: OneValue{Float64}(4.0)\n\nIn [10]: typeof(x) == typeof(y)\nOut[10]: false\n\nIn [11]: typeof(x) == typeof(OneValue{Int64}(5))\nOut[11]: true\nstruct OneValue{T} 에서 OneValue 는 타입 이름이며 {T} 에서 {T} 가 타입에 대한 매개변수입니다. 타입에 대한 매개변수는 타입 이름일 수도 있으며 정수, 실수, Symbol 이나 Bool 과 같은 bit 타입의 값이 올 수 있습니다. 일단 매개변수로 받으면 필드의 정의나 생성자의 정의에서 사용 할 수 있습니다. 이 때 x 와 y 의 타입 즉 OneValue{Int64} 와 OneValue{Float64} 는 다른 타입입니다.\nIn [8] 을 봅시다. 매개변수 T 는 필드 val 의 타입으로 정의되었습니다. x=OneValue(3) 처럼 매개변수를 사용하지 않고 인스턴스를 만들면 val 의 타입이 자연스럽게 T 가 됩니다. In [9] 의 경우처럼 y=OneValue{Float64}(4) 와 같이 매개변수를 명시적으로 지정했을 경우에는 필드 val 의 타입이 T==Float64 로 강제로 변환됩니다.\n이렇게 타입 매개변수로 타입을 만들면 그 매개변수를 이후에도 사용 할 수 있습니다. 아래의 isIntType(o::OneValue{T}) 함수는 OneValue{T} 의 T 가 Integer 의 하위타입인지를 확인하는 함수입니다. 물론 o.val 의 타입을 확인할 수도 있지만 아래의 것이 훨씬 깔끔합니다.\nfunction isIntType(o::OneValue{T}) where T\n    if T&lt;:Integer\n        return true\n    else\n        return false\n    end\nend\nOut[13]: isIntType (generic function with 1 method)\n\nIn [14]: isIntType(x)\nOut[14]: true\n\nIn [15]: isIntType(y)\nOut[15]: false\n\n\n\n\n이제 우선 우리에게 아마도 익숙할 복소수 타입을 봅시다. Julia 는 복소수를 다루기 위한 Complex{T} 타입을 내장하고 있습니다. Complex{T} 는 필드로 실수부와 허수부를 가지며 다음과 같이 정의됩니다.\nstruct Complex{T&lt;:Real} &lt;: Number\n    re::T\n    im::T\nend\n\nComplex(x::Real, y::Real) = Complex(promote(x,y)...)\nComplex(x::Real) = Complex(x, zero(x))\n\n&lt;:Number 를 통해 Complex 객체는 Number 의 하위타입으로 정의됩니다.\nComplex{T&lt;:Real} 은 매개변수 T 를 통해 re 와 im 필드의 타입을 제한합니다. T&lt;:Real 이며 re::T, im::T 이므로 두 필드 는 Real 의 동일한 하위타입이어야 합니다. 두 개 이상의 타입이 필요할 경우는 {T1&lt;:Real, T2&lt;:Integer} 와 같이 { } 안에 , 로 분리하여 나열하면 됩니다.\n생성자가 타입 정의 외부에 존재합니다. 이를 외부생성자라고 합니다.\n첫번째 생성자는 x 와 y 가 Real 타입의 하위 타입일 때 타입을 일치시키기 위한 생성자입니다. promote(x, y) 는 x 와 y 변수의 타입을 두 변수를 공통적으로 표현할 수 있는 타입으로 변환시켜 튜플로 반환합니다. 이렇게 다른 타입의 둘 이상의 값을 같은 타입이 되도록 변환하는 것을 julia 에서는 promotion 이라고 합니다. promote(2, 3.0) == (2.0, 3.0) 입니다. 그런데 Complex(promote(2, 3.0)) 은 Complex(2.0, 3.0) 이 아니라 Complex((2.0, 3.0)) 으로 튜플 인자 하나만 주어지며, 따라서 에러가 발생합니다. Complex(promote(2, 3.0)...) 는 promote(2, 3.0) 의 결과로 주어지는 튜플을 풀어서 함수의 인자로 넣도록 합니다. 즉, Complex(promote(2, 3.0)...) 은 결과적으로 Complex(2.0, 3.0) 입니다. 함수를 실행시킬때 인자에서의 사용법 을 참고하시기 바랍니다.\n두번째 생성자는 인자가 하나만 주어졌을 때 im 필드를 인자 re 필드와 같은 타입의 0 으로 간주하여 생성하도록 하는 생성자입니다.\n\nComplex{T&lt;:Real} 은 다음과 같이 사용 할 수 있습니다.\nIn [1]: com1 = Complex{Float32}(3.3, 2.3) #Float32 타입의 필드를 갖는 복소수\nOut[1]: 3.3f0 + 2.3f0im\n\nIn [2]: com2 = Complex(3.3, 2.3) # 3.3, 2.3 이 Float64 이므로 타입의 필드를 갖는 복소수\nOut[2]: 3.3 + 2.3im\n\nIn [3]: com3 = 3.3 + 2.3im # 복소수를 선언하는 두번째 방법\nOut[3]: 3.3 + 2.3im\n\nIn [4]: com2 == com3 # 둘은 같다\nOut[4]: true\ntrue\n\n복합타입 변수의 필드에 접근하기 위해서는 . 를 사용합니다.\nIn [6]: c1 = Complex{Float64}(2.0, 3.0)\nOut[6]: 2.0 + 3.0im\n\nIn [7]: c1.re\nOut[7]: 2.0\n\nIn [8]: c1.im\nOut[8]: 3.0\n\nIn [9]: c1.im = 4.0\nERROR: setfield!: immutable struct of type Complex cannot be changed\n\n복합타입의 경우는 기본적으로 immutable 입니다. 즉 필드의 값을 직접적으로 바꿀 수 없으며 In [9] 에서와 같이 직접적으로 변경하고자 하면 에러가 발생합니다. 복합타입의 필드의 값을 바꿀 수 있는 복합타입은 mutable 이라고 하며 뒤에 변경할 수 있는 복합 타입 에서 다루겠습니다.\n\n\n\n\n복합 타입 선언 내부에서 정의된 생성자를 내부생성자 (inner constructor) 라고 하며 반대로 앞서의 Complex{T&lt;:Real} 처럼 생성자가 복합 타입 선언 밖에서 정의된 생성자를 외부 생성자 (outer constructor) 라고 합니다. 내부생성자에는 new 함수를 사용 할 수 있는데 new 함수는 생성자를 찾지 않고 즉각적으로 멤버에 접근하여 복합 타입을 만들게 해 줍니다. new 함수는 외부생성자에서는 사용 할 수 없습니다.\n코드 유지보수의 관점에서는 아무래도 외부생성자가 편리합니다. 그러나 내부생성자만이 할 수 있는 일은 기본생성자를 변경하는 것입니다. 다음의 예를 봅시다.\nstruct A\n    m::Int64\n    function A(x, y)\n        return new(Int64(x+y))\n    end\nend\n\nstruct B\n    m::Int64\nend\n\nfunction B(x, y)\n    return B(Int64(x+y))\nend\nA 와 B 는 모두 m 이라는 필드 하나만 가지고 있습니다. 이 때 B(3) 은 기본생성자가 호출되어 B.m==3 인 객체가 만들어지지만 A(3) 은 기본생성자가 교체되었으므로 에러가 발생합니다.",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "복합 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/09_composite_types.html#다양한-복합-타입",
    "href": "src/introduction_to_julia/09_composite_types.html#다양한-복합-타입",
    "title": "복합 타입",
    "section": "2 다양한 복합 타입",
    "text": "2 다양한 복합 타입\n\n변경할 수 있는 복합 타입 (mutable struct)\n앞서 언급했듯이 복합타입은 기본적으로 immutable 입니다. 이 말은 한 번 생성된 복합타입의 필드의 값을 바꿀 수 없다는 뜻입니다. 필드의 값을 바꿀 수 있는 복합타입은 struct 앞에 mutable 키워드를 넣습니다.\nmutable struct mycomplex2{T&lt;:Real} &lt;: Number\n    re::T\n    im::T\nend\n\nmycomplex2(x::Real, y::Real) = mycomplex2(promote(x, y)...)\nmycomplex2(x::Real) = mycomplex2(x, zero(x))\n위의 mycomplext2 타입을 생성하고 필드의 값을 바꿀 수 있습니다.\nIn [4]: c2 = mycomplex2(2.0, 3.0)\nOut[4]: mycomplex2{Float64}(2.0, 3.0)\n\nIn [5]: c2.im\nOut[5]: 3.0\n\nIn [6]: c2.im = -3\nOut[6]: -3\n\nIn [7]: c2\nOut[7]: mycomplex2{Float64}(2.0, -3.0)\n\n\n\n싱글톤 타입\n어떤 타입의 인스턴스가 단 하나만 존재할 수 있을 때 이를 싱글톤(singleton) 객체라고 합니다. 예를 들어 Complex(3.0, 4.0) 과 Complex(1.0, 2.0) 은 모두 Complex{Float64} 타입의 서로 다른 인스턴스입니다. 그러나 싱글톤 타입이라면 모든 타입 인스턴스가 같아야 합니다. Julia 에서 싱글톤 타입은 필드가 없는 복합타입입니다.\nstruct mysingleton end\n와 같이 정의합니다. 이 때 모든 mysingleton 타입의 인스턴스는 동일합니다.\nIn [1]: struct mysingleton end;\n\nIn [2]: a, b = mysingleton(), mysingleton();\n\nIn [3]: a===b\nOut[3]: true\n타입 매개변수를 가지는 싱글턴 타입도 존재합니다.\nstruct mysingleton1{T} end\n와 같이 정의합니다. 이 때 T 가 다르면 다른 인스턴스이며, T 가 같으면 같은 인스턴스입니다.\nIn [5]: struct mysingleton1{T} end\n\nIn [6]: c, d = mysingleton1{Int64}, mysingleton1{Int64}\nOut[6]: (mysingleton1{Int64}, mysingleton1{Int64})\n\nIn [7]: c === d\nOut[7]: true\n\nIn [8]: c, d = mysingleton1{Int64}, mysingleton1{Float64}\nOut[8]: (mysingleton1{Int64}, mysingleton1{Float64})\n\nIn [9]: c === d\nOut[9]: false\n\nIn [10]: c == d\nOut[10]: false\n\n당연히 어떤 추상 타입의 하위 타입으로서의 싱글턴 타입도 정할 수 있습니다.\nabstract type AbsSingletonType end\n\nstruct abstype1 &lt;: AbsSingletonType end\n\nJulia 에서 싱글턴 타입은 아주 많이 사용됩니다. 우선 아주 많이 사용하는 nothing 은 Nothing 타입의 싱글턴 객체입니다. 또한 julia 에서의 함수는 추상타입 Function 의 하위타입인 싱글턴 객체입니다.\nIn [15]: typeof(sin)\nOut[15]: typeof(sin) (singleton type of function sin, subtype of Function)\n당신이 당신의 코드 내에서 어떤 유일한 것을 원한다면 그것을 싱글턴 객체로 만들 수 있습니다. 또 하나 중요한것은 싱글턴 객체는 저장공간을 차지하지 않습니다.\n\n\n\n매개변수를 갖는 추상 타입\n우리는 추상적 타입 에 대해 이미 알아보았습니다. 매개변수를 갖는 추상적 타입도 존재합니다. 다음과 같이 선언합니다.\nabstract type PAType{T} end     # parametric abstract type\n\nstruct PCType{T} &lt;: PAType{T}   # parametric concrete type\n    field::T\nend\n이렇게 되면 PCT{T} 는 같은 T 에 대해서만 PAType{T} 의 하위 타입 이 됩니다.\nIn [3]: PCType{Float32} &lt;: PAType{Float32}\nOut[3]: true\n\nIn [4]: PCType{Float32} &lt;: PAType{Int64}\nOut[4]: false\n\n이제 다음과 같은 타입 구조를 봅시다.\nabstract type AA end\n\nabstract type AB{T&lt;:Real} &lt;: AA end\n\nstruct AC{T} &lt;: AB{T}\n    f::T\nend\nAC{T} 의 상위 타입이 AB{T&lt;:Real} 이므로 T 는 Real 의 하위 타입이어야만 합니다. 따라서 AC{String} 로 타입을 정할 수 없습니다. 또한 메서드를 정의할 때 AA 타입으로 인자를 정하면 모든 AC{T} 타입에 대해 사용 할 수 있습니다.\nIn [5]: qad(x::AA) = x.f+3\nOut[5]: qad (generic function with 1 method)\n\nIn [6]: qad(AC{Float32}(4))\nOut[6]: 7.0f0",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "복합 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/09_composite_types.html#연습-모듈러-산술",
    "href": "src/introduction_to_julia/09_composite_types.html#연습-모듈러-산술",
    "title": "복합 타입",
    "section": "3 연습 : 모듈러 산술",
    "text": "3 연습 : 모듈러 산술\n이제 지금까지 했던 것을 가지고 뭔가 좀 고차원적인 일을 해 봅시다. 정수를 다루는 수학의 분야를 정수론이라고 하며 여기서 모듈러 산술이라는 것을 다룹니다. 8 을 5로 나누면 나머지가 3이며 33 도 5로 나누면 나머지가 3입니다. 이것을 다음과 같이 표현합니다.\n\\[\n8 \\equiv 33 \\, (\\textrm{mod}\\, 5)\n\\]\n이것은 8 과 33 은 5로 나눈 나머지가 같다는 뜻입니다.두 정수 \\(a,\\,b\\) 와 자연수 \\(n\\) 에 대해\n\\[\na \\equiv b \\, (\\textrm{mod}\\, n)\n\\]\n은 \\(a\\) 와 \\(b\\) 는 \\(n\\) 으로 나누었을 때의 나머지와 같다는 입니다. 재미있는 것은 이 관계를 이용하여 사칙연산을 할 수 있다는 것입니다. \\(a \\equiv b \\, (\\textrm{mod}\\, n)\\), \\(c \\equiv d\\, (\\textrm{mod}\\, n)\\) 일 때 다음이 성립합니다.\n  (\\(1\\)) \\((a+c) \\equiv (b+d)\\, (\\textrm{mod}\\, n)\\).\n  (\\(2\\)) \\((a-c) \\equiv (b-d)\\, (\\textrm{mod}\\, n)\\).\n  (\\(3\\)) \\(ac \\equiv bd\\, (\\textrm{mod}\\, n)\\).\n  (\\(4\\)) \\(n\\) 이 소수이면 \\(ax \\equiv 1\\, (\\textrm{mod}\\, n)\\) 인 자연수 \\(x\\) 가 존재한다.\n\\(n\\) 이 소수가 아니더라라도 \\(a\\) 와 \\(n\\) 의 최대공약수가 \\(1\\) 이라면, 즉 \\(\\gcd(a,\\, n)=1\\) 이면 \\(ax\\equiv 1\\, (\\textrm{mod}\\, n)\\) 인 \\(x\\) 가 존재하지만 모든 수에 대해 존재하는 것은 아닙니다. \\(n\\) 이 소수일 경우에는 \\(n\\) 보다 작은 모든 자연수 \\(a\\) 에 대해 \\(\\gcd (a,n)=1\\) 이므로 (\\(4\\)) 가 성립합니다. 이 때 \\(x = a^{-1}\\) 이라고 하고 나누기를 \\(b/a := ba^{-1}\\) 로 정의 할 수 있습니다. 그렇다면 소수인 \\(n\\) 에 대해 \\(a^{-1}\\) 값은 어떻게 계산할까요? 그리고 주어진 \\(a\\) 에 대해 \\(ax \\equiv 1 \\, (\\text{mod}\\, n)\\) 인 \\(x\\) 는 오직 하나일까요? 일단 뒤의 문제부터 답하자면 소수 \\(n\\) 에 대해 \\(a^{n-1} \\equiv 1\\, (\\text{mod}\\, n)\\) 이라는 것이 알려져 있습니다\\(^1\\). 따라서 \\(a^{-1} \\equiv a^{n-2}\\, (\\textrm{mod}\\, n)\\) 이다. 또한 \\(ax\\equiv 1\\, (\\textrm{mod}\\, n),\\, ay\\equiv 1\\, (\\textrm{mod}\\, n)\\) 이면 \\(n\\) 이 소수일 때 \\(x \\equiv y\\, (\\textrm{mod}\\, n)\\) 입니다.\\(^1\\) 이를 페르마의 소정리(Fermat’s little theorem) 이라고 합니다.\n이렇게 어떤 자연수(\\(n\\)) 에 대한 나머지로 사칙연산을 수행하는 것을 모듈러 산술(modular arithematic) 이라고 합니다. \\(n\\) 이 소수가 아니라면 덧셈 뺄셈, 곱셈만 정의되며 나눗셈은 정의 할 수 없지만 \\(n\\) 이 소수라면 모두 정의 할 수 있습니다.\n이제 이 모듈러 산술에 대한 자료형과 함수를 만들어 봅시다. \\(n\\) 이 소수인 경우와 소수가 아닌 경우를 구분해야 하기 때문에 소수를 판별하는 함수를 작성해야 합니다. \\(n\\) 이 매우 큰 수가 아니라면 가장 간단하게 사용할 수 있는 알고리즘은 \\(2\\) 부터 \\(\\sqrt{n}\\) 보다 크지 않은 모든 정수에 대해 \\(n\\) 과의 최대공약수가 1 인지를 확인하는 것입니다.\nconst max_modular = 1_000_000_000\n\nfunction isprime(v::Integer)\n    @assert 1&lt;v&lt;max_modular \n    result = true\n    for x in 2:floor(Int64, √v)\n        if v % x == 0\n            result = false\n            break\n        end\n    end\n    return result\nend\nmax_modular 는 \\(n\\) 값이 될 수 있는 최대값으로 정합니다. 너무 큰 수에 대해 계산하는 것을 방지하기 위한 것 말고는 큰 의미가 없습니다.\n우선 최상위의 추상 타입 (코드에서는 AbstractMod{T, N}) 과 \\(n\\) 이 소수일 때, 그리고 소수가 아닐 때를 구별하여 타입을 만듭니다. 각각 PrimeMod 와 Mod 입니다. 값은 여러 정수의 타입을 가질수 있어야 하기 때문에 타입 매개변수 T 를 사용합니다. 더불어 \\(n\\) 값도 복합타입의 매개변수 N 으로 넣습니다.\nabstract type AbstractMod{T, N} end \n\nconst max_modular = 1_000_000_000\n\nfunction isprime(v::Integer)\n    @assert 1&lt;v&lt;max_modular \n    result = true\n    for x in 2:floor(Int64, √v)\n        if v % x == 0\n            result = false\n            break\n        end\n    end\n    return result\nend\n\nstruct PrimeMod{T, N} &lt;: AbstractMod{T, N}\n    value::T\n    \n    function PrimeMod{T, N}(x::Integer) where {T&lt;:Integer, N}\n        @assert N &gt; 1 \"Modulos must be larger than 1\"\n        @assert isprime(N) \"Must be a prime number\"\n        r = (x ≥ 0) ? x%N : (x%N)+N \n        return new{T, N}(r)\n    end\nend\n\nstruct Mod{T, N} &lt;: AbstractMod{T, N}\n    value::T\n\n    function Mod{T, N}(x::Integer) where {T&lt;:Integer, N}\n        @assert N &gt; 1 \"Modulos must be larger than 1\"\n        x = T(x)\n        r = (x ≥ 0) ? x%N : (x%N)+N \n        if isprime(N)\n            return PrimeMod{T, N}(r)\n        else \n            return new{T, N}(r)\n        end\n    end\nend\n\nMod{N}(x::Integer) where {N} = Mod{Int64, N}(x)\nPrimeMod{N}(x::Integer) where {N} = PrimeMod{Int64, N}(x)\n\n\nfunction Base.show(io::IO, x::AbstractMod{T, N}) where {T, N} \n    println(io, \"$(x.value)_$N\")\nend\n\nBase.zero(a::AbstractMod{T, N}) where {T, N}  = Mod{T, N}(0)\nBase.one(a::AbstractMod{T, N}) where {T, N}  = Mod{T, N}(1)\nBase.:-(a::AbstractMod{T, N}) where {T, N}  = Mod{T, N}(-a.value)\nBase.:isequal(a::AbstractMod{T, N}, b::AbstractMod{T, N}) where {T, N} = (a.value == b.value)\n\nfunction Base.:+(a::AbstractMod{T, N}, b::AbstractMod{T, N}) where {T, N} \n    return Mod{T, N}(a.value+b.value)\nend\n\nfunction Base.:-(a::AbstractMod{T, N}, b::AbstractMod{T, N}) where {T, N}  \n    return Mod{T, N}(a.value-b.value)\nend\n\nfunction Base.:*(a::AbstractMod{T, N}, b::AbstractMod{T, N}) where {T, N}  \n    return Mod{T, N}(a.value*b.value)\nend\n\nfunction Base.:inv(a::PrimeMod{T, N}) where {T, N} \n    return Mod{T, N}(a.value^(N-2))\nend\n\nfunction Base.:^(a::AbstractMod{T, N}, n::Integer) where {T, N} \n     return Mod{T, N}(a.value^n)\nend\n\nfunction Base.:/(a::PrimeMod{T, N}, b::PrimeMod{T, N}) where {T, N} \n    if b == zero(b)\n        throw(DivideError)\n    end\n    return a*inv(b)\nend\nMod 와 PrimeMod 둘 다 에게 적용되는 메서드는 AbstractMod 타입을 인자로 받으며 PrimeMod 에만 적용되는 나머지나 곱셈의 역원(Base.:inv) 함수의 경우 인자를 PrimeMod 타입을 받도록 합니다.\n이것은 NAJ.jl 에 포함되어 있으며 다음과 같이 사용합니다.\nIn [2]: using NAJ\n\nIn [3]: a=Mod{13}(5)\nOut[3]: 5_13\n\n\nIn [4]: b=-a\nOut[4]: 8_13\n\nIn [5]: a+b\nOut[5]: 0_13\n\nIn [6]: a*b\nOut[6]: 1_13\n\n\nIn [7]: a^5\nOut[7]: 5_13\n\nIn [8]: a^-2\nOut[8]: 12_13",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "복합 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/07_module_package.html",
    "href": "src/introduction_to_julia/07_module_package.html",
    "title": "이름공간, 모듈, 패키지",
    "section": "",
    "text": "프로그래밍할 때에는 많은 변수, 함수, 자료형의 이름이 필요합니다. 보통은 이름이 중복된다면 에러가 발생하거나 나중에 나오는 것이 앞에 나온 것을 삭제시키고 그 자리를 대신하게 되는데 이것은 큰 문제를 발생시킬 수 있습니다. 이런 것을 막기 위해 중복되지 않은 이름을 사용해야 하지만 코드가 길어지면 이것도 아주 골치아픈 일이 될 수 있습니다. 그래서 많은 프로그래밍 언어들이 이름공간(namespace)과 변수가 유효한 범위를 구현합니다. Julia 에서 이름공간은 뒤에 설명할 모듈(module) 마다 생성됩니다. Julia 가 실행될 때 Main 모듈로 실행되며, julia REPL 이나 Jupyter 에서도 Main 이 최상위 모듈입니다.",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "이름공간, 모듈, 패키지"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/07_module_package.html#이름-공간과-변수의-범위",
    "href": "src/introduction_to_julia/07_module_package.html#이름-공간과-변수의-범위",
    "title": "이름공간, 모듈, 패키지",
    "section": "",
    "text": "프로그래밍할 때에는 많은 변수, 함수, 자료형의 이름이 필요합니다. 보통은 이름이 중복된다면 에러가 발생하거나 나중에 나오는 것이 앞에 나온 것을 삭제시키고 그 자리를 대신하게 되는데 이것은 큰 문제를 발생시킬 수 있습니다. 이런 것을 막기 위해 중복되지 않은 이름을 사용해야 하지만 코드가 길어지면 이것도 아주 골치아픈 일이 될 수 있습니다. 그래서 많은 프로그래밍 언어들이 이름공간(namespace)과 변수가 유효한 범위를 구현합니다. Julia 에서 이름공간은 뒤에 설명할 모듈(module) 마다 생성됩니다. Julia 가 실행될 때 Main 모듈로 실행되며, julia REPL 이나 Jupyter 에서도 Main 이 최상위 모듈입니다.",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "이름공간, 모듈, 패키지"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/07_module_package.html#모듈",
    "href": "src/introduction_to_julia/07_module_package.html#모듈",
    "title": "이름공간, 모듈, 패키지",
    "section": "2 모듈",
    "text": "2 모듈\n모듈은 어떤 기능과 관련된 값, 함수, 자료형 등의 모음입니다. 추상적인 개념이 아닌 julia 에 그 문법이 정의된 기능으로 아래의 예제 코드와 같이 module 로 시작해서 end 로 끝납니다. 모듈 안에는 다른 모듈이 포함 될 수 있습니다. 하나의 파일에 여러개의 모듈이 같이 있을 수도 있습니다.\nmodule mymodule1\n\nexport a, mf\na=2\nb=3\nfunction mf(x)\n    return x*2\nend\n\nend\n앞서 설명했듯이 모듈은 새로운 전역적인 이름공간을 만들 수 있습니다. 그 안에서 정의된 이름들은 다른 이름공간의 이름과 충돌할 염려 없이 사용 할 수 있습니다. 다른 이름공간에서 모듈의 이름을 사용하기 위해서는 우선 모듈 내에서 export 명령어를 통해 밖에서 사용 할 수 있는 이름을 지정해 줘야 합니다. 예를 들어\nIn [1]: module mymodule1\n        export a, mf\n        a=2\n        b=3\n        function mf(x)\n            return x*2\n        end\n        end\nOut[1]: Main.mymodule1\n이 모듈은 REPL 이 실행될 때 만들어지는 Main 이라는 전역적인 이름공간 내에 mymodule1 이라는 이름이 붙은 부분적인 이름공간을 만듭니다. 부분적 이름공간의 이름에 접근할 때는 . 으로 구분하여 Main.mymodule1.a 와 같이 접근하거나 전역적 이름공간을 제외한 mymodule1.a 와 같이 접근합니다. 예를 들어\nIn [2]: mymodule1.mf(3)\nOut[2]: 6\n는 mymodule1 모둘의 함수 mf 를 의미합니다.\n\n\nusing\nusing 명령어는 module 에서 export 명령어를 통해 지정한 이름들을 전역적 이름공간에서 사용 할 수 있게 해 줍니다.\nIn [6]: using .mymodule1\n\nIn [7]: a\nOut[7]: 2\n\nIn [8]: mf(3)\nOut[8]: 6\n\nIn [9]: mymodule1.b\nOut[9]: 3\n\nIn [10]: b\nERROR: UndefVarError: `b` not defined\nexport 를 통해 지정되지 않은 b 는 전역 이름공간에서 사용 할 수 없으며 굳이 접근하고자 하면 mymodule1.b 와 같이 접근해야 합니다.\n\n\n\nimport\nusing 명령어는 모듈 내의 이름을 전역적인 이름공간으로 가져오는데 비해 import 명령어는 모듈 이름만을 전역적인 이름공간으로 가져옵니다. 즉 import mymodule1 을 하면 mymodule1.a 나 mymodule1.mf 를 통해 접근해야 합니다. 그렇다면 단순히 REPL 에서 사용할 때는 차이가 없게 됩니다. 이 차이를 알기 위해 다음과 같은 내용을 mymodule.jl 파일로 저장합니다.\nmodule mymodule1\nexport a, mf\na=2\nb=3\nfunction mf(x)\n    return x*2\nend\nend\n\nmodule mymodule2\nexport b, mf\na=4\nb=5\nfunction mf(x)\n    return x*a*b\nend\n두 모듈 모두 mf 란 함수가 존재하며 export 되므로 충돌의 가능성이 있습니다.. 이제 julia REPL 에서 모듈이 있는 파일을 읽고 mf 함수를 실행시켜 봅니다.\nIn [1]: include(\"mymodule.jl\")\nOut[1]: Main.mymodule2\n\nIn [2]: using .mymodule1\n\nIn [3]: mf(1)\nOut[3]: 2\nIn [2] 에서는 mymodule1 모듈만을 반입했으므로 mf 함수는 mymodule1 모듈의 그것입니다.\nIn [4]: using .mymodule2\nWARNING: using mymodule2.mf in module Main conflicts with an existing identifier.\n\nIn [5]: b\nOut[5]: 5\n\nIn [6]: mf(3)\nOut[6]: 6\nusing .mymodule2 를 하면 충돌이 발생하기 때문에 julia 인터프리터는 경고합니다. b 는 mymodule2 에서 반입된 5 가 사용되며 mf 함수는 먼저 반입된 mymodule1 의 그것입니다. 이렇게 이름이 충돌하는 것은 중요한 오류를 발생시킬 수 있으므로 절대로 피해야 합니다. 이런 경우에는 import 를 사용하는 것이 하나의 방법입니다. 아래와 같이 import 다음에 . 을 앞에 붙이고 모듈 이름을 써서 반입하면 모듈 이름과 모듈 내의 이름을 . 으로 구분하여 사용 할 수 있습니다.\nIn [1]: include(\"mymodule.jl\")\nOut[1]: Main.mymodule2\n\nIn [2]: import .mymodule1\n\nIn [3]: import .mymodule2\n\nIn [4]: mymodule1.mf(1)\nOut[4]: 2\n\nIn [5]: mymodule2.mf(2)\nOut[5]: 40\n\n\n\nusing ... as, import ... as\n또 하나의 방법은 이름을 바꾸는 것입니다. usimg .mymodule1: a as a1, mf as mf1 이라고 하면 mymodule1 모듈의 a 를 전역적인 이름영역으로 반입하면서 그 이름을 a1 으로 바꾸며, mf 를 mf1 으로 이름을 바꿉니다. 이름울 바꾸지 않고 반입할 경우는 as ... 없이 이름만 쓰면 됩니다. 아래 코드의 In [2] 처럼 하면 됩니다.\nIn [1]: include(\"mymodule.jl\")\nOut[1]: Main.mymodule2\n\nIn [2]: using .mymodule1: a, mf as mf1\n\nIn [3]: a\nOut[3]: 2\n\nIn [4]: mf\nERROR: UndefVarError: `mf` not defined\n...\n\nIn [5]: mf1\nOut[5]: mf (generic function with 1 method)\n\nIn [6]: using .mymodule2:b, mf as mf2\n\nIn [7]: b\nOut[7]: 5\n\nIn [8]: mf2(a)\nOut[8]: 40\n\nIn [9]: mf1(1)\nOut[9]: 2\n이름을 바꾸는 것은 이름의 중복을 방지하는데도 사용되지만, 긴 이름을 짧게 해서 편리하게 쓰고자 할 경우나, 짧은 이름을 명확하게 하기위해 긴 이름으로 바꿀 때도 사용할 수 있습니다.",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "이름공간, 모듈, 패키지"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/07_module_package.html#변수의-범위",
    "href": "src/introduction_to_julia/07_module_package.html#변수의-범위",
    "title": "이름공간, 모듈, 패키지",
    "section": "3 변수의 범위",
    "text": "3 변수의 범위\n모듈을 통해 이름공간과 다른 이름공간을 현재의 이름공간으로 반입하는 법을 알아보았습니다. 이름공간 내에서 사용 할 수 있는 변수를 전역적(global) 이라고 합니다. 반대로 이름공간 내의 특정 부분에서만 사용할 수 있는 변수를 지역적(local) 이라고 합니다. 변수가 유효한 지역적인 범위를 만들어 낼 수 있는 코드 영역을 블럭 (block)이라고 합시다. 대표적으로 함수를 정의하는 function ... end 구문이나 흐름 제어문인 for ... end 구문입니다. 이들은 그 내에서만 유효한 변수를 선언 할 수 있습니다.\n이제 이름 공간 내에서 변수의 범위를 알아봅시다. 아래 코드를 수행하기 전에 i 와 j 라는 변수를 할당하지 않았다고 합시다.\nfor i in 1:10\n    j=i+1\nend\n이 때 i 나 j 는 for ... end 블럭 밖에서는 접근 할 수 없으며, 접근하려고 하면 ERROR: UndefVarError 에러가 발생합니다.\n그러나 아래 코드와 같이 미리 j 변수를 정해둔 경우에는 j 변수는 for ... end 블럭 안에서 그대로 적용됩니다.\nj=0\nfor i in 1:10\n    j=i+1\nend\nprintln(\"j=$j\")\n\n이젠 함수의 경우를 봅시다.\nIn [1]: j=4\nOut[1]: 4\n\nIn [2]: function mf1(x)\n        k = x+j\n        return k\n        end\nOut[2]: mf1 (generic function with 1 method)\n\nIn [3]: mf1(5)\nOut[3]: 9\n\nIn [4]: k\nERROR: UndefVarError: `k` not defined\n위의 코드에서 j 는 전역적 범위에서 4 를 할당받았습니다\\(^\\ast\\). mf1 이라는 함수 안의 k 라는 변수는 함수 내부에만 영항을 끼칠 수 있습니다. 그러나 j 는 전역변수이므로 함수 내의 j 는 함수 밖의 j 와 동일합니다. \\(^\\ast\\) 함수 내에서 인자로 주어지지 않은 함수 밖의 변수를 사용하는 것은 대부분의 경우 피해야 할 습관입니다. 이 경우는 무조건 인자로 전달해서 함수에서 처리해야 하지만, 변수 범위를 설명하기 위해 억지로 예를 든 것입니다.\n\nIn [4]: function mf2(x)\n        k = x+1\n            function mf3(y)\n                return (k+1)\n            end\n            return mf3(x+1)\n        end\n\nOut[4]: mf2 (generic function with 1 method)\n\nIn [5]: mf2(3)\nOut[5]: 5\nmf2 함수 정의 안에서는 새로운 지역적 변수들을 정의 할 수 있으며 mf3 는 mf2 안에서 더 지역적인 변수들을 만들 수 있습니다. k 는 mf2 함수 내에서 정의되었기 때문에 mf3 함수 정의 내에서 사용 할 수 있습니다. 이렇게 변수의 범위는 계층적입니다. 최상위에 전역적인 이름들이 있으며, 그 하위 범위마다 지역적인 변수를 사용 할 수 있습니다. 하위의 블럭에서는 상위의 변수를 사용 할 수 있습니다. 필요하다면 지역적 블럭에서 전역적인 혹은 상위의 블럭의 변수와 같은 이름을 갖지만 별도로 동작하는 이름을 만들 수 있습니다\\(^\\ast\\).  하지만 혼동을 일으키며, 이러한 혼동은 에러의 큰 원인이 되기 때문에 되도록이면 피해야 할 것입니다.\\(^\\ast\\) 이렇게 상위 이름공간에서 정의된 이름을 하위 이름공간에서 별도로 사용할 때, 해당하는 상위 이름공간의 이름의 효과를 일시적으로 멈추는 것을 shadowing 이라고 합니다.\n\n\n영역 타입\n전역적 혹은 지역적 범위의 변수를 생성 할 수 있는 블럭은 다음과 같습니다.\n\n\n\n\n\n\n\n\nConstruct\n영역 타입\n혀용되는 이름공간\n\n\n\n\nmodule, baremodule\n전역\n전역\n\n\nstruct\n지역 (soft)\n전역\n\n\nfor, while, try\n전역, 지역 (soft)\n전역\n\n\nmacro\n지역 (hard)\n전역\n\n\nfunctions, do 블럭, let 블럭, comprehensions, generators\n지역 (hard)\n전역, 지역\n\n\n\n여기에 빠진 begin 블럭과, if 블럭은 영역 변수를 만들 수 없습니다. 즉 이 두 블럭 내에서 변수를 선언하더라도 상위 영역의 변수에 포함됩니다.\n상위 범위의 이름은 하위 범위에서 사용 할 수 있습니다. 문제는 상위 범위에 있는 이름과 같은 이름을 하위 범위에서 사용할 때 이며 크게 두가지로 나눌 수 있겠습니다.\n\n상위 범위 변수를 그대로 사용하고 싶을 때.\n상위 변수와 같은 이름을 가진 변수를 별도로 하위 범위에서 사용하고 싶을 때.\n\n2번의 경우는 굳이 상위 변수와 같은 이름을 사용한다기 보다는, 상위 범위에 많은 변수명과 연산이 얽혀 있는데 그것을 일일이 확인하고 싶지 않을 때에 발생한다고 볼 수 있겠습니다. 이때는 local 을 사용하면 되는데 이후 설명하겠습니다.\n상위 범위에서 v=1 이라고 이름을 할당 했다고 합시다. 하위 범위에서 v=2 라고 변수를 명시적으로 할당 했다면 하위 이름공간의 영역에서는 v==2 이며 상위 이름공간의 v 는 가려집니다. 그런데 변수에 값을 할당 하지 않고 w=v+2 와 같이 v 의 값을 사용 할 때의 성질에 따라 hard scope 와 soft scope 로 나뉩니다.\n\nHard scope 의 경우 : 해당 하위 이름공간에 지역적 범위의 변수 v 가 생성됩니다.\n\nIn [1]: v=1\nOut[1]: 1\n\nIn [2]: function myfunc1(x)\n            println(\"in myfunc1, v+x=\", v+x)\n        end\nOut[2]: myfunc1 (generic function with 1 method)\n\nIn [3]: function myfunc2(x)\n            v=3 # local variable 이 생성됩니다. shadowing !!\n            println(\"in myfunc1, v=3, v+x=\", v+x)\n        end\nOut[3]: myfunc2 (generic function with 1 method)\n\nIn [4]: myfunc1(3)\nin myfunc1, v+x=4\n\nIn [5]: myfunc2(3)\nin myfunc1, v=3, v+x=6\n\nIn [6]: v\nOut[6]: 1\n\nSoft scope 의 경우\n\nJulia REPL 이나 jupyter 와 같이 interactive mode 일 경우에는 상위 범위의 변수 v 가 할당됩니다.\nInteractive mode 가 아닐경우에는 경고가 출력되며 하위 범위의 변수 v 가 생성됩니다.\n\n\n\n\n연습문제 1 for ... end 는 soft scope 입니다. 아래의 코드를 파일로 저장하고 julia 로 실행시켜보고 어떤 경고(Warning) 가 출력되는지 확인해 봅시다. Julia REPL 이나 jupyter 로 실행시켜 봅시다.\nv=10\nfor i in 1:10\n    v=i\nend\n\n\n\n\nlocal\n다음 코드를 봅시다.\nv1 = 0\nv2 = 3\nif v2 &lt; 5 \n    v1 = v2+1\n    x = sin(v1)\nend\n이미 v1=0 라고 선언되었으며 if 문의 분기조건을 충족하기 때문에 위 코드의 실행이 끝나면 v1=4 가 됩니다. 그런데 당신이 실제로 원하는 것은 v1 값을 바꾸는 것이 아니라 단지 sin(v2+1) 을 계산하는 것이었다고 합시다. 코드가 길거나 많은 변수가 복잡하게 계산되고 있다면 이런 일이 벌어질 수 있습니다. 이 때 변수 할당 앞에 local 키워드를 놓으면 이 변수는 더 상위 범위의 같은 이름의 변수와 내부적으로 다르게 처리하며, 상위 범위의 미리 선언된 변수의 값에 영향을 주지 않습니다. 즉\nv1 = 0\nv2 = 3\nif v2 &lt; 5 \n    local v1 = v2+1\n    x = sin(v1)\nend\n를 실행시키고 난 뒤에도 v1 == 0 입니다. local 키워드는 전역적으로 어떤 변수가 선언되었더라도 지역적인 변수를 만들어서 그 변수를 사용하며, 전역적인 변수는 건드리지 않도록 합니다.",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "이름공간, 모듈, 패키지"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/07_module_package.html#패키지",
    "href": "src/introduction_to_julia/07_module_package.html#패키지",
    "title": "이름공간, 모듈, 패키지",
    "section": "4 패키지",
    "text": "4 패키지\n패키지는 모듈들과 모듈들을 관리하고 테스트하기위한 여러 파일들의 모음입니다. 공식적으로 지원되는 패키지들은 https://juliapackages.com 에서 확인 할 수 있습니다.\nJulia 를 설치하면 기본적으로 많은 자료형과 함수들도 같이 설치되지만 이것만으로는 충분하지 않습니다. 어떤 패키지는 Julia 언어와 함께 제공되며, 어떠 패키지는 패키지 관리자 Pkg.jl 을 이용하여 설치할 수 있습니다. Julia 의 패키지들은 Github 저장소에서 관리됩니다.\n\n패키지 추가\n패키지를 추가하는 방법은 두가지가 있습니다. 우선은\nusing Pkg\n를 실햄합니다. Pkg 는 패키지를 관리해주는 패키지로 기본적으로 julia 에 포함된 패키지 입니다. using Pkg 는 이제 Pkg 패키지에 포함된 여러 값, 함수, 자료형 등을 사용수 있도록 julia 에게 준비하라는 뜻입니다. 패키지 설치는 Pkg.add 함수를 사용합니다. 예를 들어 코드의 수행을 분석해주는 BenchmarkTools 를 설치한다면\nPkg.add(\"BenchmarkTools\")\n를 실행시키면 됩니다. 보통 하나의 패키지는 다른 패키지를 필요로 하는데 이 필요성 관계를 의존성(dependency) 이라고 합니다. Julia 는 자동적으로 이 패키지를 설치하는데 필요한 다른 패키지도 설치합니다. 패키지 설치가 성공하면\nusing BenchmarkTools\n명령문을 통해 BenchmarkTools 패키지의 여러 기능을 사용 할 수 있습니다.\n\n\n\n패키지 update\n보통 널리 사용되는 패키지는 끊임없이 개선됩니다. 이것을 update 라고 하며\nPkg.update()\n명령어는 이미 설치된 패키지 전체를 자동적으로 업데이트 합니다. 설치된 패키지가 많으면 몇분 정도의 시간이 걸릴 수도 있습니다.\n\n\n\n패키지 제거\nBenchmarkTools 패키지를 제거할때는 Pkg.rm(\"BenchmarkTools\") 명렬어를 수행하면 됩니다. 만약 제거하고자 하는 패키지에 의존하는 다른 패키지가 존재한다면 제거 할 수 없습니다. 억지로 제거할 수는 있지만 추천하지 않습니다. 다른 패키지를 먼저 제거하고 제거하십시요.\n\n\n\n패키지의 사용\n앞의 모듈의 사용과 마찬가지로 using 혹은 import 명령문을 사용합니다.",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "이름공간, 모듈, 패키지"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html",
    "href": "src/introduction_to_julia/05_control_flows.html",
    "title": "흐름 제어",
    "section": "",
    "text": "컨테이너를 순회하며 컨테이너에 포함된 아이템 만큼의 어떤 일을 수행하기 위한 구문입니다. 또한 컨테이너의 각 아이템을 이용한 계산과 명령을 수행 할 수 있습니다. 예를 들어 아래는 1 부터 100 까지의 합을 구하는 코드인데 for i ∈ 1:100 은 StepRange 타입인 1:100 의 각 성분들을 순서대로 i 라는 변수로 받아 end 까지의 명령을 수행한다는 의미입니다. 여기서 ∈ 는 in 으로 대체할 수 있습니다.\nnsum = 0\nfor i ∈ 1:100\n    nsum+= i\nend\n같은 크기의 컨테이너를 zip 명령어로 묶어서 동시에 순회할 수도 있습니다.\naa=(\"a\", \"b\", \"c\", \"d\")\nfor (a, v) in zip(aa, 1:4)\n    println(\"$a, $v\")\nend\n그 결과는 아래와 같습니다.\na, 1\nb, 2\nc, 3\nd, 4\n\nenumerate() 함수를 통해 인덱스 와 포함된 아이템을 같이 순회할 수도 있습니다다.\nfor (i, v) in enumerate(aa)\n    println(\"Index = $i, value = $v\")\nend\nIndex = 1, value = a\nIndex = 2, value = b\nIndex = 3, value = c\nIndex = 4, value = d\n\n사전 타입의 경우 key 와 value 를 다음과 같이 순회할 수 있습니다. 사전은 순서가 없으므로, 아래와 같은 경우에는 key 와 value 가 나오는 순서는 임의적이라고 생각해야 합니다.\ndict1 = Dict(\"a\"=&gt;1, \"b\"=&gt;2, \"c\"=&gt;3.3)\nfor (k, v) in dict1\n    println(\"Key = $k, value = $v\")\nend\nKey = c, value = 3.3\nKey = b, value = 2\nKey = a, value = 1\n\n컨테이너에 포함된 아이템의 수만큼 1부터 순회하고 싶다면 eachindex() 를 사용할 수 있습니다.\nfor i in eachindex((\"a\", \"b\", \"c\", \"d\"))\n    println(i)\nend\n\n\n\n구구단을 for 문을 써서 출력한다면 우선 다음과 같이 코드를 짤 수 있습니다.\nfor i in 2:9 \n    for j in 1:9\n        println(\"$i x $j = $(i*j)\")\n    end\nend\n하나의 for 문마다 하나의 end 가 필요합니다. Julia 는 다중 루프를 한 줄에 처리할 수 있게 해 줍니다. 아래의 코드는 위의 코드와 같은 일을 합니다.\nfor i in 2:9, j in 1:9\n    println(\"$i x $j = $(i*j)\")\nend",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "흐름 제어"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html#for-...-end",
    "href": "src/introduction_to_julia/05_control_flows.html#for-...-end",
    "title": "흐름 제어",
    "section": "",
    "text": "컨테이너를 순회하며 컨테이너에 포함된 아이템 만큼의 어떤 일을 수행하기 위한 구문입니다. 또한 컨테이너의 각 아이템을 이용한 계산과 명령을 수행 할 수 있습니다. 예를 들어 아래는 1 부터 100 까지의 합을 구하는 코드인데 for i ∈ 1:100 은 StepRange 타입인 1:100 의 각 성분들을 순서대로 i 라는 변수로 받아 end 까지의 명령을 수행한다는 의미입니다. 여기서 ∈ 는 in 으로 대체할 수 있습니다.\nnsum = 0\nfor i ∈ 1:100\n    nsum+= i\nend\n같은 크기의 컨테이너를 zip 명령어로 묶어서 동시에 순회할 수도 있습니다.\naa=(\"a\", \"b\", \"c\", \"d\")\nfor (a, v) in zip(aa, 1:4)\n    println(\"$a, $v\")\nend\n그 결과는 아래와 같습니다.\na, 1\nb, 2\nc, 3\nd, 4\n\nenumerate() 함수를 통해 인덱스 와 포함된 아이템을 같이 순회할 수도 있습니다다.\nfor (i, v) in enumerate(aa)\n    println(\"Index = $i, value = $v\")\nend\nIndex = 1, value = a\nIndex = 2, value = b\nIndex = 3, value = c\nIndex = 4, value = d\n\n사전 타입의 경우 key 와 value 를 다음과 같이 순회할 수 있습니다. 사전은 순서가 없으므로, 아래와 같은 경우에는 key 와 value 가 나오는 순서는 임의적이라고 생각해야 합니다.\ndict1 = Dict(\"a\"=&gt;1, \"b\"=&gt;2, \"c\"=&gt;3.3)\nfor (k, v) in dict1\n    println(\"Key = $k, value = $v\")\nend\nKey = c, value = 3.3\nKey = b, value = 2\nKey = a, value = 1\n\n컨테이너에 포함된 아이템의 수만큼 1부터 순회하고 싶다면 eachindex() 를 사용할 수 있습니다.\nfor i in eachindex((\"a\", \"b\", \"c\", \"d\"))\n    println(i)\nend\n\n\n\n구구단을 for 문을 써서 출력한다면 우선 다음과 같이 코드를 짤 수 있습니다.\nfor i in 2:9 \n    for j in 1:9\n        println(\"$i x $j = $(i*j)\")\n    end\nend\n하나의 for 문마다 하나의 end 가 필요합니다. Julia 는 다중 루프를 한 줄에 처리할 수 있게 해 줍니다. 아래의 코드는 위의 코드와 같은 일을 합니다.\nfor i in 2:9, j in 1:9\n    println(\"$i x $j = $(i*j)\")\nend",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "흐름 제어"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html#while-...-end",
    "href": "src/introduction_to_julia/05_control_flows.html#while-...-end",
    "title": "흐름 제어",
    "section": "2 while ... end",
    "text": "2 while ... end\nwhile 이후에 조건이 오고 그 조건이 참이면 end 까지 실행합니다. 1 부터 100 까지의 합을 구하는 코드를 while ... end 를 이용하여 구현해 봅시다.\nnsum = 0\nnn = 1\nwhile nn&lt;=100\n    nsum += nn\n    nn += 1\nend\nwhile ... end 를 쓸 때 조심할 것은 종료조건이 충족되지 않는 것입니다. for ... end 의 경우는 정해진 수의 컨테이너의 아이템만을 순회하므로 어쨌든 무조건 종료되지만 while ... end 의 경우는 종료되지 않는 무한루프에 빠질 수 있습니다.\n\n\n루프에서 벗어나기\n루프 수행 도중 벗어나고자 할 때는 break 를 씁니다. 예를 들어 1, 1/2, 1/3 과 같이 자연수의 역수를 계속 곱하다가 1/10000 보다 작아지는 첫번째 자연수를 구한다면, 1 부터 충분히 큰 수 (그 역수가 1/10000 보다 작은 수를 선택 할 수도 있다) 까지 루프를 수행하고 그 누적곱이 1/10000 보다 작을 때 break 로 루플에서 빠져나오면 됩니다.\nresult = 1.0\nfor n in 1:10000\n    result *=(1/n)\n    if result &lt; 1.0/10000\n        print(\"$n is the value\")\n        break\n    end\nend\nbreak 는 전체 루프에서 벗어나는 것이 아니라 break 를 포함하는 가장 인접한 루프로부터만 벗어납니다. 예를 들어,\nfor i in 1:10\n    for j in 1:10\n        println(\"i=$i, j=$j\")\n        if j &gt; 5\n            break\n        end\n    end\nend\n코드의 break 는 j&gt;5 일 때 break 되며, i 루프는 벗어나지 못하고 1 부터 10 까지 진행됩니다. 그러나,\nfor i in 1:10, j in 1:10\n    println(\"i=$i, j=$j\")\n    if j &gt; 5\n        break\n    end\nend\n는 i=1, j=6 에서 break 되어 멈춥니다.",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "흐름 제어"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html#if-분기문",
    "href": "src/introduction_to_julia/05_control_flows.html#if-분기문",
    "title": "흐름 제어",
    "section": "3 if 분기문",
    "text": "3 if 분기문\n어떤 조건이 충족되는 지 여부를 따질 때 if ... elseif ... end 구문을 사용합니다. 어떤 수 x 에 대해 x&gt;0 이면 1 을 x&lt;0 이면 -1 을, x=0 이면 0 을 리턴하는 함수 msign(x) 를 만들어 봅시다.\nfunction msign(x)\n    if x&gt;zero(x)\n        return one(x)\n    elseif x&lt;zero(x) \n        return -one(x)\n    else\n        return zero(x)\n    end\nend\nzero(x) 는 x 의 타입에서의 0 값을 리턴하는 함수이며, one(x) 는 x 타입의 1 값을 리턴하는 함수입니다. x 는 어떤 값일 수도 있고 타입일 수도 있습니다. zero(1) 은 Int64 타입의 1 이며, one(Float32) 는 Float32 타입의 0.0 입니다. for, while 과 같이 if 블럭도 end 로 끝내야 합니다.\nif 블록에서 elseif 나 else 는 필요 없다면 생략해도 됩니다. 예를 들어 1 부터 100 까지의 정수 가운데 3의 배수만을 더한 합을 구한다고 하면,\nresult = 0\nfor i in 1:100\n    if i % 3 == 0\n        result += i\n    end\nend\n와 같이 사용 할 수 있습니다. i % 3 == 0 일 때만 result += i 를 수행하고 다른 경우는 아무 일도 수행하지 않습니다.",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "흐름 제어"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html#삼항-연산자-a-b-c",
    "href": "src/introduction_to_julia/05_control_flows.html#삼항-연산자-a-b-c",
    "title": "흐름 제어",
    "section": "4 삼항 연산자 a ? b : c",
    "text": "4 삼항 연산자 a ? b : c\na 는 true/false 를 따질 수 있는 조건이며, true 이면 b 를 실행시키고 false 이면 c 를 실행 시킵니다. 예를 들어, 절대값을 리턴하는 함수 mabs() 를 다음과 같이 짧게 구현 할 수 있습니다.\nmabs(x) = (x&gt;0) ? x : -x\n여기서 주의해야 할 것은 ? 와 : 각각의 앞, 뒤에 공백이 존재해야 한다는 것입니다. (x&gt;0)? x : -x 나 (x&gt;0)? x: -x 같은 것들은 에러를 발생시킵니다.",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "흐름 제어"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html#begin-...-end-블럭",
    "href": "src/introduction_to_julia/05_control_flows.html#begin-...-end-블럭",
    "title": "흐름 제어",
    "section": "5 begin ... end 블럭",
    "text": "5 begin ... end 블럭\nJulia 에서 한줄에 여러 명령을 처리하기 위해 ; 을 사용 할 수 있습니다. 예를 들어\nx=3;y=5;z=x+y\n는 세가지 명렁을 차례로 입력한 것과 같습니다. 이것을 begin ... end 블럭으로 묶을 수 있습니다.\nz = begin\n    x=3\n    y=5\n    x+y\nend",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "흐름 제어"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/02_variables_basic_types.html",
    "href": "src/introduction_to_julia/02_variables_basic_types.html",
    "title": "변수와 기본 타입",
    "section": "",
    "text": "많은 프로그래밍 언어처럼 변수에 어떤 값을 지정할 수 있습니다. 이것을 변수 할당이라고 하며 = 기호를 사용합니다. a 문자에 3 이라는 값을 값을 할당하고, 거기에 2 를 곱한 결과를 얻는 것은 다음과 같이 할 수 있습니다. 이 때 변수는 = 기호의 왼쪽에, 값은 오른쪽에 위치해야 합니다.\nIn [1]: a=3\nOut[1]: 2\n수학에서처럼 값이 할당된 변수는 계산에 사용되거나 함수에 인자로 사용 될 수 있습니다.\nIn [2]: a*2\nOut[2]: 6\n\nIn [3]: abs(a)\nOut[3]: 3\n변수에 할당 될 수 있는 것은 수(number) 뿐만이 아닙니다. 앞으로 배울 거의 모든 것이 변수에 할당 될 수 있습니다. 예를 들어 sin(x) 은 짐작 할 수 있듯이 x 에 대한 sin 함수값을 반환하는 함수입니다. 그런데 myfunc = sin 하면 어떻게 될까요?\nIn [1]: myfunc = sin\nOut[1]: sin (generic function with 14 methods)\n\nIn [2]: myfunc(π)\nOut[2]: 0.0\n\nIn [3]: myfunc(2π)\nOut[3]: -2.4492935982947064e-16\nmyfunc 가 sin 함수가 되어 버렸습니다. 이것에 대해 길게 이야기 할 수 있겠지만 일단은 함수도 변수에 할당 될 수 있다는 것을 알아두면 좋겠습니다.\n\n\n\n\n변수 이름에는 제한이 있습니다. 우선 첫문자는 알파벳 대문자(A-Z) 혹은 소문자(a-z) 나 밑줄 _ 혹은 00A0 보다 큰 유니코드 문자 가운데 특정 범주에 속하는 문자들이 와야 합니다. 유니코드 및 수학 기호 지원 를 참고하시기 바랍니다. 한글은 허용됩니다. 자세한 것은 julia 공식 문서 가운데 Variables 을 참고 하십시요. 두번째 글자부터는 첫번째 글자로 허용된 문자에 ! 나 숫자가 올 수 있습니다.\nIn [4]: 파이 = π\nOut[4]: π = 3.1415926535897...\n\nIn [5]: 2*파이\nOut[5]: 6.283185307179586\n\nIn [6]: 맑뚫 = 3; 맑뚫*3\nOut[6]: 9\n\n앞서 유니코드 및 수학 기호 지원 에서 언급했듯이 π 나 ℯ 는 이미 값이 지정되어 있습니다. 그 외의 θ(\\theta + [tab]), φ(\\varphi + [tab]), ϕ(\\phi + [tab]), Γ(\\Gamma + [tab]) 와 같이 수학, 과학, 공학에서 많이 사용되는 기호들을 변수로 사용 할 수 있습니다.\nIn [1]: θ = π/4; cos(θ)\nOut[1]: 0.7071067811865476",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "변수와 기본 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/02_variables_basic_types.html#변수",
    "href": "src/introduction_to_julia/02_variables_basic_types.html#변수",
    "title": "변수와 기본 타입",
    "section": "",
    "text": "많은 프로그래밍 언어처럼 변수에 어떤 값을 지정할 수 있습니다. 이것을 변수 할당이라고 하며 = 기호를 사용합니다. a 문자에 3 이라는 값을 값을 할당하고, 거기에 2 를 곱한 결과를 얻는 것은 다음과 같이 할 수 있습니다. 이 때 변수는 = 기호의 왼쪽에, 값은 오른쪽에 위치해야 합니다.\nIn [1]: a=3\nOut[1]: 2\n수학에서처럼 값이 할당된 변수는 계산에 사용되거나 함수에 인자로 사용 될 수 있습니다.\nIn [2]: a*2\nOut[2]: 6\n\nIn [3]: abs(a)\nOut[3]: 3\n변수에 할당 될 수 있는 것은 수(number) 뿐만이 아닙니다. 앞으로 배울 거의 모든 것이 변수에 할당 될 수 있습니다. 예를 들어 sin(x) 은 짐작 할 수 있듯이 x 에 대한 sin 함수값을 반환하는 함수입니다. 그런데 myfunc = sin 하면 어떻게 될까요?\nIn [1]: myfunc = sin\nOut[1]: sin (generic function with 14 methods)\n\nIn [2]: myfunc(π)\nOut[2]: 0.0\n\nIn [3]: myfunc(2π)\nOut[3]: -2.4492935982947064e-16\nmyfunc 가 sin 함수가 되어 버렸습니다. 이것에 대해 길게 이야기 할 수 있겠지만 일단은 함수도 변수에 할당 될 수 있다는 것을 알아두면 좋겠습니다.\n\n\n\n\n변수 이름에는 제한이 있습니다. 우선 첫문자는 알파벳 대문자(A-Z) 혹은 소문자(a-z) 나 밑줄 _ 혹은 00A0 보다 큰 유니코드 문자 가운데 특정 범주에 속하는 문자들이 와야 합니다. 유니코드 및 수학 기호 지원 를 참고하시기 바랍니다. 한글은 허용됩니다. 자세한 것은 julia 공식 문서 가운데 Variables 을 참고 하십시요. 두번째 글자부터는 첫번째 글자로 허용된 문자에 ! 나 숫자가 올 수 있습니다.\nIn [4]: 파이 = π\nOut[4]: π = 3.1415926535897...\n\nIn [5]: 2*파이\nOut[5]: 6.283185307179586\n\nIn [6]: 맑뚫 = 3; 맑뚫*3\nOut[6]: 9\n\n앞서 유니코드 및 수학 기호 지원 에서 언급했듯이 π 나 ℯ 는 이미 값이 지정되어 있습니다. 그 외의 θ(\\theta + [tab]), φ(\\varphi + [tab]), ϕ(\\phi + [tab]), Γ(\\Gamma + [tab]) 와 같이 수학, 과학, 공학에서 많이 사용되는 기호들을 변수로 사용 할 수 있습니다.\nIn [1]: θ = π/4; cos(θ)\nOut[1]: 0.7071067811865476",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "변수와 기본 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/02_variables_basic_types.html#sec-primary_number_types",
    "href": "src/introduction_to_julia/02_variables_basic_types.html#sec-primary_number_types",
    "title": "변수와 기본 타입",
    "section": "2 기본적인 수 타입",
    "text": "2 기본적인 수 타입\n수(number) 를 포함하는 julia 에서 사용하는 모든 값(value) 은 타입(type) 을 갖습니다. 여기서는 julia 언어 자체에서 정의된 기본 타입 가운데 수(number) 에 관련된 타입은 아래와 같습니다.\n\n\n\n\n\n\n\n타입 종류\n타입들\n\n\n\n\n부호 없는 정수 타입\nUInt8, UInt16, UInt32, UInt64, UInt128\n\n\n정수 타입\nInt8, Int16, Int32, Int64, Int128, BigInt\n\n\n유리수 타입\nRational\n\n\n부동소수 타입\nFloat16, Float32, Float64, BigFloat\n\n\n무리수 타입\nIrrational\n\n\n복소수 타입\nComplex\n\n\n불 타입\nBool\n\n\n\n\n부호 없는 정수는 0 과 양의 정수를 말합니다.\n앞서 언급한 π (\\(\\pi\\), 원주율) 나 ℯ (\\(e\\), 자연로그의 밑) 는 무리수 타입으로, 연산할 때 가장 적절한 타입으로 변환되어 계산됩니다.\n타입 이름은 다른 타입의 값을 타입으로 변환시키는 함수처럼 사용 할 수 있습니다. Float64(1) 은 1 을 Float64 타입으로 변환시킵니다.\n실제 Julia 의 타입 구조는 이보다 훨씬 복잡합니다. 이후 타입 계층 구조 에서 좀 더 자세히 설명하도록 하겠습니다.\n\n\n어떤 변수나 값의 타입을 알기 위해서는 typeof() 함수를 사용 할 수 있습니다.\nIn [4]: typeof(UInt8(2))\nOut[4]: UInt8\n\n\n정수형 타입\n우선 부호 없는 정수타입, 정수타입, 부동소수 타입의 이름의 끝부분에 붙는 8, 16, 32, 64, 128 은 각 타입의 값이 차지하는 비트(bit) 수 입니다. 비트는 on/off 혹은 0/1 로 구분되는 정보 단위입니다. 예를 들어 UInt8 의 경우는 8개의 비트로 수를 표현합니다. 2진수로 00000000 은 0 이며 2진수 11111111 은 255 입니다. UInt8 은 이렇게 0 부터 255 까지의 값을 표현 할 수 있습니다. UInt64 는 64 개의 비트로 숫자를 저장하며, 따라서 0부터 264-1 까지의 숫자를 표현 할 수 있습니다.\nInt8 의 경우는 8비트로 정수를 저장하지만 한 비트는 음수/양수 를 구분하기 위해 사용됩니다. -128 부터 127 까지의 정수를 표현 할 수 있습니다. Int64 는 -232 부터 232-1 까지의 숫자를 표현 할 수 있습니다.\n\n\n\n타입\n부호\n비트수\n최소값\n최대값\n\n\n\n\nInt8\no\n8\n-27\n27 - 1\n\n\nUInt8\nx\n8\n0\n28 - 1\n\n\nInt16\no\n16\n-215\n215 - 1\n\n\nUInt16\nx\n16\n0\n216 - 1\n\n\nInt32\no\n32\n-231\n231 - 1\n\n\nUInt32\nx\n32\n0\n232 - 1\n\n\nInt64\no\n64\n-263\n263 - 1\n\n\nUInt64\nx\n64\n0\n264 - 1\n\n\nInt128\no\n128\n-2127\n2127 - 1\n\n\nUInt128\nx\n128\n0\n2128 - 1\n\n\nBool\nN/A\n8\nfalse (0)\ntrue (1)\n\n\n\n\nmyint=3 처럼 변수를 할당하면 시스템 마다 지정된 기본 타입으로 처리됩니다. 보통의 경우는 Int64 이며 시스템에 따라 Int32 나 다른 타입일 수 있습니다. 보통 Int 가 기본 정수형과 같은 의미로 사용되므로 다음과 같은 입력을 통해 기본 정수형을 알 수 있습니다.\nIn [1]: Int\nOut[1]: Int64\n긴 숫자를 표현할 때 혼란을 줄이는 방법으로 밑줄 _ 을 사용할 수 있습니다. 예를 들어 a=123_4567_89_12 는 밑줄을 없엔 a=12345678912 와 같습니다. 다만 밑줄을 두개 이상 동시에 사용 할 수는 없습니다.\nIn [2]: a=123_4567_89_12\nOut[2]: 12345678912\n\n\nOverflow\n타입이 허용하는 범위의 값을 넘어서는 값을 할당하려 할 때에는 에러가 발생합니다.\nIn [1]: a::UInt8 = 300\nERROR: InexactError: trunc(UInt8, 300)\n...\na::UInt8 = 300 은 UInt8 타입의 변수 a 에 값 300 을 할당하는 명령어입니다. 만얄 a::UInt8=2 라면 2 는 UInt8 범위 내의 수이기 때문에 문제가 발생하지 않지만 300 은 UInt8 의 범위를 벗어나기 떼문에 에러가 발생합니다. 아래의 경우는 에러가 발생되지 않고 틀린 결과가 나옵니다.\nIn [2]: b = UInt8(200)+UInt8(56)\nOut[2]: 0x00\n200 과 56 은 모두 UInt8 의 범위 안이지만 그 합 256 은 범위를 벗어납니다. 이렇게 정수 타입에서 범위를 넘어서는 값이 할당되거나 계산될 때 실제 계산되어야 할 값과는 다른 값이 나오는 것을 overflow 라고 합니다. 해결책은 연산을 잘 조작하여 타입의 범위 내에서 원하는 결과를 얻을 수 있게 하거나, 당신의 변수가 가질 수 있을 가능성이 있는 값을 모두 포함하는 타입을 쓰는 것 밖에는 없습니다. Overflow 시 결과가 어떻게 나오는 지 알고 싶다면 공식 매뉴얼의 Overflow behavior 를 참고하시기 바랍니다.\n\n\n\n\n부동소수 타입\n부동소수는 일반적인 실수 (real number) 를 표현하기 위한 타입으로 가장 많이 사용하며, 부동소수의 기본타입인 Float64 타입의 경우 fn1 = 3.33 나 fn2=2.3e-4 처럼 사용합니다. 후자의 경우는 2.3 × 10-4 와 같습니다. 그리고 e 대신 E 를 사용해도 됩니다. e 나 E 대신 f 를 사용하면 Float32 타입으로 지정됩니다.(F 는 사용 할 수 없습니다.) 2.3f0 의 경우는 Float32 타입의 2.3 을 의미하며 2.3f2 와 2.3f-2 의 경우는 각각 Float32 타입의 2.3 × 102 와 2.3 × 10-2 를 의미합니다. 부동정수형과 마찬가지로 숫자 사이에 밑줄을 넣어서 사용 할 수 있습니다. 혹은 정수에서와 같이 a::Float32=3.3 처럼 변수에 타입을 지정할 수 있습니다. 이 경우 할당되는 값이 지정된 타입(여기서는 Float32)으로 변환됩니다.\nIn [1]: 3.14_1592\nOut[1]: 3.141592\n\nIn [2]: c::Float32=3.3\nOut[2]: 3.3\n\nIn [3]: typeof(c)\nOut[3]: Float32\n\nIn [4]: c\nOut[4]: 3.3f0\n\n\n\n유리수 타입 (Rational) 과 복소수 타입 (Complex)\n유리수 타입은 두개의 정수 타입을 이용하여 하나는 분모, 하나는 분자로 사용하여 유리수를 표현합니다. 복소수 타입은 두개의 실수를 이용하여 하나는 실수부, 하나는 허수부로 사용하여 복소수를 표현합니다.\nRational 타입의 경우 // 연산자를 이용하거나 Rational(3, 4) 와 같이 할당합니다.. a=1//3 는 Rational(1, 3) 과 같고, a 라는 변수에 \\(\\frac{1}{3}\\) 을 저장합니다. 유리수값끼리의 혹은 유리수값과 정수의 사칙연산은 유리수가 되며, 자동적으로 약분하여 가장 간단한 값으로 처리됩니다.\nIn [1]: 6//5 + 1 # 유리수와 정수의 연산\nOut[1]: 11//5\n\nIn [2]: 1//2 + 1.0 # 유리수와 실수의 연산\nOut[2]: 1.5\n\nIn [3]: 27//12   # 유리수 입력은 자동으로 약분된다.\nOut[3]: 9//4\n\nIn [4]: 1//12 + 2//12 # 유리수 연산 후 약분된다.\nOut[4]: 1//4\n\nComplex 타입의 경우는 2.0 + 3.0im 혹은 Complex(2.0, 3.0) 과 같이 할당합니다. Julia 에서 im 은 \\(\\sqrt{-1}\\) 로 정의되었으며 i 나 j 와 같은 문자를 사용하지 않습니다. conj() 함수는 켤레복소수를 반환합니다.\nIn [7]: (1.0+1.0im)*(1.0-1.0im)\nOut[7]: 2.0 + 0.0im\n\nIn [8]: conj(Complex(1.0, 1.0))\nOut[8]: 1.0 - 1.0im\n\n\n\n불(Bool) 타입\n불(Bool) 타입은 참을 나타내는 true 와 거짓을 나타내는 false 의 두 값만을 표현하는 정수형 타입입니다. 수로 변환하면 true 는 1 이며 false 는 0 입니다. 거꾸로 수를 불 타입으로 변환하는 경우 1 혹은 1 과 같다고 평가되는 1.0f0 와 같은 수는 true 로 0 혹은 0 과 같다고 평가되는 0.0 은 false 로 변환됩니다. Python 과 같은 언어에서는 0 혹은 0 과 같다고 평가되는 수만 False 이고 나머지 수는 모두 True 로 평가됩니다.\nIn [1]: Bool(-3)\nERROR: InexactError: Bool(-3)\n...\n\nIn [2]: Bool(1.0)\nOut[2]: true\n\nIn [3]: Bool(1.0f0)\nOut[3]: true\n\nIn [4]: Bool(3//3)\nOut[4]: true\n\nIn [5]: Bool(0//1)\nOut[5]: false\n\n\n\n타입 확인\n변수의 값이 특정 타입인지를 비교해야 할 때 가장 간단하게 사용할 수 있는 함수는 isa 입니다. isa 는 함수이기도 하지만 연산자이기도 합니다.\nIn [1]: isa(3.3f0, Float32)   # isa 를 함수처럼 사용할 경우\nOut[1]: true\n\nIn [2]: 3.3f0 isa Float64     # isa 를 연산자처럼 사용할 경우\nOut[2]: false\n\n\n\n타입 변환\n앞서 언급했듯이 타입 이름은 그 타입으로 변환시키는 함수처럼 사용 할 수 있습니다.\nIn [5]: Float32(3.32)\nOut[5]: 3.32f0\n어떤 언어에서는 실수를 정수로 변환할 때 억지로라도 변환시켜주지만 julia 에서는 실수가 정수와 같지 않으면 에러가 발생합니다.\nIn [6]: Int64(2.0)\nOut[6]: 2\n\nIn [7]: Int64(2.001)\nERROR: InexactError: Int64(2.001)\n...\n이때는 반올림 (round), 내림(floor), 올림(ceil) 함수를 사용 할 수 있습니다. 이 함수들은 입력값의 타입으로 반올림한 값을 반환합니다. round(3.3) 처럼 사용해도 되지만 특정 정수 타입으로 변환할때는 ceil(UInt16, 4.2) 처럼 타입을 명시하여 변환해야 합니다.\nIn [8]: round(2.3)\nOut[8]: 2.0\n\nIn [9]: floor(4.3f0)\nOut[9]: 4.0f0\n\nIn [10]: ceil(UInt16, 4.2)\nOut[10]: 0x0005",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "변수와 기본 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/02_variables_basic_types.html#sec-char_and_string_types",
    "href": "src/introduction_to_julia/02_variables_basic_types.html#sec-char_and_string_types",
    "title": "변수와 기본 타입",
    "section": "3 문자와 문자열, 기호 타입",
    "text": "3 문자와 문자열, 기호 타입\n\nChar 와 String 타입\nChar 는 ascii 나 유니코드 하나의 문자에 대한 타입이며 String 은 하나 이상의 문자를 포함하는 문자열에 대한 타입입니다. Char 타입은 'a' 와 같이 따옴표 ' 로 감싸서 선언합니다. 한줄 문자열은 겹따옴표(\") 로 감싸고 여러줄 문자열은 겹따옴표 세개(\"\"\")로 감쌉니다. 문자열을 출력할때는 println 함수를 사용합니다. println 함수의 경우 인자를 , 로 분리하여 계속 써 주면 각각의 인자를 문자열로 변환하여 연결시켜 하나의 문자열을 출력합니다.\nIn [11]: char1='가'\nOut[11]: '가': Unicode U+AC00 (category Lo: Letter, other)\n\nIn [12]: str1 = \"Hello, world.\\n\"\nOut[12]: \"Hello, world.\\n\"\n\nIn [13]: str2 = \"\"\"Julia is\n                a good programing\n                language\"\"\"\nOut[13]: \"Julia is\\na good programing\\nlanguage\"\n\nIn [14]: println(str2)\nJulia is\na good programing\nlanguage\n\nIn [15]: println(1, \"ab\", \" c_d \", 3.3)\n1ab c_d 3.3\n문자열 내의 \\n 은 개행문자라고 해서 출력할 때 줄바꿈을 해 주는 문자입니다. asciii 는 컴퓨터 자판에서 보이는 숫자, 영어 알파벳과 기호를 포함하며 각 문자가 1바이트를 차지합니다. ascii 문자로 이루어진 문자열은 1부터 시작하는 인덱스로 접근 할 수 있습니다.\nIn [16]: str3 = \"I love Julia language !!!\"\nOut[16]: \"I love Julia language !!!\"\n\nIn [17]: str3[1], str3[end], str3[end-4]\nOut[17]: ('I', '!', 'e')\n인덱스에서 end 는 맨 마지막 인덱스를 의미하며 end-4 은 마지막에서 다섯번째 글자를 의미합니다. end-2 는 마지막에서 세번째입니다. 정확히 말하면 str3[3] 은 문자열 str3 에서 세번째 글자가 아니라 세번째 바이트에서 시작하는 문자를 의미합니다. ascii 에서는 각 문자가 1 바이트를 차지하기 때문에 세번째 바이트에서 시작하는 문자와 세번째 문자가 같지만 2 바이트 이상을 차지하는 문자에서는 다른 의미가 됩니다.\n\n\n\n유니코드(Unicode)\n유니코드(unicode) 는 전 세계의 모든 문자를 다룰 수 있도록 제정된 표준 문자 처리 방식입니다. 유니코드를 표기할때는 U+0A03 처럼 U+ 와 16진수의 결합으로 표현합니다. 앞서 언급한 Unicode Input 에 julia 에서 표현 할 수 있는 문자들이 나열되어있습니다.\n유니코드를 문자열로 표현할 때는 탭으로 완성되는 문자를 사용 할 수도 있고 다음처럼 \\u 혹은 \\U 로 시작되는 문자로 표현 할 수도 있습니다. \\u 다음에는 4개까지의 16진수 문자가 올 수 있으며 \\U 다음에는 8개까지의 16진수 문자가 올 수 있고 \\u 를 포함하여 더 많은 문자를 표현 할 수 있습니다. \\u 나 \\U 다음에 오는 숫자 가운데 자릿수를 차지하는 0 은 생략 할 수 있습니다. 예를 들어 \\u0033 은 \\u33 과 같습니다. 그리고 \\U000000 부터 \\U00FFFF 까지는 \\u0000 과 \\uffff 까지와 같습니다. 유니코드는 다음과 같이 사용합니다.\nIn [18]: unistr = \"\\u2200 x \\u2203 y\"\nOut[18]: \"∀ x ∃ y\"\nJulia 에서 유니코드는 UTF-8 로 인코딩 되어 있습니다. UTF-8 에서는 각 문자당 차지하는 바이트수가 다르기 때문에 ascii 와 같은 인덱스를 사용 할 수 없습니다. 앞서 설명했듯이 unistr[2] 는 문자열 unistr 의 2번째 바이트에서 시작하는 문자를 의미하는데 \\u2200 은 3 바이트 문자이므로 2번째 바이트에서 시작하는 문자가 없으므로 에러가 발생합니다.\nIn [19]: unistr[1]\nOut[19]: '∀': Unicode U+2200 (category Sm: Symbol, math)\n\nIn [20]: unistr[2]\nERROR: StringIndexError: invalid index [2], valid nearby indices [1]=&gt;'∀', [4]=&gt;' '\n...\n\nIn [21]: unistr[4]\nOut[21]: ' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n그렇다면 문자열의 \\(n\\) 번째 문자는 어떻게 추출할까요? 불편하긴 하지만 collect 함수를 사용할 수 있습니다. collect 함수는 문자열을 분리하여 배열(Array) 로 만듭니다. 즉 unistr[2] 는 문자가 아니지만 collect(unistr)[2] 는 unistr 문자열의 두번째 문자입니다.\n\n\n\n\n\n\n\n유니코드 문자열의 인덱스\n\n\n\n유니코드 문자열을 다룰 때 인덱스의 의미는 언어마다 다릅니다. 예를 들어 Python 에서는 인덱스 가 i 일 때 i 번째 문자를 의미합니다. 아래는 Python shell 에서 같은 일을 한 결과입니다. 참고로 julia 는 인덱스가 1부터 시작하지만 python 은 0 부터 시작하기 때문에 인덱스가 차이가 납니다.\n&gt;&gt;&gt; unistr = \"\\u2200 x \\u2203 y\"\n&gt;&gt;&gt; unistr\n'∀ x ∃ y'\n&gt;&gt;&gt; unistr[0]\n'∀'\n&gt;&gt;&gt; unistr[1]\n' '\n&gt;&gt;&gt; unistr[2]\n'x'\n\n\n\n\n\n문자열 연산과 함수\n\n결합과 반복\n문자열을 합칠 때는 * 연산자를 이용하거나 string() 함수를 이용하며, 여러번 반복할때는 ^ 연산자 나 repeat() 함수를 이용합니다. 실제로 string() 함수는 인자를 차례대로 문자열로 바꾸어 주는 함수입니다.\nIn [1]: \"가나다라\"*\"마바사\" # 문자열 합치기\nOut[1]: \"가나다라마바사\"\n\nIn [2]: string(\"가나다라\", \"abc\", 'π', 5) # 문자열 합치기\nOut[2]: \"가나다라abcπ5\"\n\nIn [3]: \"αβγ\"^3 # 문자열 반복\nOut[3]: \"αβγαβγαβγ\"\n\nIn [4]: repeat(\"Δ=\", 5) # 문자열 반복\nOut[4]: \"Δ=Δ=Δ=Δ=Δ=\"\n문자열의 길이는 length() 함수를 사용하며 문자열에 접근할 때는 str1[3] 과 같이 인덱스를 사용합니다. Julia 에서는 처음 인덱스는 0 이 아닌 1 입니다.\nIn [5]: str3=\"abcdefg\";str3[2]\nOut[5]: 'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n\n\n\n문자열 보간(Interpolation)\n문자열에 $ 기호를 통해 이미 정의된 변수를 사용하여 문자열을 구성 할 수 있습니다.\nIn [6]: aa=1;bb=22.2;cc=\"C12\";\n\nIn [7]: \"\"\"aa=$aa, bb=$bb, cc=$cc\"\"\"\nOut[7]: \"aa=1, bb=22.2, cc=C12\"\n보간 이전에 값을 평가해야 할 경우에는 괄호(( )) 안에 식을 넣을 수 있습니다. 예를 들어 \"$sin(π)\" 는 문자열 \"sin(π)\" 지만 \"$(sin(π))\" 는 sin(π) 를 평가한 0.0 이 문자열로 입력됩니다.\nIn [9]: \"$sin(π)\"\nOut[9]: \"sin(π)\"\n\nIn [10]: \"$(sin(π))\"\nOut[10]: \"0.0\"\n\n\n\n비교\n문자열을 사전순으로 비교 할 수 있습니다. 즉 'a' &lt; 'b' 이며 \"aa\" &lt; \"ab\" 입니다.\nIn [11]: \"abracadabra\" &lt; \"xylophone\"\nOut[11]: true\n\nIn [12]: \"abracadabra\" == \"xylophone\"\nOut[12]: false\n\nIn [13]: \"Hello, world.\" != \"Goodbye, world.\"\nOut[13]: true\n\nIn [14]: \"1 + 2 = 3\" == \"1 + 2 = $(1 + 2)\"\nOut[14]: true\n\n\n\n문자열 함수\nfindfirst(a, str) 은 문자열 str 에서 문자 혹은 문자열 a 가 나타는 첫번째 인덱스를 리턴합니다. findlast(a, str) 는 마지막 인덱스를 리턴합니다. findprev(a, str, i) 는 문자열 str 에서 문자 혹은 문자열 a 를 찾는데 인덱스 i 부터 앞으로 찾아가서 나오는 첫번째 인덱스를 반환합니다. findnext(a, str, i) 는 인덱스 i 부터 뒤로 찾아가서 나오는 첫번째 인덱스를 반환합니다. 네가지 경우 모두 찾지 못한다면 nothing 을 반환합니다. a 가 문자열일 경우는 a 와 일치하는 인덱스의 범위를 리턴합니다. 6:7 은 인덱스 6에서 인덱스 7 까지란 의미입니다. occursin(a, str) 은 문자 혹은 문자열 a 가 문자열 str 에 포함되어 있는지만을 확인하여 true 나 false 를 리턴합니다.\nIn [15]: findfirst('a', \"biography\")\nOut[15]: 6\n\nIn [16]: findfirst(\"ap\", \"biography\")\nOut[16]: 6:7\n\nIn [17]: occursin(\"gr\", \"biography\")\nOut[17]: true\n\nIn [18]: occursin(\"rp\", \"biography\")\nOut[18]: false\n\nrepeat(a, n) 은 문자열 a 를 n 번 반복한 문자열을 반환합니다. 여러 문자열을 결합할 때는 join() 함수를 사용합니다.\nIn [19]: repeat(\".:Z:.\", 10)\nOut[19]: \".:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:.\"\n\nIn [20]: join([\"apples\", \"bananas\", \"pineapples\"], \", \", \" and \")\nOut[20]: \"apples, bananas and pineapples\"\njoin 함수의 두번째 인자 \", \" 는 결합하는 문자열 사이에 \", \" 를 끼워 결합하라는 의미입니다. 세번째 인자 \" and \" 는 마지막 두 문자열을 결합할때는 \", \" 대신에 \" and \" 를 사용하라는 의미입니다. 자세한 것은 julia 의 공식 도움말을 참고하시기 바랍니다.\n\n\n\n\n심볼 타입\n심볼(Symbol) 타입은 문자열과 비슷하지만 다릅니다. 심볼(Symbol) 타입은 : 다음의 문자열, 혹은 Symbol 이라는 타입 이름을 함수로 사용하여 다음과 같이 선언할 수 있습니다.\nIn [21]: a=Symbol(\"bc\") # `Symbol` 함수를 이용한 선언\nOut[21]: :bc\n\nIn [22]: b=:bc # 콜론 `:` 을 이용한 선언\nOut[22]: :bc\n\nIn [23]: a==b # 두 선언은 같다.\nOut[23]: true\n심볼 타입은 Julia 에서 소위 메타 프로그래밍 개념의 핵심이지만 여기서는 자세히 다루지 않겠습니다. 심볼 타입이 많이 쓰이는 다른 경우는 함수에 인자로 전달할 때 입니다. 예를 들어 그래프를 빨간 색으로 그리고 싶을 때, 다른 언어라면 \"red\" 라는 문자열을 함수의 인자로 입력하는 경우가 많은데, Julia 에서는 이렇게 문자열을 쓸 수도 있지만 :red 라는 심볼 타입을 전달하는 경우가 많습니다. 이 경우 비교가 문자열보다 빠릅니다.\n\n\n\n변수의 타입 지정과 타입 유니온\n\n변수의 타입 지정\n예를 들어 변수 a 에 UInt8 타입의 3 을 할당한다고 해 봅시다. a=UInt8(3) 와 a::UInt8=3 과 같은 두가지 방법을 사용 할 수 있습니다. 그러나 두번째 경우에는 a 라는 변수가 UInt8 타입으로 지정되기 때문에 UInt8 타입 이외의 값으로 변경할 수 없습니다.\nIn [1]: a::UInt8=3\nOut[1]: 3\n\nIn [2]: a=4\nOut[2]: 4\n\nIn [3]: a=-1\nERROR: InexactError: trunc(UInt8, -1)\nStacktrace:\nIn [2] 에서는 4 가 UInt8 타입으로 a 에 저장됩니다. 그러나 UInt8 은 음수를 저장 할 수 없으므로 In [3] 의 입력은 에러를 냅니다. 그러나 b=UInt8(3) 과 같이 할당하면 a 변수에 대한 타입 제한은 없습니다.\nIn [4]: b=UInt8(3)\nOut[4]: 0x03\n\nIn [5]: b=-1\nOut[5]: -1\n\n\n\n타입 유니온\n타입 유니온은 변수가 가질 수 있는 타입을 하나가 아닌 여러개중 하나로 할 때 사용되며 Union{T1, T2} 처럼 사용됩니다. T1, T2 는 변수가 가질 수 있는 타입이며 두개 이상일 경우에는 , 로 구분하여 나열합니다. 다음 보기를 봅시다.\nIn [1]: a::Union{Int, AbstractString}=\"a\"\nOut[1]: \"a\"\n\nIn [2]: b::Union{Int, AbstractString}=3\nOut[2]: 3\n\nIn [3]: c::Union{Int, AbstractString, Nothing}=nothing\n\nIn [4]: (a, b, c)\nOut[4]: (\"a\", 3, nothing)\nIn [1] 의 경우는 입력값이 문자열이므로 a 는 문자열 타입이 되고, b 는 입력값이 정수이므로 정수 타입이 되었습니다. c 는 세가지 타입중에 선택하도록 하는 것입니다. 이런 방법 역시 일반적인 변수에 값을 할당할 때 보다 함수의 인자의 타입을 제한 할 때 사용됩니다. 그리고 nothing 은 값이고 Nothing 은 nothing 에 대한 타입입니다.",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "변수와 기본 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/04I_splat_operator.html",
    "href": "src/introduction_to_julia/04I_splat_operator.html",
    "title": "Interude : ... 연산자",
    "section": "",
    "text": "… 연산자 에서 튜플이나 배열의 첫번째 몇개만 취할 때 ... 연산자를 사용 할 수 있다는 것을 알아보았습니다. Julia 에서 ... 연산자는 두가지 용법으로 사용됩니다.\n\n\n\n튜플이나 StepRange 혹은 1차원 배열과 같이 순서가 있는 컨테이너에 대해서는 직관적으로 알 수 있습니다.\nIn [1]: a1, a2, a3... = (1, \"a\", (2, 3), 4, sin)\nOut[1]: (1, \"a\", (2, 3), 4, sin)\n\nIn [2]: a1, a2\nOut[2]: (1, \"a\")    \n\nIn [3]: b1, b2, b3... = 1:10\nOut[3]: 1:10\n\nIn [4]: b1, b2\nOut[4]: (1, 2)\n\nIn [5]: c1, c2, c3... = [1, 2, 3, 4, 5];\n\nIn [6]: c1, c2\nOut[6]: (1, 2)\n\n집합이나 사전과 같은 순서가 없는 컨테이너에 대해서는 에러를 발생시키지는 않지만 그 결과의 일관성을 보장할 수 없습니다.\nIn [14]: d1, d2, d3... = Set([1, 2, 3, 4]);\n\nIn [15]: d1, d2\nOut[15]: (4, 2)\n\nIn [16]: d1, d2, d3... = Set([1, 2, 3, 4, 5]);\n\nIn [17]: d1, d2\nOut[17]: (5, 4)\n\nIn [18]: a, b, c... = Dict(\"A\"=&gt;1, \"B\"=&gt;2, \"C\"=&gt;3, \"D\"=&gt;4)\nOut[18]: Dict{String, Int64} with 4 entries:\n  \"B\" =&gt; 2\n  \"A\" =&gt; 1\n  \"C\" =&gt; 3\n  \"D\" =&gt; 4\n\nIn [19]: a\nOut[19]: \"B\" =&gt; 2\n\nIn [20]: b\nOut[20]: \"A\" =&gt; 1\n\nIn [21]: c\nOut[21]: Base.Iterators.Rest{Dict{String, Int64}, Int64}(Dict(\"B\" =&gt; 2, \"A\" =&gt; 1, \"C\" =&gt; 3, \"D\" =&gt; 4), 4)\n\n다차원 배열의 경우 선형 인덱스에 따라 일차원 배열로 변환됩니다.\nIn [18]: x1, x2, x3... = [1 2;3 4; 5 6];\n\nIn [19]: x1\nOut[19]: 1\n\nIn [20]: x2\nOut[20]: 3\n\nIn [21]: x3\nOut[21]: 4-element Vector{Int64}:\n 5\n 2\n 4\n 6\n\n\n\n\n정해진 수의 인자를 받는 것이 아니라 다양한 수의 인자를 받는 함수를 가변 인자 함수 (function of variable number of arguments) 라고 하며 ... 연산자를 사용합니다. 다음을 봅시다.\nIn [6]: function ps(xs...)\n        println(typeof(xs))\n        return xs[1], xs[2]\n        end\nOut[6]: ps (generic function with 1 method)\n\nIn [7]: ps(1,2,3,\"c\")\nTuple{Int64, Int64, Int64, String}\nOut[7]: (1, 2)\n함수 정의에서 인자로 xs... 가 사용되었습니다. 이것은 인자를 모두 xs 라는 변수의 튜플로 받는다는 뜻입니다. 즉 In [7] 에서 함수 내부적으로 인자는 (1, 2, 3, \"c\") 입니다. 일부의 인자에 대해서만 사용할 경우에는 다음과 같습니다.\nIn [9]: function ps2(x1, xs...)\n        return xs[1], xs[2]\n        end\nOut[9]: ps2 (generic function with 1 method)\n\nIn [10]: ps2(1,2,3,4,5,6)\nOut[10]: (2, 3)\n키워드 인자도 역시 ... 를 사용하여 받을 수 있습니다. 다음의 함수를 봅시다. 예를 들어,\nfunction ps3(xs...;vs...)\n   ...         \nend\n와 같은 함수는 키워드가 없는 인자들은 xs 라는 변수의 튜플로, 키워드로 제시된 인자들은 vs 라는 기명 튜플(NamedTuple) 인자로 받습니다.\nIn [6]: function ps3(xs...; vs...)\n        return vs\n        end\nOut[6]: ps3 (generic function with 1 method)\n\nIn [7]: ps3(color=\"red\", number=4, location=\"Daejeon\")\nOut[7]: pairs(::NamedTuple) with 3 entries:\n  :color    =&gt; \"red\"\n  :number   =&gt; 4\n  :location =&gt; \"Daejeon\"\n\n\n\n\n함수의 정의에서는 인자를 튜플로 묶는다면 함수를 사용할 때는 컨테이너를 풉니다. 예를 들어,\nIn [12]: function ps3(a1, a2, a3)\n         return a1+(a2*a3)\n         end\n와 같은 함수를 사용해야 한다고 합시다. 그런데 다른 함수의 계산 결과로 aa=(a1, a2, a3) 를 얻었다고 합시다. ps3(aa[1], aa[2], aa[3]) 와 같이 실행 시킬 수도 있지만\nIn [13]: aa=(2, 3, 4)\nOut[13]: (2, 3, 4)\n\nIn [14]: ps3(aa...)\nOut[14]: 14\n처럼 ps3 함수를 실행 시킬 때 인자로 a... 를 쓰면 튜플이 풀려서 ps3(aa[1], aa[2], aa[3]) 를 실행시킨 것과 같게됩니다.",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "Interude : `...` 연산자"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/04I_splat_operator.html#sec-splat_operator_for_containers",
    "href": "src/introduction_to_julia/04I_splat_operator.html#sec-splat_operator_for_containers",
    "title": "Interude : ... 연산자",
    "section": "",
    "text": "튜플이나 StepRange 혹은 1차원 배열과 같이 순서가 있는 컨테이너에 대해서는 직관적으로 알 수 있습니다.\nIn [1]: a1, a2, a3... = (1, \"a\", (2, 3), 4, sin)\nOut[1]: (1, \"a\", (2, 3), 4, sin)\n\nIn [2]: a1, a2\nOut[2]: (1, \"a\")    \n\nIn [3]: b1, b2, b3... = 1:10\nOut[3]: 1:10\n\nIn [4]: b1, b2\nOut[4]: (1, 2)\n\nIn [5]: c1, c2, c3... = [1, 2, 3, 4, 5];\n\nIn [6]: c1, c2\nOut[6]: (1, 2)\n\n집합이나 사전과 같은 순서가 없는 컨테이너에 대해서는 에러를 발생시키지는 않지만 그 결과의 일관성을 보장할 수 없습니다.\nIn [14]: d1, d2, d3... = Set([1, 2, 3, 4]);\n\nIn [15]: d1, d2\nOut[15]: (4, 2)\n\nIn [16]: d1, d2, d3... = Set([1, 2, 3, 4, 5]);\n\nIn [17]: d1, d2\nOut[17]: (5, 4)\n\nIn [18]: a, b, c... = Dict(\"A\"=&gt;1, \"B\"=&gt;2, \"C\"=&gt;3, \"D\"=&gt;4)\nOut[18]: Dict{String, Int64} with 4 entries:\n  \"B\" =&gt; 2\n  \"A\" =&gt; 1\n  \"C\" =&gt; 3\n  \"D\" =&gt; 4\n\nIn [19]: a\nOut[19]: \"B\" =&gt; 2\n\nIn [20]: b\nOut[20]: \"A\" =&gt; 1\n\nIn [21]: c\nOut[21]: Base.Iterators.Rest{Dict{String, Int64}, Int64}(Dict(\"B\" =&gt; 2, \"A\" =&gt; 1, \"C\" =&gt; 3, \"D\" =&gt; 4), 4)\n\n다차원 배열의 경우 선형 인덱스에 따라 일차원 배열로 변환됩니다.\nIn [18]: x1, x2, x3... = [1 2;3 4; 5 6];\n\nIn [19]: x1\nOut[19]: 1\n\nIn [20]: x2\nOut[20]: 3\n\nIn [21]: x3\nOut[21]: 4-element Vector{Int64}:\n 5\n 2\n 4\n 6",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "Interude : `...` 연산자"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/04I_splat_operator.html#sec-splat_operator_in_function_definition",
    "href": "src/introduction_to_julia/04I_splat_operator.html#sec-splat_operator_in_function_definition",
    "title": "Interude : ... 연산자",
    "section": "",
    "text": "정해진 수의 인자를 받는 것이 아니라 다양한 수의 인자를 받는 함수를 가변 인자 함수 (function of variable number of arguments) 라고 하며 ... 연산자를 사용합니다. 다음을 봅시다.\nIn [6]: function ps(xs...)\n        println(typeof(xs))\n        return xs[1], xs[2]\n        end\nOut[6]: ps (generic function with 1 method)\n\nIn [7]: ps(1,2,3,\"c\")\nTuple{Int64, Int64, Int64, String}\nOut[7]: (1, 2)\n함수 정의에서 인자로 xs... 가 사용되었습니다. 이것은 인자를 모두 xs 라는 변수의 튜플로 받는다는 뜻입니다. 즉 In [7] 에서 함수 내부적으로 인자는 (1, 2, 3, \"c\") 입니다. 일부의 인자에 대해서만 사용할 경우에는 다음과 같습니다.\nIn [9]: function ps2(x1, xs...)\n        return xs[1], xs[2]\n        end\nOut[9]: ps2 (generic function with 1 method)\n\nIn [10]: ps2(1,2,3,4,5,6)\nOut[10]: (2, 3)\n키워드 인자도 역시 ... 를 사용하여 받을 수 있습니다. 다음의 함수를 봅시다. 예를 들어,\nfunction ps3(xs...;vs...)\n   ...         \nend\n와 같은 함수는 키워드가 없는 인자들은 xs 라는 변수의 튜플로, 키워드로 제시된 인자들은 vs 라는 기명 튜플(NamedTuple) 인자로 받습니다.\nIn [6]: function ps3(xs...; vs...)\n        return vs\n        end\nOut[6]: ps3 (generic function with 1 method)\n\nIn [7]: ps3(color=\"red\", number=4, location=\"Daejeon\")\nOut[7]: pairs(::NamedTuple) with 3 entries:\n  :color    =&gt; \"red\"\n  :number   =&gt; 4\n  :location =&gt; \"Daejeon\"",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "Interude : `...` 연산자"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/04I_splat_operator.html#sec-splat_operator_in_function_argument",
    "href": "src/introduction_to_julia/04I_splat_operator.html#sec-splat_operator_in_function_argument",
    "title": "Interude : ... 연산자",
    "section": "",
    "text": "함수의 정의에서는 인자를 튜플로 묶는다면 함수를 사용할 때는 컨테이너를 풉니다. 예를 들어,\nIn [12]: function ps3(a1, a2, a3)\n         return a1+(a2*a3)\n         end\n와 같은 함수를 사용해야 한다고 합시다. 그런데 다른 함수의 계산 결과로 aa=(a1, a2, a3) 를 얻었다고 합시다. ps3(aa[1], aa[2], aa[3]) 와 같이 실행 시킬 수도 있지만\nIn [13]: aa=(2, 3, 4)\nOut[13]: (2, 3, 4)\n\nIn [14]: ps3(aa...)\nOut[14]: 14\n처럼 ps3 함수를 실행 시킬 때 인자로 a... 를 쓰면 튜플이 풀려서 ps3(aa[1], aa[2], aa[3]) 를 실행시킨 것과 같게됩니다.",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "Interude : `...` 연산자"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html",
    "href": "src/introduction_to_julia/06_arrays.html",
    "title": "배열",
    "section": "",
    "text": "Julia 는 0 차원 배열부터 임의의 차원(dimension)의 배열을 지원합니다. 1차원 배열은 Vector, 2차원 배열은 Matrix 라는 별명(alias)을 가지고 있습니다. 0 차원 배열은 성분을 하나 가지고 있는 배열입니다. 각 차원을 축(axis) 이라고 부릅니다. 배열의 형태(shape) 는 각 차원마다 몇개의 성분을 가지는지를 말합니다. 예를 들어 배열의 형태가 (3, 4, 5) 라면 3차원 배열이고 첫번째 차원으로는 3개, 두번째 차원으로는 4개, 세번째 차원으로는 5개의 성분을 가져야 합니다.\n1 차원 배열과 2차원 배열은 다음과 같이 선언됩니다.\nIn [1]: arr1 = [1.0, 2.0, 3.0, 4.0]\nOut[1]: 4-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n 4.0\n\nIn [2]: arr2 = [4.0; 5; 6]\nOut[2]: 3-element Vector{Float64}:\n 4.0\n 5.0\n 6.0\n\nIn [3]: arr3 = [1 2 3 4]\nOut[3]: 1×4 Matrix{Int64}:\n 1  2  3  4\n\nIn [4]: arr4=[3 2;4 5]\nOut[4]: 2×2 Matrix{Int64}:\n 3  2\n 4  5\narr1 과 같이 [ ] 안에 콤마로 분리된 경우와 arr2 와 같이 ; 로 분리된 경우는 1 차원 벡터입니다. Out[1] 의 Vector{Float64} 는 성분이 Float64 타입인 1차원 배열이라는 의미입니다. 앞서 말했듯이 Vector 는 1차원 배열과 같은 의미이며 (alias 라고 하며 본질적으로 같고, 부르는 이름이 다르다는 의미입니다.) Matrix 는 2차원 배열의 alias 입니다. arr3 와 같이 공백으로 분리되는 경우는 2차원 배열입니다. 즉 [1 2] 와 [1, 2] 는 다릅니다. arr4 를 보면 알겠지만 2차원 배열은 행 순서대로 나열하되 같은 행에서는 공백으로 열을 구분하며, 행의 구분은 ; 를 사용합니다. 배열의 각 성분에 접근할 때는 arr2[3] 이나 arr3[1, 1] 과 같이 접근합니다. 이 때 배열의 위치를 나타내는 숫자 혹은 숫자들을 인덱스라고 부릅니다. 인덱스에 대해서는 잠시후 배열의 인덱스 에서 좀 더 자세히 다룹니다.\n; 를 여러 개 겹쳐서 다차원 배열을 선언하는데 사용 할 수 있습니다.\n\nIn [5]: arr3d = [1; 2;; 3; 4;; 5; 6;;; 7; 8;; 9; 10;; 11; 12]\nOut[5]: 2×3×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  3  5\n 2  4  6\n\nIn [6]: arr5 = [1;;2;;3;;4]\nOut[6]: 1×4 Matrix{Int64}:\n 1  2  3  4\n\nIn [7]: arr6 = [1;;;2;;;3;;;4]\nOut[7]: 1×1×4 Array{Int64, 3}:\n[:, :, 1] =\n 1\n\n[:, :, 2] =\n 2\n\n[:, :, 3] =\n 3\n\n[:, :, 4] =\n 4\n\n[:, :, 2] =\n 7   9  11\n 8  10  12\n\nIn [8]: ndims(arr5)\nOut[8]: 2\n\nIn [9]: size(arr6)\nOut[9]: (1, 1, 4)\n\nIn [10]: sizeof(arr3d)\nOut[10]: 96\n\nIn [11]: length(arr3d)\nOut[11]: 12\nIn [8] 에서 ndims() 함수는 배열의 차원을 반환합니다. 배열의 형태는 size() 함수로 알 수 있습니다. sizeof() 함수는 배열의 크기를 바이트(bytes) 로 나타냅니다. arr3d 는 Int64 타입의 성분으로 이루어져 있으며, Int64 는 8바이트 이고 모두 12 개의 성분을 가지므로 96 바이트를 차지합니다. 일반적인 컨테이너와 같이 length() 함수를 통해 배열에 속하는 모든 성분의 갯수를 알 수 있습니다.",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "배열"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html#sec-array",
    "href": "src/introduction_to_julia/06_arrays.html#sec-array",
    "title": "배열",
    "section": "",
    "text": "Julia 는 0 차원 배열부터 임의의 차원(dimension)의 배열을 지원합니다. 1차원 배열은 Vector, 2차원 배열은 Matrix 라는 별명(alias)을 가지고 있습니다. 0 차원 배열은 성분을 하나 가지고 있는 배열입니다. 각 차원을 축(axis) 이라고 부릅니다. 배열의 형태(shape) 는 각 차원마다 몇개의 성분을 가지는지를 말합니다. 예를 들어 배열의 형태가 (3, 4, 5) 라면 3차원 배열이고 첫번째 차원으로는 3개, 두번째 차원으로는 4개, 세번째 차원으로는 5개의 성분을 가져야 합니다.\n1 차원 배열과 2차원 배열은 다음과 같이 선언됩니다.\nIn [1]: arr1 = [1.0, 2.0, 3.0, 4.0]\nOut[1]: 4-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n 4.0\n\nIn [2]: arr2 = [4.0; 5; 6]\nOut[2]: 3-element Vector{Float64}:\n 4.0\n 5.0\n 6.0\n\nIn [3]: arr3 = [1 2 3 4]\nOut[3]: 1×4 Matrix{Int64}:\n 1  2  3  4\n\nIn [4]: arr4=[3 2;4 5]\nOut[4]: 2×2 Matrix{Int64}:\n 3  2\n 4  5\narr1 과 같이 [ ] 안에 콤마로 분리된 경우와 arr2 와 같이 ; 로 분리된 경우는 1 차원 벡터입니다. Out[1] 의 Vector{Float64} 는 성분이 Float64 타입인 1차원 배열이라는 의미입니다. 앞서 말했듯이 Vector 는 1차원 배열과 같은 의미이며 (alias 라고 하며 본질적으로 같고, 부르는 이름이 다르다는 의미입니다.) Matrix 는 2차원 배열의 alias 입니다. arr3 와 같이 공백으로 분리되는 경우는 2차원 배열입니다. 즉 [1 2] 와 [1, 2] 는 다릅니다. arr4 를 보면 알겠지만 2차원 배열은 행 순서대로 나열하되 같은 행에서는 공백으로 열을 구분하며, 행의 구분은 ; 를 사용합니다. 배열의 각 성분에 접근할 때는 arr2[3] 이나 arr3[1, 1] 과 같이 접근합니다. 이 때 배열의 위치를 나타내는 숫자 혹은 숫자들을 인덱스라고 부릅니다. 인덱스에 대해서는 잠시후 배열의 인덱스 에서 좀 더 자세히 다룹니다.\n; 를 여러 개 겹쳐서 다차원 배열을 선언하는데 사용 할 수 있습니다.\n\nIn [5]: arr3d = [1; 2;; 3; 4;; 5; 6;;; 7; 8;; 9; 10;; 11; 12]\nOut[5]: 2×3×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  3  5\n 2  4  6\n\nIn [6]: arr5 = [1;;2;;3;;4]\nOut[6]: 1×4 Matrix{Int64}:\n 1  2  3  4\n\nIn [7]: arr6 = [1;;;2;;;3;;;4]\nOut[7]: 1×1×4 Array{Int64, 3}:\n[:, :, 1] =\n 1\n\n[:, :, 2] =\n 2\n\n[:, :, 3] =\n 3\n\n[:, :, 4] =\n 4\n\n[:, :, 2] =\n 7   9  11\n 8  10  12\n\nIn [8]: ndims(arr5)\nOut[8]: 2\n\nIn [9]: size(arr6)\nOut[9]: (1, 1, 4)\n\nIn [10]: sizeof(arr3d)\nOut[10]: 96\n\nIn [11]: length(arr3d)\nOut[11]: 12\nIn [8] 에서 ndims() 함수는 배열의 차원을 반환합니다. 배열의 형태는 size() 함수로 알 수 있습니다. sizeof() 함수는 배열의 크기를 바이트(bytes) 로 나타냅니다. arr3d 는 Int64 타입의 성분으로 이루어져 있으며, Int64 는 8바이트 이고 모두 12 개의 성분을 가지므로 96 바이트를 차지합니다. 일반적인 컨테이너와 같이 length() 함수를 통해 배열에 속하는 모든 성분의 갯수를 알 수 있습니다.",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "배열"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html#sec-array_initialization",
    "href": "src/introduction_to_julia/06_arrays.html#sec-array_initialization",
    "title": "배열",
    "section": "2 배열의 생성",
    "text": "2 배열의 생성\n앞에서와 같이 각각 배열의 성분을 입력 할 수도 있겠지만, 배열이 클 경우는 거의 불가능한 방법입니다. Julia 는 배열을 생성하고 초기화 할 수 있는 다양한 방법을 제공합니다.\n\n\nArray comprehension 을 이용한 배열의 생성\n[ ] 안에 루프를 사용하여 배열을 만들 수 있으며 이렇게 배열을 만드는 것을 Array comprehension 이라고 합니다. 1 부터 10 까지의 정수의 제곱을 순서대로 포함하는 배열은 아래와 같이 만들 수 있습니다.\nac1 = [x^2 for x in 1:10]\n다차원 배열도 다음과 같이 만들 수 있습니다.\nIn [6]: [x+y for x = 1:3, y = 1:2]\nOut[6]: 3×2 Matrix{Int64}:\n 2  3\n 3  4\n 4  5\n[ ] 안에 조건을 넣을 수도 있습니다. 예를 들어 앞의 2차원 배열에서 x+y&gt;3 인 경우에는 0 으로 채우고 싶다면,\nIn [7]: [if x+y &gt; 3 0 else x+y end for x = 1:3, y = 1:2]\nOut[7]: 3×2 Matrix{Int64}:\n 2  3\n 3  0\n 0  0\n와 같이 쓸 수 있습니다. 3항 연산자를 사용하여 다음과 같이 쓸 수도 있습니다.\nIn [8]: [(x+y &gt; 3) ? 0 : x+y  for x = 1:3, y = 1:2]\nOut[8]: 3×2 Matrix{Int64}:\n 2  3\n 3  0\n 0  0\n그런데 if 문이 뒤에 가면 전혀 다른 결과가 발생합니다.\nIn [9]: [x for x in 1:10 if x&gt;4]\nOut[9]: 6-element Vector{Int64}:\n  5\n  6\n  7\n  8\n  9\n 10\n\nIn [10]: [x+y for x = 1:3, y = 1:2 if x+y&gt;3]\nOut[10]: 3-element Vector{Int64}:\n 4\n 4\n 5\nIn[7] 과 같이 for 가 if 뒤에 있으면, 중첩된 for 의 갯수에 따라 다차원 배열을 만든 후 연산을 수행합니다. 반대로 In[9] 나 In [10] 과 같이 if 가 for 의 뒤에 있다면 1차원 배열에 대해 if 문이 일종의 filter 함수 역할을 수행하며 이 filter 에 대해 true 인 경우 1차원 배열에 삽입합니다.\n\n간단한 규칙으로 배열을 생성하는 경우 Array comprehension 을 사용하는 것이 for 를 이용하는 것보다 빠른 경우가 많습니다. 예를 들어 \\(A_{ij} = i^{j-1}\\) 의 규칙으로 생성되는 배열을 두가지 방법으로 만들어 봅시다.\n# for loop\nV1 = zeros(Int64,(10, 10))\nfor i ∈ 1:10, j ∈ 1:10\n    V1[i, j] = i^(j-1)\nend\n\n# Array comprehension\nV2 = [i^(j-1) for i ∈ 1:10, j ∈ 1:10]\n두 결과는 같은 결과를 냅니다. BenchmarkTools 패키지의 @btime 매크로로 수행 시간을 측정해보면\nusing BenchmarkTools\n\nV1 = zeros(Int64,(10, 10))\n@btime begin\nfor i ∈ 1:10, j ∈ 1:10\n    V1[i, j] = i^(j-1)\nend\nend\n\n@btime V2 = [i^(j-1) for i ∈ 1:10, j ∈ 1:10]\n두번째 경우가 첫번째 경우보다 6배 이상 빠릅니다. 하지만 배열 작성 규칙이 복잡해지고 배열의 크기가 커질수록 역전되며 array comprehenshion 에서는 복잡한 과정을 넣기 힘들기 때문에 오히려 for 문을 사용하는 것이 좋습니다.\n\n\n\n특정 값으로만 이루어진 배열의 생성\nzeros(), ones(), fill() 함수가 대표적으로 배열을 초기화 하는 함수입니다. zeros(T, dims) 는 T 의 타입에서의 0 값(zero(T))으로 채워진 dims 차원의 배열을 반환합니다. ones(T, dims) 은 one(T) 로 채워진 배열의 형상이dims 인 배열을 반환하며 fill(v, dims) 는 값 v 로 채워진 dims 형상의 배열을 반환합니다. T 가 주어지지 않을 경우는 Float64 타입으로 정해지며 dims 는 1차원 배열의 경우는 정수, 다차원 배열의 경우는 튜플, 혹은 연속적인 정수입니다.\nIn [1]: zeros(Float32, (2, 3))\nOut[1]: 2×3 Matrix{Float32}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\nIn [2]: ones(UInt8, (2,2,2)) # == ones(UInt8, 2,2,2)\nOut[2]: 2×2×2 Array{UInt8, 3}:\n[:, :, 1] =\n 0x01  0x01\n 0x01  0x01\n\n[:, :, 2] =\n 0x01  0x01\n 0x01  0x01\n\nIn [3]: fill(2.0, 1, 3)  # == fill(2.0, (1, 3))\nOut[3]: 1×3 Matrix{Float64}:\n 2.0  2.0  2.0\n\nundef 키워드를 사용하여 타입과 크기만을 지정하고 값을 정하지 않고 초기화 할 수도 있습니다.\nA1 = Vector{Int8}(undef, 4) # 1차원 배열 초기화\nA2 = Matrix{Float64}(undef,10,10) # 2차원 배열 초기화\nA3 = Array{Float32}(undef, 2, 2, 2) #3차원 배열 초기화\n이 경우 배열의 성분은 임의의 값이 정해집니다. 이렇게 임의의 값이 채워진 배열을 초기화 하는 이유는 이렇게 배열을 만드는 것이 특정 값으로 채워서 초기화 하는 것보다 훨씬 빠르기 때문입니다. 제 컴퓨터에서는 Float64 타입의 \\(10000 \\times 10000\\) 배열을 만드는데 zeros 함수를 사용하는 것보다 undef 를 사용하는 것이 50000 배 정도 빨랐습니다. 만약 배열의 모든 성분이 이후의 계산과정에서 채워지는것이 확실하다면 굳이 특정 값으로 초기화 시키지 않고 undef 를 사용하여 배열을 생성하는 것이 좋습니다.\n\n\n\n이미 존재하는 배열과 같은 크기의 배열 생성\n배열의 타입과 크기를 지정하지 않고 이미 존재하는 배열을 이용하여 초기화 할 수 있습니다. 예를 들어 어떤 배열 A 와 같은 크기와 타입을 갖지만 모든 성분이 0 인 배열을 만들 때 zero(A) 를 사용 할 수 있습니다. (zeros(A) 가 아닙니다) A 가 정사각 행렬일 경우 one(A) 는 A 와 같은 크기와 타입을 갖는 항등행렬을 리턴합니다.\nIn [1]: A=[1.0 -2.0 3.0;4.0 -3.0 -1.0]\nOut[1]: 2×3 Matrix{Float64}:\n 1.0  -2.0   3.0\n 4.0  -3.0  -1.0\n\nIn [2]: zero(A)\nOut[2]: 2×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\nIn [3]: B=[1 2;3 4]\nOut[3]: 2×2 Matrix{Int64}:\n 1  2\n 3  4\n\nIn [4]: one(B)\nOut[4]: 2×2 Matrix{Int64}:\n 1  0\n 0  1\n\n배열을 초기화 할 때 undef 키워드를 사용하는 것처럼 일단 주어진 배열과 같은 크기와 타입을 갖는, 하지만 그 안에 채워지는 값을 보장하지 않는 배열을 similar() 함수를 통해 만들 수 있습니다. similar() 를 사용하는 이유도 속도 때문이며, undef 키워드로 배열을 만드는 것과 같이, 이후 연산으로 그 값이 다 채워진다면 충분히 사용할 만 합니다.\nIn [8]: C=[1.0 3.0;2.0 -1.0]\nOut[8]: 2×2 Matrix{Float64}:\n 1.0   3.0\n 2.0  -1.0\n\nIn [9]: similar(C)\nOut[9]: 2×2 Matrix{Float64}:\n 0.0           2.39288e-314\n 2.39288e-314  0.0\n\n\n\n배열을 확장하여 생성\n2차원 배열을 생성할 때 [1 3;2 4] 와 같이 열 구별은 공백을, 행 구별은 ; 을 이용하여 생성하는 방법을 이미 알아 보았습니다. 이 방법은 스칼라 뿐만 아니라 배열을 사용 할 수도 있는데 예를 들면\nIn [1]: A=[1 2;3 4];B=[5 ; 6]; C = [7 8]; D=[9]\nOut[1]: 1-element Vector{Int64}:\n 9\n\nIn [2]: A=[1 2;3 4];B=[5 ; 6]; C = [7 8]; D=[9]\nOut[2]: 1-element Vector{Int64}:\n 9\n\nIn [3]: F1=[A B]\nOut[3]: 2×3 Matrix{Int64}:\n 1  2  5\n 3  4  6\n\nIn [4]: F2=[A;C]\nOut[4]: 3×2 Matrix{Int64}:\n 1  2\n 3  4\n 7  8\n\nIn [5]: F3=[A B;C D]\nOut[5]: 3×3 Matrix{Int64}:\n 1  2  5\n 3  4  6\n 7  8  9\n와 같습니다. 즉 부분 행렬을 모아 더 큰 행렬을 만들 때 행 방향으로의 확장은 공백으로, 열 방향으로의 확장은 ; 를 이용합니다. 이렇게 작은 배열을 모아 큰 배열을 만드는 것을 concatenation 이라고 합니다. Concatenation 을 이용할 때는 각 부분행렬의 행과 열의 갯수가 서로 잘 맞도록 해줘야 합니다. [A B; C D] 형태로 concatenation 을 할 때는 A 와 B 의 행의 갯수가 같아야 하며 A 와 C 의 열의 갯수가 같아야 하고 B 의 열의 갯수와 D 의 열의 갯수도 같아야 하며 C 와 D 의 행의 갯수가 같아야 합니다. 복잡하게 설명했지만 결국 크기가 다른 타일을 빈 틈 없이 맞추는 경우로 생각할 수 있겠습니다.\nConcatenation 을 해 주는 함수로는 cat, vcat, hcat, hvcat, hvncat 이 있습니다.\nIn [1]: A=[1 2;3 4];B=[5 6;7 8];C=[-1 -2; -3 -4];\n\nIn [2]: vcat(A, B)\nOut[2]: 4×2 Matrix{Int64}:\n 1  2\n 3  4\n 5  6\n 7  8\n\nIn [3]: hcat(A, B, C)\nOut[3]: 2×6 Matrix{Int64}:\n 1  2  5  6  -1  -2\n 3  4  7  8  -3  -4\n\nIn [4]: hvcat((2, 3), [1 2;3 4], [-1;-2], [5; 6], [7;8], [9;10])\nOut[4]: 4×3 Matrix{Int64}:\n 1  2  -1\n 3  4  -2\n 5  7   9\n 6  8  10\n\nIn [5]: [[1 2;3 4] [-1;-2] ; [5; 6] [7;8] [9;10]]\nOut[5]: 4×3 Matrix{Int64}:\n 1  2  -1\n 3  4  -2\n 5  7   9\n 6  8  10\n\nIn [6]: hvcat(2, [1 2;3 4], [5;6])\nOut[6]: 2×3 Matrix{Int64}:\n 1  2  5\n 3  4  6\nvcat(A, B) 는 [A; B] 와 같으며 hcat(A, B) 는 [A B] 와 같습니다. 즉 vcat 은 배열을 수직으로 위에서 아래로 쌓으며, hcat 은 왼쪽에서 오른쪽으로 쌓습니다. vcat 이나 hcat 의 인자로는 다수의 배열 혹은 숫자가 올 수 있습니다. hvcat 은 인자로서 처음에 정수 혹은 정수의 터플이 오며, 그 다음부터 다수의 배열이 위치합니다. In [4] 의 hcat 함수의 첫번째 인자 (2, 3) 는 첫번째 블록열은 2개의 행렬로, 두번째 블록열은 그 다음 세개의 행렬로 이루어진다는 것을 의미합니다. 즉 [1 2;3 4], [-1;-2] 가 첫번째 열을 이루고, [5; 6], [7;8], [9;10] 가 두번째 열을 이룹니다. 따라서 In [5] 와 같습니다. hvcat 의 첫번째 인자로 정수만 있을 때는 첫번째 블록열로만 이루어집니다.\ncat 함수는 좀 많이 복잡합니다. 우리는 여기서는 1차원과 2차원 배열에 대해서만 다루겠습니다. 우선 cat 함수의 시그너쳐는 다음과 같습니다.\ncat(A...; dims)\ndims 는 자연수, 혹은 자연수의 터플이 올 수 있습니다. Julia 1.8 부터는 Val{x} 타입도 가능하지만 여기서는 다루지 않겠습니다. 자연수가 올 때는 그 차원 방향으로 확장합니다.\nIn [1]: cat(1, [2;3], dims=1)\nOut[1]: 3-element Vector{Int64}:\n 1\n 2\n 3\n\nIn [2]: cat([1;2], [3;4], dims=2)\nOut[2]: 2×2 Matrix{Int64}:\n 1  3\n 2  4\ndims 에 자연수의 컨테이너가 올 때는 마치 블록 대각 행렬을 만드는 것 처럼 확장됩니다. 다음을 봅시다.\nIn [3]: cat(1, [2;3], [4 5; 6 7], dims=(1, 2))\nOut[3]: 5×4 Matrix{Int64}:\n 1  0  0  0\n 0  2  0  0\n 0  3  0  0\n 0  0  4  5\n 0  0  6  7\ndims=(1, 2) 이므로 첫번째 차원(수직) 과 두번째 차원 (수평) 으로 확장되며 주어진 배열 (스칼라는 0차원 배열로 간주됩니다) 대각으로 놓게 됩니다.",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "배열"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html#sec-index_of_array",
    "href": "src/introduction_to_julia/06_arrays.html#sec-index_of_array",
    "title": "배열",
    "section": "3 배열의 인덱스",
    "text": "3 배열의 인덱스\n프로그래밍 언어에서 배열을 다룰 때 첫번째 인덱스가 0 인 언어가 있으며(C/C++, Java, Python, Javascript 등), 1 인 언어(Fortran, Matlab, R 등) 가 있습니다. Julia는 1부터 시작합니다. end 는 각 차원의 마지막 인덱스를 의미하는 키워드입니다. 물론 배열의 차원과 형태를 알고 있다면 인덱스를 직접 써도 됩니다.\nIn [1]: A = [1 4 7 10;2 5 8 11;3 6 9 12] \nOut[1]: 3×4 Matrix{Int64}:\n 1  4  7  10\n 2  5  8  11\n 3  6  9  12\n\nIn [2]: A[1, 1] # a의 1 행 1열\nOut[2]: 1\n\nIn [3]: A[2, end] # a의 2 행 마지막 열\nOut[3]: 11\n\nIn [4]: A[end, end] # a 의 마지막 행 마지막 열\nOut[4]: 12\n\n\n인덱스를 이용한 배열 연산\n인덱스의 범위를 지정할 수도 있습니다. 전체 볌위는 : 로 표기하며, 벡터나 튜플, StepRange 를 사용하여 선택적으로 지정할 수도 있습니다.\nIn [5]: A[:, 1]   # 전체 행, 1 열\nOut[5]: 3-element Vector{Int64}:\n 1\n 2\n 3\n\nIn [6]: A[2, 1:2:end]  # 2행 의 1열부터 끝열까지 2열 간격으로\nOut[6]: 2-element Vector{Int64}:\n 2\n 8\n\nIn [7]: A[3, [2, 3]] # 3행 의 2열과 3열\nOut[7]: 2-element Vector{Int64}:\n 6\n 9\n\nB=A[:, 1] 라고 하면 B 는 A 의 1 행과 같은 값을 갖는 벡터이며 A 의 1행이 아닙니다. 즉 B=A[:, 1] 을 수행하고 B 벡터의 성분을 바꾼다고 해도 A 가 변하지 않습니다. 이에 대해서는 배열의 복사 와 view 와 @view 를 참고하시기 바랍니다.\nIn [9]: B=A[:, 1]\nOut[9]: 3-element Vector{Int64}:\n 1\n 2\n 3\n\nIn [10]: B[2]=-3\nOut[10]: -3\n\nIn [11]: A\nOut[11]: 3×4 Matrix{Int64}:\n 1  4  7  10\n 2  5  8  11\n 3  6  9  12\n\nIn [12]: B\nOut[12]: 3-element Vector{Int64}:\n  1\n -3\n  3\n\n\n\n행렬의 열/행 우선 방식\n예를 들어 \\(\\boldsymbol{A} =\\begin{bmatrix} 1&2\\\\3&4\\end{bmatrix}\\) 를 메모리상에 저장할 때 1행 1열, 1행 2열,… 1행 마지막열, 2행 1열, … 순으로 저장하는 것을 행 우선 순서(row-major order) 라고 하고 1행 1열 2행 1열,…, 마지막행 1열, 2행 1열, 2행 2열,… 순으로 저장하는 것을 열 우선 방식(column-major order)이라고 합니다. 행 우선 방식에서는 배열 A 가 1 2 3 4 의 순으로 저장이 되며 열 우선방식에서는 1 3 2 4 순으로 저장이 됩니다. 행 우선 방식을 쓰는 언어로는 C/C++ 과 Python 의 numpy 가 있고 열 우선 방식을 쓰는 언어로는 Fortran, MATLAB, Julia, R 등이 있습니다. 또한 언어에서 사용하는 자료구조나 함수에 따라 달라질 수 있습니다.\n\n\n\n\n\n\n경고\n\n\n\n이것이 문제가 될 수 있는 경우는 우선순위가 다른 언어나 라이브러리간에 데이터를 교환 할 때 입니다. 예를 들어 julia 의 배열을 파일로 저장 한 후 python 의 numpy 로 읽으면 행과 열이 바뀔 수 있습니다.\n\n\n열/행 우선 방식이 본질적으로 동일한 계산의 계산 속도에 영향을 줄 수 있습니다. 아래의 코드는 \\(10000 \\times 10000\\) 배열의 합을 두가지 방법으로 구하는 코드입니다. 우선 각 행에대헤 열을 순회하며 합을 구하였고, 그 다음은 각 열에 대해 행을 순회하며 합을 구하였습니다.\nusing BenchmarkTools\nM = 10000\nmat= rand(M, M)\n\n@btime begin\n    r1  =0.0\n    for i ∈ 1:M, j ∈ 1:M\n        r1 += mat[i, j]\n    end\nend\n\n@btime begin\n    r2 =  0.0\n    for j ∈ 1:M, i ∈ 1:M\n        r2 += mat[i, j]\n    end\nend\n그 결과는\n  13.454 s (489818979 allocations: 8.79 GiB)\n  8.744 s (489818979 allocations: 8.79 GiB)\n로 아래의 방법이 훨씬 빨랐습니다. 이것은 julia 에서는 배열이 열 우선방식으로 정렬되기 때문이며, 행보다 열을 많이 변화시키는 것이 전체적으로 더 빠릅니다. 같은 열에서 다음 행으로 넘어갈 때는 바로 다음칸으로 넘어가면 되지만, 같은 행에서 다음 열로 넘어갈 때 열의 갯수 +1 만큼 넘어가야 하기 때문입니다. 예를 들어 첫번째 합 계산의 경우, 행이 10000 번 변할 동안 열은 1억번 변하는데, 두번째 계산의 경우는 열이 10000 번 변할 동안 행이 1억번 변합니다. 이 차이가 계산 속도의 차이를 만들어 냅니다.\n\n\n\n데카르트 인덱스와 선형 인덱스\n지금까지 2차원 배열A 의 2행 3열 성분을 A[2, 3] 으로 접근했습니다. 이와 같이 배열의 차원의 갯수만큼의 자연수로 접근하는 것을 데카르트 인덱스(Cartesian index) 혹은 카르테시안 인덱스 라고 합니다. 다른 접근 방법도 있는데, 다차원 배열의 각 성분을 1부터 하나의 자연수로 접근하는 방법도 사용합니다. 이것을 선형 인덱스(linear index) 라고 합니다. 앞서 알아본 열 우선 방식에서 배열을 나열할 때의 차례입니다. 예를 들어 A=[1 3;2 4] 의 경우 A[3]=3 이며 A[4]=4 입니다.프랑스의 철학자이자 과학자인 르네 데카르트(René Descartes) 의 이름에서 따왔습니다. 데카르트의 라틴어명이 Renatus Cartesius 이기 때문에 영어로는 Cartesian index 라고 씁니다.\nIn [13]: A=[1 2;3 4]\nOut[13]: 2×2 Matrix{Int64}:\n 1  2\n 3  4\n\nIn [14]: A[3]\nOut[14]: 2\n데카르트 인덱스로부터 선형 인덱스를, 선형 인덱스로부터 데카르트 인덱스르 얻는 방법이 존재합니다. 배열 A 에 대해 CartesianIndices(A)[10] 은 배열 A 의 선형 인덱스 10 에 대한 데카르트 인덱스를 리턴합니다. A 가 삼차원 배열일 경우 LinearIndices(A)[1, 2, 3] 은 배열 A 의 데카르트 인덱스(1, 2, 3) 에 대한 선형 인덱스를 리턴합니다. 고차원 배열에대해서도 차원의 갯수만큼의 데카르트 인덱스를 받아 선형 인덱스를 리턴합니다.\nIn [1]: A=Array(reshape(1:2*3*4, (2, 3, 4)))\nOut[1]: 2×3×4 Array{Int64, 3}:\n[:, :, 1] =\n 1  3  5\n 2  4  6\n\n[:, :, 2] =\n 7   9  11\n 8  10  12\n\n[:, :, 3] =\n 13  15  17\n 14  16  18\n\n[:, :, 4] =\n 19  21  23\n 20  22  24\n\nIn [2]: CartesianIndices(A)[10]\nOut[2]: CartesianIndex(2, 2, 2)\n\nIn [3]: LinearIndices(A)[1, 2, 3]\nOut[3]: 15",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "배열"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html#sec-copy_of_array",
    "href": "src/introduction_to_julia/06_arrays.html#sec-copy_of_array",
    "title": "배열",
    "section": "4 배열의 복사",
    "text": "4 배열의 복사\n배열을 복사할 때는 copy() 혹은 deepcopy() 명령어를 사용합니다. 주의해야 할 것은 배열 A 에 대해 B=A 와 B=copy(A) 는 다르다는 것입니다. 아래 코드를 봅시다.\nIn [13]: A=[1 2]\nOut[13]: 1×2 Matrix{Int64}:\n 1  2\n\nIn [14]: B=A;C=copy(A)\nOut[14]: 1×2 Matrix{Int64}:\n 1  2\n\nIn [15]: B[1, 1]=3\nOut[15]: 3\n\nIn [16]: A\nOut[16]: 1×2 Matrix{Int64}:\n 3  2\n\nIn [17]: C\nOut[17]: 1×2 Matrix{Int64}:\n 1  2\n\nIn [18]: C[1, 2]=-1\nOut[18]: -1\n\nIn [19]: A\nOut[19]: 1×2 Matrix{Int64}:\n 3  2\nB=A 라는 표현식은 B 와 A 변수가 같은 행렬에 대한 변수라는 뜻입니다. 따라서 B 라는 변수를 이용해 행렬 값을 변화시키면 A 변수로 접근하더더라도 변화된 행렬에 접근하게 됩니다. B=copy(A) 는 A 복사본을 만들어 B 라는 변수에 지정합니다. 따라서 B 변수를 이용해 행렬을 바꾸더라도 A 변수에 지정된 행렬은 변화하지 않습니다. B=A[:] 는 B=A 가 아닌 copy(A) 를 의미합니다.\n객체를 복사하는 deepcopy() 함수 가 있습니다. 다음 예를 봅시다.\nIn [1]: A = [1, 2, 3, [4, 5, 6]]\nOut[1]: 4-element Vector{Any}:\n 1\n 2\n 3\n  [4, 5, 6]\n\nIn [2]: B = A[:]; C=copy(A); D=deepcopy(A);\n\nIn [3]: A[4][2]=-1\nOut[3]: -1\n\nIn [4]: B\nOut[4]: 4-element Vector{Any}:\n 1\n 2\n 3\n  [4, -1, 6]\n\nIn [5]: C\nOut[5]: 4-element Vector{Any}:\n 1\n 2\n 3\n  [4, -1, 6]\n\nIn [6]: D\nOut[6]: 4-element Vector{Any}:\n 1\n 2\n 3\n  [4, 5, 6]\nA = [1, 2, 3, [4, 5, 6]] 는 벡터이며 정수와 벡터를 성분으로 갖기 때문에 Any 타입에 대한 벡터가 됩니다. A 의 네번째 성분은 벡터이며 실제로 A 변수에 내부적으로 저장되는것은 벡터 [4, 5, 6] 에 대한 주소입니다. C=copy(A) 명령어는 값 1, 2, 3 과 벡터 [4, 5, 6] 의 복사본을 만들지 않고 단지 주소만을 복사하여 변수 C 에 할당합니다. deepcopy 함수는 벡터 [4, 5, 6] 에 대해서도 복사본을 만들기 때문에 D=deepcopy(A) 명령어로 D 에 할당된 배열은 A 와는 같은 값을 갖는 완전히 별개인 배열이 됩니다.",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "배열"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html#배열에-대한-함수",
    "href": "src/introduction_to_julia/06_arrays.html#배열에-대한-함수",
    "title": "배열",
    "section": "5 배열에 대한 함수",
    "text": "5 배열에 대한 함수\n\n인덱스 순회에 대한 함수들 : eachindex, CartesianIndex\n배열의 인덱스, 혹은 성분 각각에 대해 for ... end 루프를 수행하는 방법은 여러가지가 있습니다. 배열의 선형 인덱스를 이용하여 순회할 때는 eachindex 를 씁니다.\nIn [1]: A = [1 2; 3 4];\n\nIn [2]: for i in eachindex(A)\n        @show i, A[i]\n        end\n(i, A[i]) = (1, 1)\n(i, A[i]) = (2, 3)\n(i, A[i]) = (3, 2)\n(i, A[i]) = (4, 4)\n\nIn [3]: for i in CartesianIndices(A)\n        @show i, A[i]\n        end\n(i, A[i]) = (CartesianIndex(1, 1), 1)\n(i, A[i]) = (CartesianIndex(2, 1), 3)\n(i, A[i]) = (CartesianIndex(1, 2), 2)\n(i, A[i]) = (CartesianIndex(2, 2), 4)\n위에서 알 수 있듯이 eachindex(A) 는 배열 A 에 대한 선형 인덱스를 사용하여 순회하도록 하며 CartesianIndices(A) 는 데카르트 인덱스를 이용하여 순회합니다.\n\n\n\n타입과 모양의 변환\n우리는 앞서 타입이름이 타입 변환함수로 사용될 수 있다는 것을 보았습니다. 예를 들어 Float32(6) 은 Int64 타입의 6 을 4바이트 부동소수 타입인 Float32 타입으로 변환시킵니다. 또한 우리는 . 연산자를 통해 컨테이너의 각각의 성분에 대해 함수를 적용시킬 수 있다는 것을 알았습니다. 따라서 Float32.([1, 2, 3, 4]) 는 Float32 타입의 성분을 갖는 [1.0f0, 2.0f0, 3.0f0, 4.0f0] 입니다.\n\\(3\\times 5\\) 배열을 \\(5 \\times 3\\) 배열로 바꾸거나 \\(12 \\times 5\\) 배열을 \\(3\\times 4 \\times 5\\) 로 바꾸는 것과 같이 그 크기를 유지하지만 배열의 모양을 바꾸는 함수는 reshape 입니다. 예를 들어 보겠습니다.\nIn [1]: A = Array(1:6)\nOut[1]: 6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\nIn [2]: reshape(A, (2, 3))\nOut[2]: 2×3 Matrix{Int64}:\n 1  3  5\n 2  4  6\nIn[1] 에서의 A 는 6개의 성분을 갖는 1차원 벡터였지만 reshape(A, (2, 3)) 를 통해 \\(2 \\times 3\\) 행렬이 되었습니다. 다시 말하지만 원래의 행렬과 변환된 행렬의 총 성분 수는 같아야 합니다. 즉 length 가 같아야 합니다. reshape 는 원래 행렬과 변환 행렬의 선형 인덱스가 같도록 변환됩니다.\n\n\n\nview 와 @view\nview 는 이미 존재하는 배열로부터 특정 부분을 추출하여 만든 배열에 대한 타입이며, 이런 연산을 하는 함수이기도 합니다. 배열 A 에 대해 a=view(A, 1) 은 배열 A 의 첫번째 성분을 가리킵니다. 가리킨다라고 표현한 것은 단지 같은 값을 가질 뿐만 아니라 a 를 변경시키면 A 도 변경되기 때문입니다.\nIn [4]: A= [1 2;3 4];\n\nIn [5]: a = view(A, 1)\nOut[5]: 0-dimensional view(::Vector{Int64}, 1) with eltype Int64:\n1\n\nIn [6]: a[1]=3;\n\nIn [7]: A\nOut[7]: 2×2 Matrix{Int64}:\n 3  2\n 3  4\n다차원 배열의 경우 인덱스를 쓰거나 : 나 배열을 이용하여 범위를 특정 할 수 있습니다.\nIn [8]: B=reshape(Array(1:12), (3, 4))\nOut[8]: 3×4 Matrix{Int64}:\n 1  4  7  10\n 2  5  8  11\n 3  6  9  12\n\nIn [9]: b=view(B, [1, 3], :)  # 1행과 3행, 그리고 열 전체에 대한 view\nOut[9]: 2×4 view(::Matrix{Int64}, [1, 3], :) with eltype Int64:\n 1  4  7  10\n 3  6  9  12\n\nIn [10]: b[2, 2]=-6 # view 의 변경\nOut[10]: -6\n\nIn [11]: B\nOut[11]: 3×4 Matrix{Int64}:\n 1   4  7  10\n 2   5  8  11\n 3  -6  9  12\n앞서 B[:, 3] 과 같이 이미 존재하는 배열로부터 그 부분을 성분으로 갖는 배열을 생성하는 방법을 보았습니다. @view 매크로는 view 함수를 쓰지 않고 B[:, 3] 과 같은 방법으로 view 를 생성합니다. 매크로에 대해서는 메타프로그래밍과 매크로 를 참고하시기 바랍니다. 일단은 @ 로 시작하는 명령문은 매크로 라고 하며 명령문 뒤에 주어진 인자나 함수에 대한 특별한 기능을 한다는 정도만 알아 둡시다\nIn [21]: B=reshape(Array(1:12), (3, 4))\nOut[21]: 3×4 Matrix{Int64}:\n 1  4  7  10\n 2  5  8  11\n 3  6  9  12\n\nIn [22]: B[:, [2, 3]]\nOut[22]: 3×2 Matrix{Int64}:\n 4  7\n 5  8\n 6  9\n\nIn [23]: @view B[:, [2, 3]]\nOut[23]: 3×2 view(::Matrix{Int64}, :, [2, 3]) with eltype Int64:\n 4  7\n 5  8\n 6  9\nB[:, [2, 3]] 은 B 의 2행과 3행만을 선택하여 새로운 배열을 만들기 때문에, 일단 만든 다음에는 원래의 B 값과 무관하게 변경시킬 수 있습니다. @view B[:, [2, 3]] 는 B 의 부분에 대한 view 를 만들기 때문에 C=@view B[:, [2, 3]] 를 통해 C 에 할당한다면 C 를 변경하는 것은 B 를 변경하는 것이 됩니다.\nIn [24]: C=@view B[:, [2, 3]]\nOut[24]: 3×2 view(::Matrix{Int64}, :, [2, 3]) with eltype Int64:\n 4  7\n 5  8\n 6  9\n\nIn [25]: C[1, 1]=-1;\n\nIn [26]: B\nOut[26]: 3×4 Matrix{Int64}:\n 1  -1  7  10\n 2   5  8  11\n 3   6  9  12\nview 나 @view 가 필요한 이유는 메모리와 시간을 절약해 주기 때문입니다. 아주 큰 배열을 다룰 때 그 부분 배열에 대해 연산이 필요하다고 합시다. 배열을 새로 생성한다면 그만큼의 메모리와 배열의 생성과 복사를 위한 시간이 필요하지만 view 를 사용한다면 이미 존재하는 배열을 사용하기 때문에 약간의 메모리에서의 빈 공간만으로 연산을 수행 할 수 있습니다. 다만 view 나 @view 를 이용해 얻은 부분배열을 변경할 경우 원래의 배열도 변경된다는 사실을 명심해야 합니다.\n\n\n\n다차원 배열에서의 도트연산\n앞서 컨테이너 에서 도트 연산, 즉 연산자 앞이나 함수 뒤에 . 를 붙여 성분별 연산을 수행하는 것을 다루었습니다. 다차원 배열의 경우 차원이 같으면(즉 차원의 갯수와, 각 차원별 원소의 갯수가 같으면) 도트 연산을 수행할 수 있지만 차원이 다를 경우에는 차원을 확장하여 수행합니다.\n\n도트 연산에서의 차원 확장은 그 차원이 정의되어 있지 않거나 차원의 성분의 갯수가 1개 일때만 이루어집니다. 즉 [1 2] .+ [1 2; 3 4] 나 [1 2;] .+ [1 2; 3 4]는 가능하지만 [1 2;3 4] .+ [1 2 3; 2 3 4] 는 에러를 발생시킵니다.\n차원 확장은 차원이 없거나 1차원인 차원으로 원래의 배열을 반복합니다. [1 2] .+ [1 2; 3 4] 의 경우는 [1 2] 를 배열로 변환시킬 때 \\(1 \\times 2\\) 배열이 되며 첫번째 차원이 하나의 성분을 가지므로 첫번째 차원에 대해 두번 반복한 [1 2;1 2] 와 [1 2;3 4] 의 연산을 수행하게 됩니다.\n따라서 스칼라나 영차원 배열은 모든 차원의 다차원 배열에 대해 도트 연산이 가능합니다.\n\nIn [1]: [1;;2] .+ [1 2;3 4]\nOut[1]: 2×2 Matrix{Int64}:\n 2  4\n 4  6\n\nIn [2]: [1; 2] .+ [1 2;3 4]\nOut[2]: 2×2 Matrix{Int64}:\n 2  3\n 5  6\n\nIn [3]: [3] .* [1 2; 3 4]\nOut[3]: 2×2 Matrix{Int64}:\n 3   6\n 9  12\n[1;;2] 는 \\(1 \\times 2\\) 배열이므로 \\(2 \\times 2\\) 배열과 연산할 때는 [1 2; 1 2] 로 바뀌어 연산됩니다. [1 ; 2] 는 \\(2 \\times 1\\) 배열이므로 \\(2 \\times 2\\) 배열과 연산할 때는 [1 1; 2 2] 로 바뀌어 연산됩니다.\n컨테이너에서의 도트 연산과 같이 @. 매크로도 동작합니다. @. 매크로를 앞에 붙이면 뒤에 나오는 함수나 연산자에 . 를 붙이지 않아도 julia 가 알아서 연산을 해 줍니다.\n\n\n\nbroadcast\nbroadcast(f, As...) 함수는 하나 이상의 값 혹은 컨테이너인 As... 에 함수 혹은 연산자 f 를 적용합니다. map 함수와 같은것이라고 생각 할 수 있지만, 실제로는 julia 에서 차원과 크기가 다른 컨테이너에 함수를 적용할 때는 이 함수가 기본이 되기 때문에 다차원 배열의 연산을 이해하기 위해서는 이 함수를 이해해야 합니다.\n\nf 를 제외한 인자가 스칼라나 0차원 배열일 경우 스칼라를 반환합니다.\nf 를 제외한 인자에 튜플이 포함되며, 튜플을 제외한 나머지 인자가 스칼라이면 튜플을 반환합니다.\nf 를 제외한 인자가 위의 두 경우와 다르다면 배열을 반환합니다.\nf 를 제외한 인자가 배열이나 스칼라라면 위의 도트 연산시의 차원 확장 규칙에 따라 차원을 확장하여 도트 연산으로 계산합니다.\n\nIn [1]: broadcast(+, 2, 3)\nOut[1]: 5\n\nIn [2]: ones()\nOut[2]: 0-dimensional Array{Float64, 0}:\n1.0\n\nIn [3]: broadcast(+, 1, ones())\nOut[3]: 2.0\n\nIn [4]: broadcast(*, 2, (1, 2, 3))\nOut[4]: (2, 4, 6)\n\nIn [5]: broadcast(*, (1, 2, 3), [-1, 1, 0])\nOut[5]: 3-element Vector{Int64}:\n -1\n  2\n  0\nIn [6]: broadcast(sin, range(0, π, length = 5))\nOut[6]: 5-element Vector{Float64}:\n 0.0\n 0.7071067811865475\n 1.0\n 0.7071067811865476\n 1.2246467991473532e-16\n크기가 다른 배열의 경우 다차원 배열의 도트 연산 과 같은 규칙으로 계산됩니다. 실제로는 도트 연산의 자체가 broadcast 함수를 사용하여 정의되었으므로 당연한 것입니다.",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "배열"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/08_type_hierarchy.html",
    "href": "src/introduction_to_julia/08_type_hierarchy.html",
    "title": "타입의 계층구조와 메서드 디스패치",
    "section": "",
    "text": "Julia 에서 다루는 모든 값은 특정 타입(Type) 의 값입니다. 타입은 julia 언어에서 제공하는 Int64 나 Complex{Float64} 일 수도 있고 필요에 의해 만든 것일 수도 있습니다. Julia 에서 변수에 값을 할당할 때 타입을 명시적으로 지정할 수 있으며, 명시적으로 지정되어 있지 않을 경우 julia 에 의해 지정되기도 합니다. 다음의 코드와 설명을 보고 이해하시기 바랍니다.\nIn [1]: a=3;typeof(a)\nOut[1]: Int64\n\nIn [2]: b=3.42;typeof(b)\nOut[2]: Float64\n\nIn [3]: c=Float32(6.44);typeof(c)\nOut[3]: Float32\n\nIn [4]: d::Float32=3.3;typeof(d)\nOut[4]: Float32\n\nIn [5]: e::UInt8=3;typeof(e)\nOut[5]: UInt8\n특별히 형을 지정하지 않았을 경우 정수는 Int64, 실수는 Float64 타입으로 암시적으로 지정됩니다. c 의 경우는 6.44 라는 Float64 의 값을 Float32 로 변환시켜 할당하였으며, d 의 경우는 변수를 Float32 타입으로 지정한 후 대입하여 자동적으로 변환되었습니다. e 의 경우도 UInt8 타입으로 지정한 후 3 을 할당하여 지정된 타입으로 자동적으로 변환되었습니다.\n\n\n\nJulia 의 타입은 추상적 타입(abstract type) 과 구체적 타입(concrete type) 으로 분류 할 수 있습니다. 구체적 타입은 변수가 지정되어 값을 할당 할 수 있지만 추상적 타입에는 변수를 지정 할 수 없으며, 값도 할당 할 수 없습니다. 억지로 할당할 경우 적당한 구체적 타입으로 변환됩니다. 우리가 지금까지 사용한 UInt8, Int64, Float64 등은 구체적 타입이며 아래의 예에서 AbstractFloat 는 부동소수에 대한 추상적인 타입입니다.\nIn [6]: aa=AbstractFloat(0.0);typeof(aa)\nOut[6]: Float64\n어떤 타입이 구체적인 타입인지 추상적인 타입인지는 isabstracttype() 함수나 isconcretetype() 함수로 확인 할 수 있습니다. Julia 에서 모든 타입은 Any 타입에서 뻗어나온 가지와 같은 계층구조를 가지고 있습니다. 예를 들어 julia 에서 제공하는 수 타입은 그림 1 와 같은 계층구조를 가집니다.\nJulia 에서 추상적 타입은 abstract 키워드를 사용하여 다음과 같이 정의합니다.\nabstract type Number end\nabstract type Real     &lt;: Number end\nabstract type AbstractFloat &lt;: Real end\nabstract type Integer  &lt;: Real end\nabstract type Signed   &lt;: Integer end\nabstract type Unsigned &lt;: Integer end\n위의 코드는 저자가 임의로 작성한 코드가 아니라 julia 에서 실제 추상 타입을 구현한 코드를 복사한 것입니다. abstract type Real &lt;: Number end 에서 Real &lt;: Number 는 Real 타입이 미리 정의된 Number 타입의 하위 타입 이란 의미입니다. Any 타입의 직접적인 하위타입은 &lt;: Any 없이 추상 타입을 정의 할 수 있습니다. 이렇게 정의된 것이 Number 타입입니다. Number 라는 수 전체를 아우르는 상위 타입이 있으며, 실수를 나타내는 Real 타입, 부동소수를 나타내는 AbstractFloat 타입, 정수를 나타내는 Integer 타입, 부호 있는 정수를 나타내는 Signed 타입, 부호 없는 정수, 즉 0 을 포함한 자연수를 나타내는 Unsigned 타입과 같은 추상 타입이 있습니다.\nJulia 의 모든 타입은 어떤 타입의 하위 타입(subtype) 이며 단 하나의 상위 타입(supertype) 을 계승합니다. 타입의 하위타입에는 갯수 제한이 없습니다. 타입 계층의 최상단에는 Any 타입이 있으며, 모든 타입은 Any 의 하위타입 이던가 Any 의 하위타입의 하위타입 이던가…. Any 의 몇대 자손중의 하나입니다. 심지어 Any 의 상위타입은 Any 입니다. 어떤 타입의 상위 타입을 알기 위해서는 supertype() 함수를 사용 하며 하위 타입들을 알기 위해서는 subtypes() 함수를 사용합니다.\nIn [7]: supertype(UInt8)\nOut[7]: Unsigned\n\nIn [8]: subtypes(Integer)\nOut[8]: 3-element Vector{Any}:\n Bool\n Signed\n Unsigned\n어떤 타입의 상위 타입은 추상적 타입만이 가능하며, 구체적 타입은 어떤 타입의 상위 타입이 될 수 없습니다. 당연히 Any 는 추상적 타입입니다. 그림 그림 1 은 Julia 에서 자체적으로 제공하는 수(number) 에 대한 타입의 계층 구조입니다. 추상적 타입은 좌우 변이 두겹인 사각형, 구체적 타입은 좌우가 둥근 도형으로 표현하였습니다. Irrational 은 \\(\\pi\\) 나 \\(e\\) 같은 특별한 무리수를 위한 타입으로 계산 될 때 적당한 타입의 값으로 변환됩니다.\n\n\n\n\n\n\nflowchart TB\n    Any[[Any]] --- Number[[Number]]\n    Number ---- Real[[Real]]\n    Number --- Complex[[Complex]]\n    Real ------- Integer[[Integer]] \n    Real --- Rational([Rational])\n    Real --- AbstractIrrational[[AbstractIrrational]]\n    Real ----- AbstractFloat[[AbstractFloat]]\n    Integer --- Unsigned[[Unsigned]] & Bool([Bool])\n    Integer ----- Signed[[Signed]]\n    AbstractIrrational --- Irrational[Irrational]\n    AbstractFloat --- Float16([Float16]) & Float32([Float32]) & Float64([Float64])  &  BigFloat([BigFloat])\n    Unsigned --- UInt8([UInt8]) & UInt16([UInt16]) & UInt32([UInt32]) & UInt64([UInt64]) & UInt128([UInt128])\n    Signed --- Int8([Int8]) & Int16([Int16]) & Int32([Int32]) & Int64([Int64])  & Int128([Int128]) & BigInt([BigInt])\n\n\n\n\n그림 1: Type hierarchy of number\n\n\n\n\n\n\n이것을 정리하면 다음과 같습니다.\n\n\n\n\n추상적 타입\n구체적 타입\n\n\n\n\n하위타입 지정\no\nx\n\n\n변수 할당\nx\no\n\n\n\n여기서 Complex 만 추상적 타입으로 구체적인 하위타입이 존재하지 않습니다. 실제로 Julia 에서 복소수는 복합 타입(composite type) 으로 정의됩니다. 여기에 대해서는 복합 타입에서 다루겠습니다.\n\n\n\n\nInt64 나 Float32 와 같이 값이 저장되는데 사용되는 바이트 수가 결정된 구체적 타입을 원시 타입(Primitive type) 이라고 합니다. isprimitivetype() 함수를 통해 특정 타입이 원시 타입인지를 확인할 수 있습니다. Julia 의 모든 기본 타입은 julia 자체 내에서 다음과 같이 정의되었습니다. 저의 경우는 Julia 설치 디렉토리의 /share/julia/base/boot.jl 파일에 정의되었습니다.\nprimitive type Float16 &lt;: AbstractFloat 16 end\nprimitive type Float32 &lt;: AbstractFloat 32 end\nprimitive type Float64 &lt;: AbstractFloat 64 end\n\nprimitive type Bool &lt;: Integer 8 end\nprimitive type Char &lt;: AbstractChar 32 end\n\nprimitive type Int8    &lt;: Signed   8 end\nprimitive type UInt8   &lt;: Unsigned 8 end\nprimitive type Int16   &lt;: Signed   16 end\nprimitive type UInt16  &lt;: Unsigned 16 end\nprimitive type Int32   &lt;: Signed   32 end\nprimitive type UInt32  &lt;: Unsigned 32 end\nprimitive type Int64   &lt;: Signed   64 end\nprimitive type UInt64  &lt;: Unsigned 64 end\nprimitive type Int128  &lt;: Signed   128 end\nprimitive type UInt128 &lt;: Unsigned 128 end\n첫번째 primitive type Float16 &lt;: AbstractFloat 16 end 는 Float16 타입은 AbstractFloat 타입의 하위타입으로 16비트, 즉 2바이트를 차지하는 타입이라는 의미입니다. 앞서 말했듯이 구체적 타입은 상위 타입이 될 수 없으므로 원시 타입은 어떤 추상 타입의 하위타입이 됩니다.",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "타입의 계층구조와 메서드 디스패치"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/08_type_hierarchy.html#sec-type_hierarchy",
    "href": "src/introduction_to_julia/08_type_hierarchy.html#sec-type_hierarchy",
    "title": "타입의 계층구조와 메서드 디스패치",
    "section": "",
    "text": "Julia 에서 다루는 모든 값은 특정 타입(Type) 의 값입니다. 타입은 julia 언어에서 제공하는 Int64 나 Complex{Float64} 일 수도 있고 필요에 의해 만든 것일 수도 있습니다. Julia 에서 변수에 값을 할당할 때 타입을 명시적으로 지정할 수 있으며, 명시적으로 지정되어 있지 않을 경우 julia 에 의해 지정되기도 합니다. 다음의 코드와 설명을 보고 이해하시기 바랍니다.\nIn [1]: a=3;typeof(a)\nOut[1]: Int64\n\nIn [2]: b=3.42;typeof(b)\nOut[2]: Float64\n\nIn [3]: c=Float32(6.44);typeof(c)\nOut[3]: Float32\n\nIn [4]: d::Float32=3.3;typeof(d)\nOut[4]: Float32\n\nIn [5]: e::UInt8=3;typeof(e)\nOut[5]: UInt8\n특별히 형을 지정하지 않았을 경우 정수는 Int64, 실수는 Float64 타입으로 암시적으로 지정됩니다. c 의 경우는 6.44 라는 Float64 의 값을 Float32 로 변환시켜 할당하였으며, d 의 경우는 변수를 Float32 타입으로 지정한 후 대입하여 자동적으로 변환되었습니다. e 의 경우도 UInt8 타입으로 지정한 후 3 을 할당하여 지정된 타입으로 자동적으로 변환되었습니다.\n\n\n\nJulia 의 타입은 추상적 타입(abstract type) 과 구체적 타입(concrete type) 으로 분류 할 수 있습니다. 구체적 타입은 변수가 지정되어 값을 할당 할 수 있지만 추상적 타입에는 변수를 지정 할 수 없으며, 값도 할당 할 수 없습니다. 억지로 할당할 경우 적당한 구체적 타입으로 변환됩니다. 우리가 지금까지 사용한 UInt8, Int64, Float64 등은 구체적 타입이며 아래의 예에서 AbstractFloat 는 부동소수에 대한 추상적인 타입입니다.\nIn [6]: aa=AbstractFloat(0.0);typeof(aa)\nOut[6]: Float64\n어떤 타입이 구체적인 타입인지 추상적인 타입인지는 isabstracttype() 함수나 isconcretetype() 함수로 확인 할 수 있습니다. Julia 에서 모든 타입은 Any 타입에서 뻗어나온 가지와 같은 계층구조를 가지고 있습니다. 예를 들어 julia 에서 제공하는 수 타입은 그림 1 와 같은 계층구조를 가집니다.\nJulia 에서 추상적 타입은 abstract 키워드를 사용하여 다음과 같이 정의합니다.\nabstract type Number end\nabstract type Real     &lt;: Number end\nabstract type AbstractFloat &lt;: Real end\nabstract type Integer  &lt;: Real end\nabstract type Signed   &lt;: Integer end\nabstract type Unsigned &lt;: Integer end\n위의 코드는 저자가 임의로 작성한 코드가 아니라 julia 에서 실제 추상 타입을 구현한 코드를 복사한 것입니다. abstract type Real &lt;: Number end 에서 Real &lt;: Number 는 Real 타입이 미리 정의된 Number 타입의 하위 타입 이란 의미입니다. Any 타입의 직접적인 하위타입은 &lt;: Any 없이 추상 타입을 정의 할 수 있습니다. 이렇게 정의된 것이 Number 타입입니다. Number 라는 수 전체를 아우르는 상위 타입이 있으며, 실수를 나타내는 Real 타입, 부동소수를 나타내는 AbstractFloat 타입, 정수를 나타내는 Integer 타입, 부호 있는 정수를 나타내는 Signed 타입, 부호 없는 정수, 즉 0 을 포함한 자연수를 나타내는 Unsigned 타입과 같은 추상 타입이 있습니다.\nJulia 의 모든 타입은 어떤 타입의 하위 타입(subtype) 이며 단 하나의 상위 타입(supertype) 을 계승합니다. 타입의 하위타입에는 갯수 제한이 없습니다. 타입 계층의 최상단에는 Any 타입이 있으며, 모든 타입은 Any 의 하위타입 이던가 Any 의 하위타입의 하위타입 이던가…. Any 의 몇대 자손중의 하나입니다. 심지어 Any 의 상위타입은 Any 입니다. 어떤 타입의 상위 타입을 알기 위해서는 supertype() 함수를 사용 하며 하위 타입들을 알기 위해서는 subtypes() 함수를 사용합니다.\nIn [7]: supertype(UInt8)\nOut[7]: Unsigned\n\nIn [8]: subtypes(Integer)\nOut[8]: 3-element Vector{Any}:\n Bool\n Signed\n Unsigned\n어떤 타입의 상위 타입은 추상적 타입만이 가능하며, 구체적 타입은 어떤 타입의 상위 타입이 될 수 없습니다. 당연히 Any 는 추상적 타입입니다. 그림 그림 1 은 Julia 에서 자체적으로 제공하는 수(number) 에 대한 타입의 계층 구조입니다. 추상적 타입은 좌우 변이 두겹인 사각형, 구체적 타입은 좌우가 둥근 도형으로 표현하였습니다. Irrational 은 \\(\\pi\\) 나 \\(e\\) 같은 특별한 무리수를 위한 타입으로 계산 될 때 적당한 타입의 값으로 변환됩니다.\n\n\n\n\n\n\nflowchart TB\n    Any[[Any]] --- Number[[Number]]\n    Number ---- Real[[Real]]\n    Number --- Complex[[Complex]]\n    Real ------- Integer[[Integer]] \n    Real --- Rational([Rational])\n    Real --- AbstractIrrational[[AbstractIrrational]]\n    Real ----- AbstractFloat[[AbstractFloat]]\n    Integer --- Unsigned[[Unsigned]] & Bool([Bool])\n    Integer ----- Signed[[Signed]]\n    AbstractIrrational --- Irrational[Irrational]\n    AbstractFloat --- Float16([Float16]) & Float32([Float32]) & Float64([Float64])  &  BigFloat([BigFloat])\n    Unsigned --- UInt8([UInt8]) & UInt16([UInt16]) & UInt32([UInt32]) & UInt64([UInt64]) & UInt128([UInt128])\n    Signed --- Int8([Int8]) & Int16([Int16]) & Int32([Int32]) & Int64([Int64])  & Int128([Int128]) & BigInt([BigInt])\n\n\n\n\n그림 1: Type hierarchy of number\n\n\n\n\n\n\n이것을 정리하면 다음과 같습니다.\n\n\n\n\n추상적 타입\n구체적 타입\n\n\n\n\n하위타입 지정\no\nx\n\n\n변수 할당\nx\no\n\n\n\n여기서 Complex 만 추상적 타입으로 구체적인 하위타입이 존재하지 않습니다. 실제로 Julia 에서 복소수는 복합 타입(composite type) 으로 정의됩니다. 여기에 대해서는 복합 타입에서 다루겠습니다.\n\n\n\n\nInt64 나 Float32 와 같이 값이 저장되는데 사용되는 바이트 수가 결정된 구체적 타입을 원시 타입(Primitive type) 이라고 합니다. isprimitivetype() 함수를 통해 특정 타입이 원시 타입인지를 확인할 수 있습니다. Julia 의 모든 기본 타입은 julia 자체 내에서 다음과 같이 정의되었습니다. 저의 경우는 Julia 설치 디렉토리의 /share/julia/base/boot.jl 파일에 정의되었습니다.\nprimitive type Float16 &lt;: AbstractFloat 16 end\nprimitive type Float32 &lt;: AbstractFloat 32 end\nprimitive type Float64 &lt;: AbstractFloat 64 end\n\nprimitive type Bool &lt;: Integer 8 end\nprimitive type Char &lt;: AbstractChar 32 end\n\nprimitive type Int8    &lt;: Signed   8 end\nprimitive type UInt8   &lt;: Unsigned 8 end\nprimitive type Int16   &lt;: Signed   16 end\nprimitive type UInt16  &lt;: Unsigned 16 end\nprimitive type Int32   &lt;: Signed   32 end\nprimitive type UInt32  &lt;: Unsigned 32 end\nprimitive type Int64   &lt;: Signed   64 end\nprimitive type UInt64  &lt;: Unsigned 64 end\nprimitive type Int128  &lt;: Signed   128 end\nprimitive type UInt128 &lt;: Unsigned 128 end\n첫번째 primitive type Float16 &lt;: AbstractFloat 16 end 는 Float16 타입은 AbstractFloat 타입의 하위타입으로 16비트, 즉 2바이트를 차지하는 타입이라는 의미입니다. 앞서 말했듯이 구체적 타입은 상위 타입이 될 수 없으므로 원시 타입은 어떤 추상 타입의 하위타입이 됩니다.",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "타입의 계층구조와 메서드 디스패치"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/08_type_hierarchy.html#sec-method_multiple_dispatch",
    "href": "src/introduction_to_julia/08_type_hierarchy.html#sec-method_multiple_dispatch",
    "title": "타입의 계층구조와 메서드 디스패치",
    "section": "2 메서드 다중 디스패치(Multiple dispatch)",
    "text": "2 메서드 다중 디스패치(Multiple dispatch)\n\n함수와 메서드\n각각의 컴퓨터 프로그래밍 언어나 프로그래밍 패러다임마다 함수와 메서드의 의미와 관계가 조금씩 다릅니다. 보통 프로그래밍에서 함수란 어떤 일련의 동작들을 모아 하나의 기능으로 만든 것을 말합니다. Julia 기본 문서의 Methods 를 보면 Julia 에서 보는 함수와 메서드는 이와는 약간 다릅니다. Julia 에서의 함수는 일종의 기능의 추상화입니다. 예를 들어 두 수를 더하는 함수를 생각해 봅시다. 먼저 원시 타입에 대한 더하기를 생각해보면, 원시 타입이란 특정한 비트의 배열이기 때문에 각 원시 타입마다 내부적으로 더하기를 다르게 구현해야 합니다. 하지만 모두 + 라는 연산자에 대해 정의됩니다. 이렇게 추상적으로 정의된 함수에 대해 각 타입마다 구체적으로 구현된 코드를 julia 에서는 메서드라고 부릅니다. 함수와 메서드의 의미와 관계는 언어마다 다르기 때문에 julia 에서 사용되는 용어가 다른 용어에서는 다른 의미 일 수 있습니다.\n다음의 함수 정의를 봅시다.\nIn [1]: function myfunc1(a, b)\n            return a*b\n        end\nOut[1]: myfunc1 (generic function with 1 method)\n함수를 정의할 때 특별히 인자에 제한조건을 두지 않았습니다. 이제 인자의 타입을 바꿔 가며 함수를 실행시켜봅시다.\nIn [2]: myfunc1(1, 3)\nOut[2]: 3\n\nIn [3]: myfunc1(2.2, 3.3)\nOut[3]: 7.26\n\nIn [4]: myfunc1(\"a\", \"bc\")\nOut[4]: \"abc\"\nJulia 는 함수의 정의를 기억했다가 처음 실행할 때 주어진 인자의 타입에 맞추어 컴파일하며 한 번 컴파일된 함수는 그 인자 타입으로 다음번 실행 할 때는 컴파일 없이 빠르게 실행 할 수 있습니다다. 이렇게 어떤 소스코드를 실행 전에 컴파일 하는 것이 아니라 실행하는 가운데 컴파일 하는것을 JIT(just-in-time) 컴파일 이라고 합니다\nmyfunc1 함수를 선언 할 때 인자의 타입에 대해 제한을 가하지 않았다는 것은 a, b 모두 Any 타입으로 지정되었다는 것입니다. 만약 a, b 모두 정수일 때, 즉 Integer 의 하위타입일 때는 곱하기가 아니라 더하기를 수행하기를 원한다고 해 봅시다.\nIn [5]: function myfunc1(a::Integer, b::Integer)\n        return a+b\n        end\nOut[5]: myfunc1 (generic function with 2 methods)\n\nIn [6]: myfunc1(1, 2)\nOut[6]: 3\n\nIn [7]: myfunc1(1.0, 2.0)\nOut[7]: 2.0\n\nIn [8]: myfunc1(1.0, 2)\nOut[8]: 2.0\n인자가 둘 다 정수일 때는 더하기가, 둘 중 하나라도 정수가 아니라면 곱하기가 수행됩니다. 만약 a 가 문자열이고 b 가 정수라면 a 를 b 의 절대값만큼 반복하도록 합시다.\nIn [9]: function myfunc1(a::String, b::Integer) \n        return a^abs(b)\n        end\nOut[9]: myfunc1 (generic function with 3 methods)\n\nIn [10]: myfunc1(\"aa\", -3)\nOut[10]: \"aaaaaa\"\n이렇게 우리는 인자 타입에 대해 myfunc1 이라는 함수 이름으로 3개의 메서드를 생성하였습니다.\n\n\n시그너쳐와 methods 함수\n메서드의 시그너쳐(signature) 는 함수이름과 인자, 그리고 인자의 타입을 포함합니다. 하나의 함수의 다양한 메서드는 시그너쳐로 구분되며, 한 함수의 시그너쳐는 method 함수로 확인 할 수 있습니다. methods(myfunc1) 는 함수 myfunc1 에 대한 모든 메서드의 시그너쳐를 반환합니다.\nIn [12]: methods(myfunc1)\nOut[12]: # 3 methods for generic function \"myfunc1\" from Main:\n [1] myfunc1(a::Integer, b::Integer)\n     @ REPL[5]:1\n [2] myfunc1(a::String, b::Integer)\n     @ REPL[9]:1\n [3] myfunc1(a, b)\n     @ REPL[1]:1\n여기서 볼 수 있듯이 myfunc1 함수에는 세가지의 메서드가 구현되었으며, 특정 타입에 대해 어떤 메서드가 실행될 지 파악 할 수 있습니다.\n\n함수 뿐만 아니라 연산자도 여러개의 메서드를 가질 수 있습니다. methods(+) 를 통해 + 연산자가 아주 많이 정의되었다는 것을 확인해 보시기 바랍니다. 이렇게 같은 함수나 연산자의 이름으로 인자의 타입에 따라 기능을 정하는 것을 메서드 디스패치, 혹은 다중 디스패치라고 합니다. 여러분은 앞으로 새로운 타입을 만드는 방법을 알게 될텐데 이미 존재하는 +, - 등의 연산자나 println, length 등의 함수를 다중 디스패치를 통해 타입에 맞게 사용 할 수 있습니다.\n\n\n\n\n모호한 메써드\n\\(a^b\\) 를 리턴하는 mypow 함수를 다음과 같이 구현했다고 해 봅시다.\nIn [1]: function mypow(a, b)\n        return a^b\n        end\nOut[1]: mypow (generic function with 1 method)\n\nIn [2]: function mypow(a::Number, b)\n        return a^b\n        end\nOut[2]: mypow (generic function with 2 methods)\n\nIn [3]: function mypow(a, b::Number)\n        return a^b\n        end\nOut[3]: mypow (generic function with 3 methods)\n\nIn [4]: methods(mypow)\nOut[4]: # 3 methods for generic function \"mypow\" from Main:\n [1] mypow(a::Number, b)\n     @ REPL[2]:1\n [2] mypow(a, b::Number)\n     @ REPL[3]:1\n [3] mypow(a, b)\n     @ REPL[1]:1\n3가지의 메서드가 구현되었습니다. 여기에 mypow(2, 3) 는 어떤 값을 리턴할까요? 컴파일러 입장에서는 두번째와 세번째 메써드가 동등한 권리를 갖고 있기 때문에 불확실 성이 존재하며 컴파일러는 에러를 발생시킵니다.\nIn [5]: mypow(2, 3)\nERROR: MethodError: mypow(::Int64, ::Int64) is ambiguous.\n\n\n\n타입 매개변수를 갖는 메서드\n메서드를 정의할 때 구체적, 추상적인 타입을 직접 표현하는 것이 아니라 타입 매개변수를 이용하여 정의 할 수도 있습니다. Julia 공식 문서의 예를 가져와 보겠습니다. 함수 인자 두개에 대해 그 타입이 같으면 true, 다르면 false 를 반환하는 함수를 작성해 봅시다. typeof 함수를 이용 할 수도 있겠지만 메서드를 이용하여 깔끔하게 정의 할 수도 있습니다. 일단 두개의 타입이 같으면 true 를 반환하는 함수를 작성합니다.\nIn [1]: same_type(x::T, y::T) where {T} = true\nOut[1]: same_type (generic function with 1 method)\n여기서 T 는 타입 매개변수 입니다. 함수의 인자 표현에서 x::T, y::T 는 x 와 y 가 그것이 무엇이든 같은 타입이어야 한다는 의미입니다. 타입이 다르면 적용할 메서드가 없다는 에러가 발생합니다.\nIn [2]: same_type(1, 2.0)\nERROR: MethodError: no method matching same_type(::Int64, ::Float64)\n타입이 다를 때는 false 를 반환하게 하려면\nIn [3]: same_type(x,y) = false\nOut[3]: same_type (generic function with 2 methods)\n와 같이만 하면 됩니다.\nIn [4]: same_type(1, 2.0)\nOut[4]: false\n이것이 작동하는 원리는 쉽습니다. 함수를 호출하면 메서드의 시그너쳐를 확인하여 실제 실행될 메서드를 찾는데 두 인자가 같은 타입일 경우 same_type(x::T, y::T) where {T} = true 메서드가 호출되며, 다른 타입일 경우 same_type(x,y) = false 메서드가 호출됩니다.\n\n타입 매개변수에 재한을 걸 수 있습니다. 예를 들어 다음을 봅시다.\nIn [10]: same_integer_type(x::T, y::T) where {T&lt;:Integer} = true\nOut[10]: same_integer_type (generic function with 1 method)\n\nIn [11]: same_integer_type(x, y) = false\nOut[11]: same_integer_type (generic function with 2 methods)\n\nIn [12]: same_integer_type(3, 4)\nOut[12]: true\n\nIn [13]: same_integer_type(UInt8(3), 4)\nOut[13]: false\n\nIn [14]: same_integer_type(3, 4.0)\nOut[14]: false\n두 변수 x, y 가 같은 종류의 정수 타입이 아니면 false 를 리턴합니다. 즉 다른 종류의 정수타입에도 false 를 반환합니다.\n\n\n함수 안에서의 타입매개변수\n함수에 타입 매개변수를 쓰는 또하나의 중요한 경우는 타입매개변수를 함수 안에서 사용하는 것입니다. 우리는 기본타입의 경우 타입 이름이 함수로 사용 될 수 있다는 것을 앞에서 보았습니다. 예를 들어 Float64(3) 에서 Float64 는 Int64 타입의 3 을 Float64 타입으로 변환시키는 함수로 사용되었습니다. 다음 함수를 봅시다.\nIn [1]: function myconvert(a::T, b) where {T}\n        return T(b)\n        end\nOut[1]: myconvert (generic function with 1 method)\n\nIn [2]: myconvert(2.0, 4)\nOut[2]: 4.0\n이 myconvert 함수는 두개의 인자를 받아 두번째 인자를 첫번째 인자의 타입으로 변환시켜 반환하는 함수입니다. 이 때 함수 시그니쳐의 타입 매개변수 T 가 함수의 몸체에서 사용되었습니다.\n\n\n\n아무것도 아닌 함수\n여러 메서드를 가지는 함수를 작성할 때 일단은 이름을 갖고 코드가 에러를 발생시키지는 않지만 실행은 안되는 함수가 필요할 때가 있습니다. 실용적으로 필요한 것이 아니라 문서화 작업 혹은 앞으로 작성할 함수라고 흔적을 남기기 위해 사용되기도 합니다.\nfunction great_function_with_many_methods end\ngreat_function_with_many_methods 은 함수로서 이름공간 포함되지만 아무 일도 할 수 없습니다.",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "타입의 계층구조와 메서드 디스패치"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/10_metaprogramming_and_macro.html",
    "href": "src/introduction_to_julia/10_metaprogramming_and_macro.html",
    "title": "메타프로그래밍과 매크로",
    "section": "",
    "text": "메타프로그래밍은 프로그램 실행중에 자기 자신 혹은 다른 프로그램을 읽고 수정하고 실행할 수 있는 기술을 말합니다. Julia 처럼 어떤 언어가 자기 자신을 메타프로그래밍 하는것을 reflection 이라고 합니다. Julia 에서는 메타프로그래밍이 macro 를 통해 구현됩니다. Julia 에서의 메타프로그래밍과 매크로를 이해하기 위해서는 소스코드가 어떻게 실행되는지 그 과정을 이해해야 합니다.",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "메타프로그래밍과 매크로"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/10_metaprogramming_and_macro.html#표현식",
    "href": "src/introduction_to_julia/10_metaprogramming_and_macro.html#표현식",
    "title": "메타프로그래밍과 매크로",
    "section": "1 표현식",
    "text": "1 표현식\n\n표현식의 생성\n\nMeta.parse\nJulia 에서 소스코드의 실행은 소스코드의 문자열을 파싱(parsing) 하여 Expr 객체인 표현식(expression) 을 만드는데서 시작합니다. 문자열을 표현식으로 바꾸는 함수는 Meta.parse 입니다. `\nIn [1]: ex1 = Meta.parse(\"1+2\")\nOut[1]: :(1 + 2)\n\nIn [2]: typeof(ex1)\nOut[2]: Expr\n\nIn [3]: ex1.head\nOut[3]: :call\n\nIn [4]: ex1.args\nOut[4]: 3-element Vector{Any}:\n  :+\n 1\n 2\nExpr 객체는 head 와 args 라는 두 부분으로 나뉩니다. head 는 Symbol 타입으로 표현식의 종류를, args 는 표현식에 사용되는 Symbol, 값, 구문 등을 의미합니다. 앞서 ex1.head 가 :call 인데 이것은 함수, 혹은 연산자 호출이라는 것을 의미합니다. 아래의 코드에서 보듯이 함수 호출이 아닌 할당에서는 head 가 :(=) 로 바뀝니다.\nIn [5]: ex2=Meta.parse(\"a=2\")\nOut[5]: :(a = 2)\n\nIn [6]: ex2.head, ex2.args\nOut[6]: (:(=), Any[:a, 2])\n\n표현식은 eval 함수를 통해 실행 할 수 있습니다.\nIn [8]: eval(ex1)\nOut[8]: 3\n\n\n\nQuoting\n우리는 앞서 심볼 타입 에서 a=:b 와 같이 : 를 사용하여 심볼 타입을 정의하는 것을 보았습니다. : 로 시작하는 구문은 심볼 타입 뿐만 아니라 표현식도 생성합니다. Out[1] 에서 보듯이 : 로 시작하여 ( ) 안에 표현된 구문은 표현식을 정의합니다. 이렇게 :( ) 를 이용하여 표현식을 정의하는 것을 quoting 이라고 합니다.\nIn [1]: ex1 = :(a=1+2)\nOut[1]: :(a = 1 + 2)\n\nIn [2]: ex2 = Meta.parse(\"a=1+2\")\nOut[2]: :(a = 1 + 2)\n\nIn [3]: ex1==ex2\nOut[3]: true\n\nIn [4]: eval(ex1)\nOut[4]: 3\n\nIn [5]: a\nOut[5]: 3\n\n\n표현식의 내부\n이제 표현식이 내부적으로 어떻게 구성되는지를 봅시다. 보통 두가지 방법이 있습니다. 하나는 dump 함수를 통해 들여쓰기와 참조 표시를 포함하여 출력하는 것입니다.\nIn [7]: dump(ex1)\nExpr\n  head: Symbol =\n  args: Array{Any}((2,))\n    1: Symbol a\n    2: Expr\n      head: Symbol call\n      args: Array{Any}((3,))\n        1: Symbol +\n        2: Int64 1\n        3: Int64 2\n다른 하나는 S-표현식 의 형태로 보는 것으로 Meta.show_sexp 함수를 이용합니다.\nIn [8]: Meta.show_sexpr(ex1)\n(:(=), :a, (:call, :+, 1, 2))\n\n\n\n:( ) 안에 값이 있는 경우\n한가지 유의해야 할 것은 표현식에 :(3) 처럼 :( ) 안에 값을 넣는다면 표현식이 아닌 값이 됩니다.\nIn [12]: :(3)\nOut[12]: 3\n\nIn [13]: :(3.34)\nOut[13]: 3.34\n\nIn [14]: :(\"aBγΔ\")\nOut[14]: \"aBγΔ\"\n\n\n\n\n\nquote ... end\n앞서 알아본 것처럼 :( ) 를 이용한 quting 을 통해 표현식을 정의 할 수 있으며 단순한 표현식에 적합합니다. 좀 더 복잡한 표현식을 위해서는 quote ... end 블럭을 다음과 같이 사용 할 수 있습니다.\nex = quote\n    x = 1\n    y = 2\n    x + y\nend\nex 는 :(x=1;y=2;x+y) 와 같습니다.\n\n\n\n표현식의 보간법\n\n$ 를 이용한 보간\n$ 를 이용한 문자열 보간처럼 $ 를 이용하여 표현식을 보간 할 수 있습니다.\nIn [1]: a=1;\n\nIn [2]: ex1 = :(b=$a+3)\nOut[2]: :(b = 1 + 3)\nex1 표현식 내의 $a 는 즉시 a 라는 변수가 가진 값 1 로 치환됩니다. $ 로 보간하지 않았을 경우에는 a 변수의 값이 바뀔 경우 그 결과가 달라집니다.\nIn [3]: ex2 = :(b=a+3)\nOut[3]: :(b = a + 3)\n\nIn [4]: eval(ex1), eval(ex2)\nOut[4]: (4, 4)\n\nIn [5]: a=4; eval(ex1), eval(ex2)\nOut[5]: (4, 7)\n앞서 말했듯이 $ 로 보간했을 때는 즉시 변수가 현재의 값으로 치환됩니다. 따라서 ex1 에는 변수 a 의 흔적이 남아 있지 않습니다. 그러나 $ 로 보간되지 않은 ex2 는 eval 함수가 실행 될 때의 a 값이 입력되므로 그 값이 바뀌게 됩니다.\nIn [6]: Meta.show_sexpr(ex1)\n(:(=), :b, (:call, :+, 1, 3))\n\nIn [7]: Meta.show_sexpr(ex2)\n(:(=), :b, (:call, :+, :a, 3))\n\n\n\n스플래팅 보간\n$ 를 이용한 보간은 한번에 하나의 표현식만 보간합니다. 앞서 알아본 … 연산자 처럼 표현식의 배열을 이용하여 한꺼번에 보간 할 수 있습니다.\nIn [1]: exprs = [:a, :b, :c]\nOut[1]: 3-element Vector{Symbol}:\n :a\n :b\n :c\n\nIn [2]: :(f(1, $(exprs...)))\nOut[2]: :(f(1, a, b, c))\n\n\n\n중첩된 quote\n앞서 우리는 표현식의 보간을 알아보았습니다. 표현식 또한 표현식에 보간 될 수 있습니다. 다음을 봅시다.\nIn [1]: ex = :(1+2);\n\nIn [2]: ex1 = quote $ex end\nOut[2]: quote\n    #= REPL[2]:1 =#\n    1 + 2\nend\n\nIn [3]: eval(ex1)\nOut[3]: 3\n\nIn [4]: ex2 = quote ex end\nOut[4]: quote\n    #= REPL[4]:1 =#\n    ex\nend\n\nIn [5]: eval(ex2)\nOut[5]: :(1 + 2)\n\nIn [6]: eval(eval(ex2))\nOut[6]: 3\nex 는 표현식이며 ex1 은 quoto ... end 안에 $ex 즉 1+2 라는 식을 삽입합니다. 따라서 ex1 은 quote 1+2 end 와 같습니다. ex2 는 quote ... end 안에 :(1+2) 를 삽입합니다. 따라서 ex2 는 quote :(1+2) end 와 같으며, eval(ex2) 는 (1 + 2) 를 반환합니다. 아래의 ex3 는 당연히 quote ex end 와 같습니다.\nIn [8]: ex3 = quote quote $ex end end\nOut[8]: quote\n    #= REPL[8]:1 =#\n    $(Expr(:quote, quote\n    #= REPL[8]:1 =#\n    $(Expr(:$, :ex))\nend))\nend\n\n\n\n\nQuoteNode\n\n\n\n함수를 호출하는 표현식\n두 수의 최대공약수를 구하는 함수는 gcd 입니다. 즉 gcd(4, 6) 은 2 입니다. 이 표현식에 대한 S-표현식은 다음과 같습니다.\nIn [1]: ex1 = :(gcd(4, 6))\nOut[1]: :(gcd(4, 6))\n\nIn [2]: Meta.show_sexpr(ex1)\n(:call, :gcd, 4, 6)\nS- 표현식을 이용하여 ex1 과 같은 표현식을 Expr(:call, :gcd, 4, 6) 을 통해 만들 수 있습니다.\nIn [3]: ex3 = Expr(:call, :gcd, 4, 6)\nOut[3]: :(gcd(4, 6))\n\nIn [4]: eval(ex3)\nOut[4]: 2\n즉 인자 op1, op1 를 받는 함수 func1 을 호출하는 표현식은 Expr(:call, :func1, op1, op2) 입니다. 만약 인자가 많아지면 계속 , 로 이어 쓰면 됩니다.",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "메타프로그래밍과 매크로"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/10_metaprogramming_and_macro.html#매크로",
    "href": "src/introduction_to_julia/10_metaprogramming_and_macro.html#매크로",
    "title": "메타프로그래밍과 매크로",
    "section": "2 매크로",
    "text": "2 매크로\n매크로는 인자를 받아 표현식을 반환하는 특별한 타입의 함수라고 볼 수 있습니다. mymacro 라는 함수에 인자로 ag1, ag2 를 입력 할 때 @mymacro(ag1, ag2) 혹은 @mymacro ag1 ag2 와 같이 실핼 시킬 수 있습니다. 좀 더 자세히 알아봅시다.\n\n매크로와 함수의 차이\n매크로에 인자를 입력 할 수 있으며, 역시 함수와 유사합니다. 그러나 매크로는 함수와 다른 몇가지 차이점이 존재합니다.\n\n매크로는 전역 범위 내에서만 정의 될 수 있습니다.\n매크로의 인자는 매크로 내부에서 인자에 대한 표현식으로 바뀝니다.\n매크로의 반환값은 표현식이며 반환값을 값으로 반환하지 않고 실행합니다.\n매크로는 함수처럼 괄호 안에 인자를 나열할 수도 있으며, 괄호 없이 공백으로 구분하여 나열할 수도 있습니다.\n\n\n1은 매크로가 함수 정의 안이나 for ... end 같은 블럭 내부에서 정의될 수 없다는 것을 말합니다. 함수는 이와 반대로 함수 내부나 블럭 내부에서 정의 될 수 있습니다.\n\n\n매크로의 정의와 반환값\n매크로는 인자들을 받아 표현식을 반환하는 함수를 의미합니다. 매크로는 함수와 비슷하게 macro ... end 구문으로 정의하며, 매크로 이름 앞에 @ 를 붙여 실행 할 수 있습니다.\nIn [1]: macro hello_world()\n            return :(println(\"Hello, world!\"))\n        end\nOut[1]: @hello_world (macro with 1 method)\n\nIn [2]: @hello_world()\nHello, world!\n\n\n\n매크로의 인자\n우선 매크로에 전달되는 인자가 매크로 내부에서 어떻게 되는지 알아봅시다.\nIn [1]: macro hello_world(your_name)\n            println(\"In macro, arg is = \", your_name, \", and the type is \", typeof(your_name))\n            return :(println(:\"Hello, world! I'm \", $your_name))\n        end\nOut[1]: @hello_world (macro with 1 method)\n\nIn [2]: @hello_world(\"Julia\")\nIn macro, arg is = Julia, and the type is String\nHello, world! I'm Julia\n\nIn [3]: @hello_world(1+1)\nIn macro, arg is = 1 + 1, and the type is Expr\nHello, world! I'm 2\nIn [3] 를 봅시다. 인자로 1+1 을 넣었을 때 macro 내부에서는 Expr 객체인 :(1+1) 로 인식이 된다는 것을 알 수 있습니다. In [2] 의 경우처럼 식이 아닌 값을 넣는 경우는 앞에서 언급했듯이 표현식이 값으로 바뀝니다.\n\n\n\n매크로의 반환값과 macroexpand 매크로\n매크로는 정의상 표현식을 반환하지만 실제로는 반환되는 표현식을 실행합니다. 표현식을 반환받기 위해서는 macroexpand 라는 매크로를 사용합니다.\nIn [10]: @macroexpand(hello_world(\"Julia\"))\nOut[10]: :(hello_world(\"Julia\"))\n@macroexpand 는 매크로 분석에 아주 유용한 메크로입니다. 앞으로 @macroexpand 와 같이 @ 로 시작하는 이름은 별다른 설명이 없다면 매크로를 의미합니다.\n\n\n\n매크로 실행시 인자의 입력\n매크로는 인자를 함수처럼 ( ) 안에 넣어서 전달 할 수도 있지만 매크로 이름 뒤와 인자들 사이에 공백을 두고 나열 할 수 있습니다.\nIn [1]: macro club_members(mem1, mem2, mem3)\n            return :(println(\"Members are : \", $mem1, \", \", $mem2, \", \", $mem3))\n            end\nOut[1]: @club_members (macro with 1 method)\n\nIn [2]: @club_members(\"John\", \"Jenny\", \"Jucy\")\nMembers are : John, Jenny, Jucy\n\nIn [3]: @club_members \"Henny\" \"Mark\" \"Tony\"\nMembers are : Henny, Mark, Tony\n\n\n\n\n(assert?) 매크로\n개인적으로 많이 사용하는 매크로입니다. @assert 매크로는 인자로 true 나 false 를 판별하는 표현식과 문자열을 받으며 표현식이 true 일 경우는 아무것도 하지 않고 false 일 경우는 에러를 내며 프로그램을 정지합니다. @assert 매크로는 built-in 이므로 julia 에서 추가 패키지 설치 없이 실행 할 수 있습니다.\nIn [1]: @assert 2==3 \"에러 메시지\"\nERROR: AssertionError: 에러 메시지\n...\n2==3 은 거짓이므로 에러를 발생시킵니다. 에러에는 여러 종류가 있으며 여기서는 AssertionError 를 발생시켰습니다. 에러를 발생시킬 때는 추가 메시지를 출력 할 수 있는데 (assert?) 의 두번째 인자가 바로 추가메시지 입니다. @macroexpand 를 통해 @assert 가 반환하는 표현식을 봅시다.\nIn [22]: @macroexpand @assert a==b\nOut[22]: :(if a == b\n      nothing\n  else\n      Base.throw(Base.AssertionError(\"a == b\"))\n  end)\n자 이제 이것과 같은 일을 하는 매크로를 작성 해 봅시다. 실제 @assert 매크로와는 다를 수 있지만 거의 똑같이 작동합니다.\nIn [1]: macro myassert(ex, msgs...)\n            msg = ((isempty(msgs) ? ex : msgs[1]) |&gt; string)\n            return :($ex ? nothing : AssertionError($msg))\n        end\nOut[1]: @myassert (macro with 1 method)\n\nIn [2]: @myassert 3&gt;4 \"맞을 경우는 메시지가 출력되지 않음\"\nOut[2]: AssertionError(\"맞을 경우는 메시지가 출력되지 않음\")\n\nIn [3]: @myassert 3&lt;4 \"맞을 경우는 메시지가 출력되지 않음\"\n\n\n\n청결한 매크로\n매크로에 전달되는 표현식이 매크로를 오염시킬 수 있습니다. 다음의 코드를 봅시다.\nmacro mm(ex)\n    return quote\n        t = 1\n        println(\"표현식 평가 이전 t = \", t)\n        val = $ex\n        println(\"표현식 평가 이후 t = \", t, \", val = \", val)\n        return val\n    end\nend\n@mm t=100 으로 실행시키면 다음과 같은 출력을 얻습니다.\n표현식 평가 이전 t = 1\n표현식 평가 이후 t = 100, val = 100\n100\n코드의 5 번째 줄 val = $ex 에서 실제로 수행하는 것은 val = t = 100 이며, t 와 val 모두 100 이 됩니다. 이 때 사용될 수 있는 것이 esc 함수입니다. esc 함수는 매크로 내에서만 사용 할 수 있는 함수로, 표현식을 평가할 때 내부 변수의 오염을 막아줍니다. 이제 다음 코드를 봅시다.\nmacro nn(ex)\n    return quote\n        t = 1\n        println(\"표현식 평가 이전 t = \", t)\n        val = $(esc(ex))\n        println(\"표현식 평가 이후 t = \", t, \", val = \", val)\n        val\n    end\nend\n@mm 과 @nn 의 차이는 5번째 줄에 esc 함수를 사용했다는 것 뿐입니다. @nn t=100 을 실행하면 우리가 원했던 오염되지 않은 결과를 얻습니다.\n표현식 평가 이전 t = 1\n표현식 평가 이후 t = 1, val = 100\n100\n\n\n\n코드 생성\n예를 들어 당신이 Float64 형태의 값에 대한 특별한 타입을 필요로 한다고 하자. 이 값은 일반적인 실수에 대해 sin 과 cos 값이 바뀌고, 따라서 tan 와 cot 함수값이 바뀌어야 한다고 하자. 실제로 이런 타입이 필요한지는 모르겠지만 일단은 연습이다. 새로운 타입을 XNum 이라고 하자. 물론 sin(v::XNum) = cos(v.val) 과 같이 네 함수에 대해 정의 할 수 있지만 표현식을 이용하여 다음과 같이 일괄적으로 바꿔 줄 수 있다.\nstruct XNum\n    val::Real\n\n    function XNum(v::Real)\n        return new(Float64(v))\n    end\nend\n\nfor (op1, op2) ∈ zip((:sin, :cos, :tan, :cot), (:cos, :sin, :cot, :tan))\n    eval(quote\n        Base.$op1(a::XNum) = XNum($op2(a.val))\n    end)\nend\nfor ... 문 안의 eval(ex::Expr) 함수는 표현식 ex 를 실행시키며 이것은 @eval 매크로를 사용하여 다음과 같이 쓸 수 있다.\nfor (op1, op2) ∈ zip((:sin, :cos, :tan, :cot), (:cos, :sin, :cot, :tan))\n    @eval Base.$op1(a::XNum) = XNum($op2(a.val))\nend",
    "crumbs": [
      "Julia 언어",
      "Julia 언어의 기초",
      "메타프로그래밍과 매크로"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/01_numerical_analysis_and_algorithm.html",
    "href": "src/numerical_analysis_using_julia/01_numerical_analysis_and_algorithm.html",
    "title": "수치해석 (Numerical Analysis) 과 알고리즘 (Algorithm)",
    "section": "",
    "text": "현대의 수치 해석은 어떤 수학적인 문제를 컴퓨터를 이용하여 계산하는 것이다. \\(4x+2=6\\) 과 같은 단순한 방정식의 해를 구하는 것 부터 아주 큰 행렬을 이용한 계산이나 복잡한 미분방정식을 푸는 것까지 사용되고 있다. 수치 해석이 필요한 이유는 복잡하거나, 계산의 양이 많거나, 정확한 해를 구하기가 힘들어 근사적으로 구해야 하는 등 사람이 직접 계산하기 힘든 난관이 존재하기 때문이다.\n우리는 5차 이상의 방정식이 해석적으로 풀리지 않는다는 것을 알고 있다. 방정식이 해석적으로 풀린다는 것은 \\(ax^2+bx+c=0\\) 의 해가 \\(\\dfrac{-b \\pm \\sqrt{b^2-4ac}}{2}\\) 인 것처럼 방정식의 계수들로 이루어진 식으로 존재하지 않는 다는 것이다. 자연과학과 공학에서 매우 중요한 미분방정식의 경우는 해가 존재하는 경우가 오히려 드물다. 점성을 가진 유체의 흐름을 기술하는 나비에-스토크스 방정식 (Navier-Stokes equation) 의 경우는 그 3차원에서 그 해가 존재하는지 여부가 소위 밀레니엄 문제로 지정되었으며, 보통 나비에-스토크스 방정식은 아주 제한된 경우에 근사적으로 수치해석을 이용하여 계산할 뿐이다.",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "수치해석 (Numerical Analysis) 과 알고리즘 (Algorithm)"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/01_numerical_analysis_and_algorithm.html#컴퓨터에서의-정수와-실수real-number-의-표현",
    "href": "src/numerical_analysis_using_julia/01_numerical_analysis_and_algorithm.html#컴퓨터에서의-정수와-실수real-number-의-표현",
    "title": "수치해석 (Numerical Analysis) 과 알고리즘 (Algorithm)",
    "section": "1 컴퓨터에서의 정수와 실수(Real number) 의 표현",
    "text": "1 컴퓨터에서의 정수와 실수(Real number) 의 표현\n현대의 컴퓨터는 2진수로 모든것을 표현한다. 하나의 2진 단위를 비트 (bit) 라 하며 보통 8개의 비트를 단위로 표현하는데 이렇게 2진수 8자리로 이루어진 단위를 바이트 (Byte) 라 한다. 우리가 다루는 컴퓨터는 정해진 수의 바이트 수에 특정한 규칙에 따라 수를 표현한다. 예를 들어 8비트, 즉 1바이트에 정수를 표현한다고 하자. 이것으로 표현 할 수 있는 정수는 28=256 개가 전부이다. 이것보다 더 많은 정수를 표현하기 위해서는 더 큰 비트수를 차지하는 정수형을 사용해야 한다. Julia 에서 실수 표현의 기본값으로 많이 쓰이는 64비트 부동 소수(floating number)의 경우에는 표현할 수 있는 실수의 갯수는 최대 264 (\\(\\approx\\) 1.8×1019) 이며 실제로는 이것보다 다소 작다. 아주 큰 수 이기는 하지만 무한은 아니다.\n\n\n정수의 표현\nIntroductio to Julia 의 기본적인 수 타입 과 정수형 타입 을 참고하라.\n\n참고로 정수를 _ 로 이어서 표현 할 수 있다. 예를 들어 1234 는 1_2_34 와 같다. _ 가 정수 표현의 맨 앞이나 맨 뒤만 아니면 상관 없다.\nIn [1]: 123456789 == 1_234_56_789\nOut[1]: true\n이 표현은 정수가 매우 큰 수일 때 입력오류를 줄이는데 유용하다.\n\n\n\n유리수의 표현\nJulia 에서는 유리수 타입이 기본 타입이며 // 를 이용하거나 Rational 함수를 이용하여 정의한다.\nIn [4]: 3//2\nOut[4]: 3//2\n\nIn [5]: Rational(3, 2)\nOut[5]: 3//2\n3//2 는 \\(\\dfrac{3}{2}\\) 이다. 유리수끼리, 혹은 유리수와 정수의 사칙연산의 결과는 유리수이다.\nIn [6]: 5//2*2\nOut[6]: 5//1\n\nIn [7]: 5//2 +3\nOut[7]: 11//2\n유리수 타입은 자동으로 인수분해를 해 준다. 다만 In [6] 에서 보았듯이 정수형으로 자동으로 바꿔주진 않는다.\nIn [8]: 121//33\nOut[8]: 11//3\n\n\n\n실수(Real Number) 의 표현\n빛의 속도 \\(c\\) 는 299792458 m/s = 0.299792458 x 109 m/s 이다. 여기서 0.299794568 부분을 가수(mentissa) 라고 하고 109 를 지수(exponent)라 한다. 실수를 이렇게 가수와 지수로 나누어 표현하는 것을 부동소수점 표현이라고 하며 실수(real number)를 컴퓨터에서 표현 할 때 부동소숫점 표현(floating point representation) 이 기본적으로 사용된다.\nJulia 는 부동소숫점 표현에서 The IEEE 754 기준을 따른다. 이 기준에 따르면, 64비트 실수 (이후 Float64 라 한다)의 경우 음수/양수 를 나타내는 1 비트, 지수를 나타내는 UInt 형식의 11비트, 가수를 나타내는 52비트로 이루어진다. 각각의 비트를 \\(b_0,\\,b_1,\\ldots,\\,b_{63}\\) 이라 하자. \\(0\\) 부터 시작하는 인덱스에 익숙하지 않은 독자를 위해 설명하자면 C, C++, Python 등 많은 언어는 배열의 인덱스를 \\(0\\) 부터 시작하도록 한다. Fortran 이나 Julia 는 \\(1\\) 시작하지만, 메모리 비트를 표현할때는 보통 \\(0\\) 부터 시작하는계 관례이므로 여기서는 \\(0\\) 부터 시작하도록 하자. 64 비트 실수형이므로 인덱스는 \\(0\\) 부터 \\(63\\) 까지 이다.실제로는 대부분의 컴퓨팅 연산의 기본이 IEEE 754 이다\n이 때 마지막 비트, 즉 \\(b_{63}\\) 을 최상위 비트라 하고, 양수인지, 음수인지를 나타내는 비트이다. 이 값을 \\(p\\) 라 하자. \\(0\\) 이면 양수, \\(1\\) 이면 음수이다. \\(b_{52}\\) 부터 \\(b_{62}\\) 까지는 지수 정보를 저장한다. 지수정보는 UInt 형식으로 저장되며 지수를 \\(e\\) 라 하면,\n\\[\ne= \\sum_{i=0}^{10} b_{52+i} 2^i\n\\]\n이다. \\(e\\) 는 \\(0\\) 부터 \\(2047\\) 까지의 값을 가질 수 있지만 실제 지수로서 기능하는 것은 \\(1\\) 부터 \\(2046\\) 까지이다. \\(e=0\\) 일 때와, \\(e=2047\\) 일 때는 뒤에 기술하는 특별한 방법을 사용한다.\n가수는 \\(b_{0}\\) 부터 \\(b_{51}\\) 까지의 비트에 저장된다. 가수 \\(m\\) 은 \\(e&gt;0\\) 인지 아닌지 여부에 따라 다르다.\n\\[\nm= \\left\\{ \\begin{array}{ll} 1.0+ \\displaystyle{\\sum_{i=1}^{52}} \\, b_{52-i}2^{-i} \\qquad & \\text{if }e&gt;0\\,,\\\\ \\displaystyle{\\sum_{i=1}^{52}}\\, b_{52-i}2^{-i} & \\text{if }e = 0\\,. \\end{array} \\right.\n\\]\n가수 \\(m\\)의 범위는 \\(e&gt;0\\) 일 때는 \\(1\\le m &lt; 2\\) 이고 \\(e=0\\) 일 때는 \\(0\\le m &lt; 1\\) 이다. \\(e&gt;0\\) 일 경우, 52 비트로 1.0 이하의 유효숫자를 표현하고 거기에 에 1을 더해주기때문에 실제적으로는 가수는 53 bit 로 저장된다고 볼 수 있다. \\(e=0\\) 일 경우는 52비트로 저장된다고 볼 수 있다. \\(2^{-53}  \\approx 1.1 \\times 10^{-16},\\, 2^{-52} \\approx 2.2 \\times 10^{-16}\\) 이므로 Float64 형식의 실수는 소수점 아래 17자리 이하의 가수의 차이는 구별 할 수 없다. 즉 \\(1.0 + 1.0 \\times 10^{-17}\\) 은 \\(1.0\\) 과 구별되지 않는다.\n이제 부호 \\(p\\) 와 지수 \\(e\\), 가수 \\(m\\) 을 이용해 실수 \\(r\\) 을 표현하면,\n\\[\nr=\\left\\{ \\begin{array}{ll} (-1)^p \\times m \\times 2^{e-1023}  \\qquad & \\text{if }e&gt;0\\,, \\\\ (-1)^p \\times m \\times e^{-1022} & \\text{if } e=0 \\,.\\end{array}\\right.\n\\]\n이다.\n한가지 언급하자면, \\(e=0,\\,m=0.0\\) 일 경우 \\(p\\) 값에 관계 없이 \\(0.0\\) 이 된다. 즉, 실수 \\(0.0\\) 을 Float64로 표현하는 방법은 2가지로 \\(+0.0\\) 과 \\(-0.0\\) 인데, 대부분의 언어는 특별한 경우를 제외하면 이 둘을 동일하게 처리하도록 되어 있다.\n\n\n\nNaN, \\(\\pm \\infty\\)\n앞서 지수 \\(e\\) 가 2047일 경우는 특별히 다룬다고 언급하였다.\nIEEE 754 표준에서는 NaN 과 양/음의 무한대 표현을 정의한다. 지수비트가 모두 \\(1\\) 이고 가수비트가 모두 \\(0\\) 이면 무한대를 의미한다. 부호비트가 \\(0\\) 이면 \\(+\\infty\\), 부호비트가 \\(1\\) 이면 \\(-\\infty\\) 이다.\n\\(e=2047\\) 이고 양과 음의 무한대를 표현하는 경우를 제외하면 모두 NaN 으로 처리한다. NaN 은 Not a Number 의 약자로, 연산 과정 등에서의 오류를 표현한다. NaN 도 종류에 따라 구분하는 경우가 있지만 여기서는 다루지 않는다.\n아래 표는 이런 특별한 표현을 정리한 것이다.\n\n\n\n\n\n\n\n\n\n\\(b_{63}\\)\n\\(b_{62}\\) ~ \\(b_{52}\\)\n\\(b_{51}\\) ~ \\(b_{0}\\)\n표현\n\n\n\n\n0\n00000000000\n0000000000000000000000000000000000000000000000000000\n+0.0\n\n\n1\n00000000000\n0000000000000000000000000000000000000000000000000000\n−0.0\n\n\n0\n11111111111\n0000000000000000000000000000000000000000000000000000\n\\(+\\infty\\)\n\n\n1\n11111111111\n0000000000000000000000000000000000000000000000000000\n\\(-\\infty\\)\n\n\n0\n11111111111\n0000000000000000000000000000000000000000000000000001\nNaN\n\n\n0\n11111111111\n1000000000000000000000000000000000000000000000000001\nNaN\n\n\n0\n11111111111\n1111111111111111111111111111111111111111111111111111\nNaN\n\n\n\n\n혹시나 관심있는 사람을 위해 bitstring 함수를 소개한다. 이 함수는 값을 비트표현의 문자열로 바꾸어준다.\nIn [9]: bitstring(0.0)\nOut[9]: \"0000000000000000000000000000000000000000000000000000000000000000\"\n\nIn [10]: bitstring(Inf)\nOut[10]: \"0111111111110000000000000000000000000000000000000000000000000000\"\n\nIn [11]: bitstring(-Inf)\nOut[11]: \"1111111111110000000000000000000000000000000000000000000000000000\"\n\nIn [12]: bitstring(UInt8(255))\nOut[12]: \"11111111\"\n\nIn [13]: bitstring(UInt8(1))\nOut[13]: \"00000001\"\n\n\n\nTrunctation error, Round-off error\n컴퓨터로 수치해석을 하는 경우 많은 오류가 있을 수도 있다. 프로그래밍적으로 오류가 발생하여 실행되지 않을 수도 있고, 프로그래머의 오류로 (예를 들면 더해야 하는데 곱한다던가) 틀린 답을 낼 수도 있다. 이런 인적 오류 이외에 발생할 수 있는 오류로는 truncation error 와 round-off error 가 있다.\nTruncation error 는 수학적 근사에서 기인하는 오차이다. 예를 들어 \\(e^x\\) 를 테일러 전개를 이용하여 계산한다면,\n\\[\ne^x \\approx 1+x+\\dfrac{x^2}{2} + \\dfrac{x^3}{3!} + \\cdots + \\dfrac{x^n}{n!}+ \\cdots\n\\]\n임을 이용한다. 그런데 컴퓨터는 무한번 계산을 할 수 없으므로 어느 정도에 끊어야 하며, 나머지 항에 의한 값이 오차가 될 것이다. 이러한 오차를 truncation error 라 한다. Truncation error 는 어쨌든 시간과 컴퓨터의 자원을 사용하기만 하면 대부분 원하는 정확도로 계산 할 수 있다.\nRound-off error 는 앞서 알아본 실수의 컴퓨터 표현에 의한 오차이다. 실수의 갯수는 무한대이며, 임의의 서로 다른 두 실수 사이에도 무한개의 실수가 존재한다. 그러나 64비트로 표현 가능한 실수는 최대한 \\(2^{64} \\approx 1.8\\times 10^{19}\\) 정도이다. 또한 앞서 알아봤듯이 유효숫자의 갯수는 10진수 표현으로 대략 16개 이며, IEEE 754 표준을 따르면 \\(3.6\\) 과 \\(3.6+1.0 \\times 10^{-16}\\) 은 구별되지 않는다. Julia 언어로 다음과 같이 계산해보자.\nIn [1]: 3.6-2.4-1.2\nOut[1]: 2.220446049250313e-16\n\nIn [2]: 3.6-1.2-2.4\nOut[2]: 4.440892098500626e-16\n다음과 같은 결과를 얻는다. 우리는 \\(3.6-2.4-1.2=0.0\\) 임을 알고 있지만, 컴퓨터로 계산한 결과는 다르다. 게다가 \\(3.6-2.4-1.2\\) 와 \\(3.6-1.2-2.4\\) 의 결과가 다르다. 이것은 불가피하며, 인간적인 관점에서는 다소 무작위적이기 때문에 계산을 하는 사람이 항상 주의해야 할 수 밖에 없다.\n또하나의 예를 들면,\nIn [3]: (3.4/1.6)*1.6\nOut[3]: 3.4000000000000004\n이다. 우리는 이 값이 3.4 이어야 함을 알고 있지만 ronnd-off 에러에 의해 결과가 \\(3.4+4.0\\times 10^{-16}\\) 으로 나왔다. 이는 Float64 에서 다루는 유효숫자의 갯수가 10진법으로 대략 16개 정도이기 때문에 발생한다.",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "수치해석 (Numerical Analysis) 과 알고리즘 (Algorithm)"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/01_numerical_analysis_and_algorithm.html#계산의-분석",
    "href": "src/numerical_analysis_using_julia/01_numerical_analysis_and_algorithm.html#계산의-분석",
    "title": "수치해석 (Numerical Analysis) 과 알고리즘 (Algorithm)",
    "section": "2 계산의 분석",
    "text": "2 계산의 분석\n특정 프로그래밍 언어를 사용하여 작성된 알고리즘이 어떤 정해진 문제를 해결하는 데 걸리는 시간을 예측하는 것은 거의 불가능하며, 보통 알고리즘을 실행 속도 측면에서 분석할 때는 수행 시간이 문제의 크기를 표현하는 변수 \\(n\\) 에 대해 점근적으로 어떻게 행동하는지 예측한다. 여기서 \\(n\\) 은 벡터의 차원, 행렬의 크기, 다항식의 차수(degree) 등을 의미한다. 보통 \\(n\\) 이 커짐에 따라 수행시간이 어떻게 되는지에 관심이 있기 때문에 \\(n\\to \\infty\\) 극한에서 생각하는데, 알고리즘의 계산 복잡도 (computational complexity) 를 분석하는 방법으로 많이 사용되는 것 중 하나가 대문자 \\(O\\) 표기법이다.\n\n\nFLOP\n수행 시간을 계산할 때 대상의 크기에 대한 변수 \\(n\\) 에 대해 몇번의 기본연산을 수행하는지를 따진다. 많이 사용되는 FLOP(floating-point operations) 는 계산에 수행되는 모든 스칼라 사칙연산과 제곱근을 1 flop 단위로 삼아 \\(n\\) 에 대한 함수 \\(T(n)\\) 으로 표현한다. 예를 들어 \\(n\\) 차원 공간에서의 두 벡터 u, v 의 내적은\nudotv = 0.0\nfor i = 1:n\n    udotv = udotv + u[i] * v[i]\nend\n를 통해 계산 할 수 있으며, \\(n\\) 번의 스칼라곱과 \\(n\\) 번의 스칼라합 계산이 수행되므로 내적에 대해서는 \\(T(n) = 2n = O(n)\\) 으로 표현한다. \\(n \\times n\\) 두 행렬 A, B 의 곱 C 는\nfor i = 1:n\n    for j = 1:n\n        for k = 1:n\n            C[i, j] = C[i, j] + (A[i, k] * B[k, j])\n        end\n    end\nend\n로 계산 할 수 있으며, \\(n^3\\) 번의 스칼라곱과 \\(n^3\\) 번의 스칼라 합 계산이 수행되므로 \\(T(n) = 2n^3\\) 이다.\n\n\n\n대문자 \\(O\\) 표기법\n예를 들어 \\(T(n) =  n^3+n\\) 이라고 하자. \\(n\\) 이 매우 클 경우 \\(T(n)\\) 의 값에 대한 기여는 대부분 \\(n^3\\) 에서 오며 \\(n\\) 이 기여하는 바는 미미하다. 이 때 함수를 가장 크게 기여하는 부분만을 표현하는 방법이 대문자 \\(O\\) 표기법이다.\n\n대문자 \\(O\\) 표기법의 정의\n자연수 \\(n\\) 에 대한 양의 함수 \\(f(n)\\), \\(g(n)\\) 에 대해 \\(f(n) = O(g(n))\\) 은\n\\[\n\\lim_{n \\to \\infty}\\dfrac{f(n)}{g(n)} &lt;\\infty\n\\]\n이 됨을 의미한다. 또한 \\(f(n) \\sim O(g(n))\\) 은\n\\[\n\\lim_{n \\to \\infty}\\dfrac{f(n)}{g(n)} =1\n\\]\n을 의미한다.\n\n보통 \\(O(f(n))\\) 에서 \\(f(n)\\) 은 가능한 함수 가운데 가장 간단한 함수를 사용한다. 예를 들어,\n\\[\n\\begin{aligned}\n2n^3-3n+1 &= O(n^2)\\\\\nn \\ln(n) + 3n &= O(n \\ln (n))\n\\end{aligned}\n\\]\n과 같다. 즉, \\(2n-1 = O(n)\\) 이다. \\(n \\times n\\) 행렬 \\(\\boldsymbol{A},\\,\\boldsymbol{B}\\) 의 곱 \\(\\boldsymbol{C}=\\boldsymbol{AB}\\) 를 생각하자. \\(C_{ij} = \\boldsymbol{A}_{i:}\\cdot \\boldsymbol{B}_{:j}\\) 이므로 \\(T(n) = 2n^3-n^2 = O(n^3)\\) 이다.",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "수치해석 (Numerical Analysis) 과 알고리즘 (Algorithm)"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/01_numerical_analysis_and_algorithm.html#알고리즘과-루프-불변성",
    "href": "src/numerical_analysis_using_julia/01_numerical_analysis_and_algorithm.html#알고리즘과-루프-불변성",
    "title": "수치해석 (Numerical Analysis) 과 알고리즘 (Algorithm)",
    "section": "3 알고리즘과 루프 불변성",
    "text": "3 알고리즘과 루프 불변성\n알고리즘은 어떤 문제가 주어졌을 때 이 문제를 풀기 위한 구체적인 방법으로 유한번의 절차 이후 종료되어야 한다. 수치해석에서 대부분의 중요한 알고리즘은 for ... end 나 while ... end 같은 루프문 과 if ... elseif ... else... end 같은 분기문으로 이루어져 있다. 루프로 이루어지는 알고리즘이 가져야 할 가장 중요한 성질이 루프 불변성 (loop invariance) 이다. 알고리즘상의 어떤 명제 혹은 식 \\(P\\)가 아래와 같은 성질을 만족하면 루프 불변이라고 한다.\n\n초기조건 : 루프가 첫 번째 반복을 시작하기 전에 \\(P\\)가 참이어야 한다\n유지조건 : 루프의 \\(N\\) 회차 반복이 시작되기 전에 \\(P\\) 가 참이었다면 \\(N+1\\) 회차 반복이 시작되기 전까지도 계속 참이어야 한다\n종료조건 : 루프가 종료될 때 \\(P\\)이 알고리즘의 타당성을 보이는 데 도움이 될 유용한 특성을 가져야 한다\n\n초기조건과 유지조건은 수학적 귀납법이 성립하는 조건과 동일하다는 것을 쉽게 알 수 있을 것이다. 세번째 종료조건이 여기에 고유한 것으로 어쨌든 알고리즘은 원하는 결과를 얻게 하며 종료되어야 한다.\n가장 간단한 문제로 두 자연수의 최대공약수를 구하는 유클리드 호제법을 생각해보자. 두 자연수 \\(n_1,\\,n_2\\) 에 대해 \\(n_1\\) 을 \\(n_2\\) 로 나눈 나머지를 \\(\\text{rem} (n_1,\\,n_2)\\) 라 하자. 두 자연수 \\(a\\), \\(b\\) 에 대한 최대공약수는 다음과 같은 절차로 얻을 수 있다.\n[과정 1] \\(a,\\,b\\) 중 큰 수를 \\(a_1\\), 작은 수를 \\(b_1\\) 이라 하자. \\(a=b\\) 이면 당연히 최대공약수는 \\(a(=b)\\) 이다.\n[과정 2] \\(n=2,\\,3,\\ldots,\\) 에 대해 \\(a_n\\), \\(b_n\\) 이 양의 정수이며 \\(a_n&gt;b_n\\) 일 때 \\(a_{n+1}=b_n,\\, b_{n+1}=\\text{rem}( a_n,\\,b_n)\\) 이라 한다. 이 과정을 \\(b_n=0\\) 이 될 때 까지 수행한다.\n[과정 3] \\(b_{n}=0\\) 일 때 \\(\\gcd(a,\\,b) = a_{n}\\) 이다.\n유클리드 호제법에 대해 다음 명제가 루프불변성을 가짐을 보이자.\n\n\\(a_n &gt; b_n&gt;0\\)\n\\(a_{n+1} &lt; a_n,\\, b_{n+1} &lt; b_n\\)\n\n첫번째 반복이 시작하기 전에 \\(a_1 = \\max \\{a,\\,b\\},\\,b_1 = \\min \\{a,\\,b\\}\\) 정의했으므로 1번을 만족한다. 2 번은 첫번째 루프에서 만족시킬 필요가 없다.이제 \\(N\\) 번 반복을 수행했을 때 위의 두 명제를 만족한다고 하자. \\(N+1\\) 번 수행한 \\(a_{n+1},\\,b_{n+1}\\) 이 이 조건을 만족하는것은 자명하다. 루프가 종료되는 조건은 \\(a_n=b_n\\) 일 때이다. \\(0&lt;a_{n+1}&lt;a_n\\) 이며 \\(a_n\\) 은 항상 자연수이므로 이 알고리즘은 필연적으로 \\(a_n=b_n\\) 이 되어 종료된다. 이때의 값이 두 수 \\(a,\\,b\\) 의 최대공약수이다.\nJulia 의 minmax(x, y) 함수는 x, y 중 작은값, 큰값을 튜플로 리턴한다. 즉 minmax(9, 7)=(9, 7) 이다. 이 함수를 이용하면 간단히 구현 할 수 있다. gcd 는 julia 내에 정의된 함수이므로 이것과 구별하기 위해 mygcd 함수로 구현해보자.\nfunction mygcd(a::T, b::T) where T&lt;:Integer \n    a, b = minmax(a, b)\n    while(b ≠ 0)\n        a, b = b, rem(a, b)\n    end\n    return a\nend",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "수치해석 (Numerical Analysis) 과 알고리즘 (Algorithm)"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/04_matrix_algebra.html",
    "href": "src/numerical_analysis_using_julia/04_matrix_algebra.html",
    "title": "Julia 에서의 행렬 계산",
    "section": "",
    "text": "지금까지는 Julia 의 기본적인 벡터와 행렬, 그리고 연산을 이용하여 일반적인 행렬에 대한 가우스 소거법과 LU 분해를 구현하였다. Julia 는 큰 벡터와 행렬을 다루기 위한 SparseArrays 모듈과 행렬 및 벡터 계산을 위한 LinearAlgebra 모듈을 기본으로 제공한다. 또한 다양한 형태의 행렬에 대한 특별한 연산도 제공한다. 이제 이런 기능들을 적극적으로 알아보도록 하자.",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "Julia 에서의 행렬 계산"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/04_matrix_algebra.html#sec-norm_and_condition_number",
    "href": "src/numerical_analysis_using_julia/04_matrix_algebra.html#sec-norm_and_condition_number",
    "title": "Julia 에서의 행렬 계산",
    "section": "1 노름(norm) 과 조건수",
    "text": "1 노름(norm) 과 조건수\n\n벡터의 노름\n벡터의 노름(norm) 은 벡터의 크기에 대한 척도로서 실수, 혹은 복소수의 절대값과 비슷한 역할을 한다. 보통 \\(n\\) 차원 공간에서 사용하는 피타고라스 정리에 의한 거리도 노름의 일종이다. 벡터공간에서의 노름은 특정한 성질을 만족하는 함수 가운데 선택된다.\n\n\n\n\n\n\n\n정의 1 (벡터공간의 노름) \\(\\mathbb{F}\\)-벡터공간 \\(V\\) 에서 정의된 함수 \\(\\|\\cdot\\| : V \\to \\mathbb{R}\\) 가 \\(\\boldsymbol{v},\\,\\boldsymbol{u}\\in V\\) 와 \\(\\alpha \\in \\mathbb{F}\\) 에 대해 다음을 만족할 때 이 함수는 벡터공간의 노름이 될 수 있다.\n  (\\(1\\)) \\(\\|\\boldsymbol{v}\\| \\ge 0\\),\n  (\\(2\\)) \\(\\|\\boldsymbol{v}\\| = 0 \\iff \\boldsymbol{v}=\\boldsymbol{0}\\),\n  (\\(3\\)) \\(\\|\\alpha \\boldsymbol{v} \\| = |\\alpha| \\|\\boldsymbol{v}\\|\\),\n  (\\(4\\)) \\(\\|\\boldsymbol{u}+\\boldsymbol{v}\\| \\le \\|\\boldsymbol{u}\\| + \\|\\boldsymbol{v}\\|\\).\n노름은 거리함수라고도 불리며 노름이 주어진 공간을 노름 벡터 공간 (normed vector space) 라고 한다.\n\n\n\n\n우리는 앞서 내적과 노름 에서 노름을 다루었다. 내적벡터공간에서는 내적에 의해 자연스럽게 노름을 정의할 수 있지만 노름 자체는 집합에 부여되는 성질이며 내적과 관계 없이 노름을 정의할 수도 있다. 즉 어떤 집합에 위의 노름이 정의되면 노름공간이라고 한다. \n벡터의 노름에 대한 성질을 알기 위해 다음 부등식을 알 필요가 있다.\n\n명제 1 (횔더부등식(Hölder’s inequality) 과 민코프스키 부등식(Minkowski’s ineqality)) \\(p\\ge 1\\) 이며 \\(1/p+1/q =1\\) 일 때 다음이 성립한다. \\[\n\\begin{aligned}\n\\text{H\\\"older's inequality} & \\sum_{i=1}^n |u_i v_i| \\le \\left(\\sum_{i=1}^n |u_i|^p\\right)^{1/p}\\left(\\sum_{i=1}^n |v_i|^q\\right)^{1/q}, \\\\\n\\text{Mincowski's inequality} & \\left(\\sum_{i=1}^n |u_i+v_i|^p\\right)^{1/p} \\le \\left(\\sum_{i=1}^n |u_i|^p\\right)^{1/p} + \\left(\\sum_{i=1}^n |v_i|^p\\right)^{1/p}.\n\\end{aligned}\n\\]\n\n\n(증명). 수학적 증명 의 Hölder 부등식 를 참고하라.\n\n\n\n\n\n\n\n\n\n정의 2 (\\(L_p\\)-노름 과 \\(\\infty\\)-노름) \\(p&gt;1\\) 에 대해 아래와 같이 정의된 \\(\\| \\cdot \\|_p : \\mathcal{M}_n(\\mathbb{F}) \\to [0, \\infty)\\) 는 노름이며 이 노름을 \\(L_p\\)-노름 이라고 한다.\n\\[\n\\|\\boldsymbol{v}\\|_p := \\left( \\sum_{i=1} |v_i|^p \\right)^{1/p}.\n\\]\n\n\n\n\n\n\\(p=1,\\,2,\\,\\infty\\) 인 경우가 많이 사용된다. \\(p=1\\) 인 경우는 맨해튼 노름(Manhattan norm) 혹은 taxicab norm 이라고 하며,\n\\[\n\\|\\boldsymbol{v}\\|_1 = \\sum_i |v_i|\n\\]\n이다. \\(p=2\\) 인 경우는 우리가 많이 사용하는 유클리드 노름(Euclidean norm) 으로\n\\[\n\\|\\boldsymbol{v}\\|_2 = \\sqrt{\\sum_i |v_i|^2}\n\\]\n이다. \\(p=\\infty\\) 인 경우는 상한 노름(maximum norm) 이라고 하며\n\\[\n\\|\\boldsymbol{v}\\|_{\\infty} = \\max_{i=1,\\ldots} |x_i|\n\\]\n이다. 혹은 단순히 \\(L_1,\\,L_2,\\,L_\\infty\\) 노름 이라고도 한다.\n\n다음은 쉽게 증명 할 수 있다.\n\n명제 2 \\(p=\\infty\\) 를 포함하여 \\(p \\ge 1\\) 일 때, 유한차원 벡터공간에서의 \\(L_p\\)-노름은 노름의 정의를 만족한다.\n\n\n\n\n\n\n\n\n\n정의 3 (노름의 동등함) 벡터공간 \\(V\\) 에 두개의 노름 \\(\\|\\cdot \\|_\\alpha\\) 와 \\(\\|\\cdot \\|_\\beta\\) 가 정의되었을 때, 모든 \\(\\boldsymbol{v}\\in V\\) 에 대해 어떤 상수 \\(c_1,\\,c_2\\) 가 존재하여\n\\[\nc_1 \\|\\boldsymbol{v}\\|_\\alpha \\le \\|\\boldsymbol{v}\\|_\\beta \\le c_2 \\|\\boldsymbol{v}\\|_\\alpha\n\\]\n라면 이 두 노름을 동등하다(equivalent) 라고 한다. 유한차원 벡터공간에 대해서는 모든 노름이 동등하다는 것이 알려져 있다.\n\n\n\n\n\n\n명제 3 \\(\\boldsymbol{v}\\in \\mathcal{M}_n(\\mathbb{F})\\) 에 대해 다음이 성립한다. 즉 \\(\\|\\cdot \\|_\\infty\\) 와 \\(\\|\\cdot \\|_2\\) 는 동등하다.\n\\[\n\\|\\boldsymbol{v}\\|_{\\infty} \\le \\|\\boldsymbol{v}\\|_2 \\le \\sqrt{n}\\|\\boldsymbol{v}\\|_\\infty\n\\]\n\n\n(증명). \\(v_M = \\max \\{ |v_i|, i=1,\\ldots,\\,v_n\\}\\) 이라고 하자. \\[\n\\|\\boldsymbol{v}\\|_\\infty = v_M \\le \\sqrt{\\sum_{i=1}^n |v_i|^2} = \\|\\boldsymbol{v}\\|_2 \\le \\sqrt{\\sum_{i=1}^n {v_M}^2} = \\sqrt{n} v_M = \\sqrt{n} \\|\\boldsymbol{v}\\|_\\infty\n\\]\n이다. \\(\\square\\)\n\n\nJulia 에서는 LinearAlgebra 모듈의 norm(v, p=2) 로 정의되는 함수를 이용하여 계산 할 수 있으며 p 는 1, 2, Inf 가 가능한데 각각 \\(L_1,\\,L_2,\\,L_\\infty\\) 노름을 의미한다. 노름이 정의된 벡터공간에서 벡터를 그 크기로 나누는 것 (\\(\\boldsymbol{v}/\\|\\boldsymbol{v}\\|\\)) 을 정규화(normalization) 라고 하며 역시 LinearAlgebra 모듈에 normalize(v, p=2) 함수로 구현되어 있다. norm(v, p=2) 에서 p=2 는 p 의 기본값이 2 라는 의미이다. 즉, norm(v) 로 벡터만을 인자로 하여 함수를 호출했을 경우는 p=2 일 경우를 계산한다.\nIn [1]: using LinearAlgebra\n\nIn [2]: v=[1, 2, 3];\n\nIn [3]: norm(v, 1)\nOut[3]: 6.0\n\nIn [4]: norm(v, Inf)\nOut[4]: 3.0\n\nIn [5]: norm(v, 2)\nOut[5]: 3.7416573867739413\n\nIn [6]: normalize(v)\nOut[6]: 3-element Vector{Float64}:\n 0.2672612419124244\n 0.5345224838248488\n\n\n\n행렬의 노름\n행렬의 노름(norm) 역시 행렬의 크기에 대한 척도로서 특정한 성질을 만족하는 함수 가운데 선택된다.\n\n\n\n\n\n\n\n정의 4 행렬의 노름 \\(\\|\\cdot \\|: \\mathcal{M}_{m\\times n}(\\mathbb{F}) \\to \\mathbb{R}\\) 은 행렬 \\(\\boldsymbol{A},\\, \\boldsymbol{B}\\) 와 스칼라 \\(\\alpha\\) 에 대해 다음의 성질을 만족한다.\n\n\\(\\|\\boldsymbol{A}\\| \\ge 0\\),\n\\(\\|\\boldsymbol{A}\\| = 0 \\iff \\boldsymbol{A} = 0\\),\n\\(\\|\\alpha \\boldsymbol{A}\\| = |\\alpha| \\|\\boldsymbol{A}\\|\\),\n\\(\\|\\boldsymbol{A}+\\boldsymbol{B}\\| \\le \\|\\boldsymbol{A}\\|+\\|\\boldsymbol{B}\\|\\).\n\n또한 \\(\\boldsymbol{A}\\in \\mathcal{M}_{m\\times n}(\\mathbb{F}),\\, \\boldsymbol{B} \\in \\mathcal{M}_{n\\times p}(\\mathbb{F})\\) 에 대해 다음이 성립한다.\n\n\\(\\|\\boldsymbol{AB}\\| \\le \\|\\boldsymbol{A}\\| \\cdot\\|\\boldsymbol{B}\\|\\).\n\n\n\n\n\n\n위의 정의 중 5번을 제외한 나머지 성질은 벡터에 대해서 성립하며, 5번은 행렬의 노름에만 성립하는 고유한 성질이다.\n\n\n프로베니우스 노름\n프로베니우스 노름은 힐버트-슈미트 노름(Hilbert-Schmidt norm), 혹은 슈어 노름(Schur norm) 으로도 불린다.\n선형대수학에서 배웠다시피 \\(\\mathcal{M}_{m\\times n}(\\mathbb{F})\\) 은 벡터공간을 이루며 각각의 \\(\\boldsymbol{A}\\in \\mathcal{M}_{m\\times n}(\\mathbb{F})\\) 도 벡터므로, 벡터에 대한 노름 처럼 행렬에 대한 노름도 정의 할 수 있다. 대표적으로 프로베니우스 노름(Frobenius norm) \\(\\|\\cdot \\|_F\\) 은 행렬을 벡터처럼 간주했을 때의 \\(L_2\\) 노름이다.\n\n\n\n\n\n\n\n정의 5 (프로베니우스 노름) \\(m \\times n\\) 행렬에 대한 프로베니우스 노름(Frobenius norm) 은 다음과 같이 정의된다. \\[\n\\|\\boldsymbol{A}\\|_F := \\left(\\sum_{i=1}^m \\sum_{j=1}^n |A_{ij}|^2\\right)^{1/2} = \\sqrt{\\text{tr}(\\boldsymbol{AA}^\\dagger)}\n\\]\n\n\n\n\n\n예제 1 프로베니우스 노름이 행렬의 노름의 정의에 나열된 5가지의 성질을 만족한다는 것을 보여라.\n\n\n\n\n자연스러운 노름\n행렬은 벡터공간에서 정의된 선형 함수로서의 의미가 더 중요하기 때문에, 벡터가 연산되었을 때 그 크기가 어떻게 되는지가 더 중요한 경우가 많다. 이런 의미에서 행렬의 노름을 벡터와의 연산에 대해 정의할 수 있는데 이렇게 정의된 행렬의 노름은 유도된 행렬 노름 (induced matrix norm), 자연스러운 행렬 노름(natural matrix norm) 혹은 종속된 노름(subordinate norm) 이라고 하며 정사각 행렬의 경우는 연산자 노름(operator norm) 이라고도 한다. 앞으로 행렬의 노름을 이야기할 때는 별다른 언급이 없다면 자연스러운 노름을 의미한다.\n\n\n\n\n\n\n\n\n정의 6 (행렬의 노름) \\(\\mathcal{M}_n(\\mathbb{F})\\) 에서의 노름이 \\(\\|\\cdot \\|_\\alpha\\), \\(\\mathcal{M}_m(\\mathbb{F})\\) 에서의 노름이 \\(\\| \\cdot \\|_\\beta\\) 로 정의되었다고 하자. \\(\\boldsymbol{A}\\in \\mathcal{M}_{m \\times n}(\\mathbb{F})\\) 에 대한 연산자 노름은 다음과 같이 정의된다.\n\\[\n\\|\\boldsymbol{A}\\|_{\\alpha,\\,\\beta} := \\sup \\{\\|\\boldsymbol{Av}\\|_\\beta : \\|\\boldsymbol{v}\\|_\\alpha=1\\} = \\sup_{\\|\\boldsymbol{v}\\|_\\alpha = 1} \\|\\boldsymbol{Av}\\|_\\beta\n\\]\n위의 정의와 다음의 정의는 같다. \\[\n\\|\\boldsymbol{A}\\|_{\\alpha,\\,\\beta} = \\sup \\left\\{\\dfrac{\\|\\boldsymbol{Av}\\|_\\beta}{\\|\\boldsymbol{v}\\|_\\alpha} : \\boldsymbol{v}\\in \\mathbb{F}^n,\\, \\boldsymbol{v}\\ne \\boldsymbol{0} \\right\\} = \\sup_{\\|\\boldsymbol{v}\\|_\\alpha \\ne 0}\\dfrac{\\|\\boldsymbol{Av}\\|_\\beta}{\\|\\boldsymbol{v}\\|_\\alpha}.\n\\]\n\n\n\n\n\n\n명제 4 자연스러운 노름은 행렬의 노름의 정의에 나열된 5 가지 성질을 만족한다.\n\n\n(증명). \\(1\\), \\(2\\), \\(3\\), \\(4\\)는 쉽게 보일 수 있다. 각각의 벡터공간에서 노름을 상징하는 아래첨자는 생략해도 이해하는데 무리가 없을 것이다.\n\\(\\text{5}\\). 우선 \\(\\|\\boldsymbol{Av}\\| \\le \\|\\boldsymbol{A}\\| \\cdot \\|\\boldsymbol{v}\\|\\) 임을 보이자. \\(\\boldsymbol{v}=\\boldsymbol{0}\\) 일 때는 자명하다. \\(\\boldsymbol{v}\\ne \\boldsymbol{0}\\) 이라면,\n\\[\n\\|\\boldsymbol{A}\\| = \\sup_{\\|\\boldsymbol{v}\\|\\ne 0} \\left\\{ \\dfrac{\\|\\boldsymbol{Av}\\|}{\\|\\boldsymbol{v}\\|} \\right\\} \\ge \\dfrac{\\|\\boldsymbol{Av}\\|}{\\|\\boldsymbol{v}\\|}\n\\]\n이므로 \\(\\|\\boldsymbol{Av}\\| \\le \\|\\boldsymbol{A}\\|\\cdot \\|\\boldsymbol{v}\\|\\) 이다. 이를 이용하면 \\[\n\\|\\boldsymbol{ABv}\\| \\le \\|\\boldsymbol{A}\\| \\cdot \\|\\boldsymbol{Bv}\\| \\le \\| \\boldsymbol{A}\\| \\cdot \\|\\boldsymbol{B}\\| \\cdot \\|\\boldsymbol{v}\\|\n\\]\n이므로 \\(\\dfrac{\\|\\boldsymbol{ABv}\\|}{\\|\\boldsymbol{v}\\|} \\le \\|\\boldsymbol{A}\\|\\|\\boldsymbol{B}\\|\\) 이다. 따라서,\n\\[\n\\|\\boldsymbol{AB}\\| =\\sup \\left\\{ \\dfrac{\\|\\boldsymbol{ABv}\\|}{\\|\\boldsymbol{v}\\|}\\right\\} \\le \\|\\boldsymbol{A}\\| \\|\\boldsymbol{B}\\|\n\\]\n이다. \\(\\square\\)\n\n\n다음은 증명 과정에서 보였지만 별도로 언급할 가치가 있다.\n\n따름정리 1 \\(\\|\\boldsymbol{Av}\\|\\le \\|\\boldsymbol{A}\\|\\cdot \\|\\boldsymbol{v}\\|\\) 이다.\n\n이것이 의미하는 것은 행렬 \\(\\boldsymbol{A}\\) 의 노름은 \\(\\boldsymbol{A}\\) 에 의해 변환되는 벡터의 노름이 변화하는 최대값을 규정한다는 것으로, 앞으로 매우 많이 나올 내용이다.\n행렬의 정의역(domain)과 공역(codomain)에서의 노름이 동일할 때 \\(\\|\\boldsymbol{A}\\|_\\alpha\\) 와 같이 노름에 대한 첨자를 하나만 표기한다. 또한 노름을 계산할 때 \\(L_p\\) 벡터 노름, 그중에서도 \\(p=1, 2, \\infty\\) 를 많이 사용한다. 즉\n\\[\n\\|\\boldsymbol{A}\\|_p = \\sup \\left\\{ \\dfrac{\\|\\boldsymbol{Av}\\|_p}{\\|\\boldsymbol{v}\\|_p}\\right\\}\n\\]\n이다.\n\n\n명제 5 \\(\\boldsymbol{A}\\in \\mathcal{M}_{m \\times n}(\\mathbb{F})\\) 일 때, \\[\n\\begin{aligned}\n\\|\\boldsymbol{A}\\|_\\infty &= \\max_{i=1,\\ldots,\\,m} \\sum_{j=1}^n |A_{ij}|,\\\\\n\\|\\boldsymbol{A}\\|_1 &= \\max_{j=1,\\ldots,\\,n} \\sum_{i=1}^m |A_{ij}|,\\\\\n\\end{aligned}\n\\]\n이다.\n\n\n(증명). 벡터 \\(L_p\\)-노름의 정의로부터, \\[\n\\|\\boldsymbol{Av}\\|_\\infty = \\sup \\left\\{ \\left|\\sum_{j=1}^n A_{ij}v_j\\right| : i=1,\\ldots,\\,m,\\, \\|\\boldsymbol{v}\\|_\\infty = 1 \\right\\}\n\\] 이다. \\(\\|\\boldsymbol{v}\\|_\\infty=1\\) 이면 \\(|v_j|\\le 1,\\, i=1,\\ldots,\\,n\\) 이므로 \\[\n\\left| \\sum_{j=1}^n A_{ij}v_j\\right| \\le \\sum_{j=1}^n |A_{ij}|\\cdot |v_j| \\le \\sum_{j=1}^n |A_{ij}|\n\\] 인데 \\(v_j = \\text{sign}(A_{ij})\\) 일 때 등호가 성립한다. 따라서, \\(\\displaystyle \\|\\boldsymbol{A}\\|_\\infty = \\max_{i=1,\\ldots,\\,m} \\sum_{j=1}^n |A_{ij}|\\) 이다.\n\\(\\|\\boldsymbol{A}\\|_1 = \\displaystyle \\sup_{\\|\\boldsymbol{v}\\|_1=1} \\|\\boldsymbol{Av}\\|_1\\) 이며, \\(\\displaystyle \\|\\boldsymbol{v}\\|_1 = \\sum_{j=1}^n |v_j|\\) 이다.\n\\[\n\\begin{aligned}\n\\|\\boldsymbol{Av}\\|_1 &= \\sum_{i=1}^m \\left| \\sum_{j=1}^n A_{ij}v_j\\right| \\le \\sum_{i=1}^m \\sum_{j=1}^n |A_{ij}| \\cdot |v_j| = \\sum_{j=1}^n |v_j| \\left(\\sum_{i=1}^n |A_{ij}|\\right) \\\\\n&\\le \\max_{j=1,\\ldots,n} \\left(\\sum_{i=1}^n |A_{ij}|\\right) \\\\\n\\end{aligned}\n\\]\n이다. \\(\\displaystyle \\sum_{i=1}^n |A_{ij}|\\) 이 최대가 되는 \\(j\\) 인덱스를 찾아 \\(j_M\\) 이라 하면\n\\[\n\\|\\boldsymbol{Ae}_{j_M}\\|_1 = \\sum_{i=1}^m |A_{i,j_M}| = \\max_{j=1,\\ldots,n} \\sum_{i=1}^m |A_{ij}|\n\\]\n이다. 따라서 \\(\\displaystyle \\|\\boldsymbol{A}\\|_1 = \\max_{j=1,\\ldots,\\,n}\\sum_{i=1}^m |A_{ij}|\\) 이다. \\(\\square\\)\n\n\nJulia 에서 행렬의 \\(L_p\\) 노름은 opnorm(A, p=2) 로 구현되었으며 가능한 p 값은 1, 2 와 Inf 로 각각 \\(L_1,\\, L_2,\\,L_\\infty\\) norm을 계산한다. Frobenius 노름은 norm(A, 2) 로 벡터의 norm 처럼 계산 할 수 있다.\nIn [7]: A = [1 3 2; 4.0 2.0 -3.0];\n\nIn [8]: opnorm(A, 1), opnorm(A, 2), opnorm(A, Inf)\nOut[8]: (5.0, 5.47722557505166, 9.0)\n\nIn [9]: norm(A, 2) # Frobenius norm\nOut[9]: 6.557438524302",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "Julia 에서의 행렬 계산"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/04_matrix_algebra.html#다양한-행렬들",
    "href": "src/numerical_analysis_using_julia/04_matrix_algebra.html#다양한-행렬들",
    "title": "Julia 에서의 행렬 계산",
    "section": "2 다양한 행렬들",
    "text": "2 다양한 행렬들\n\n성긴행렬과 밀집행렬\n수학적으로 성긴행렬(혹은 희소행렬, sparse matrix) 은 행렬 성분의 대다수가 0 인 행렬을 의미하며, 반대의 경우를 밀집 행렬(dense matrix) 이라고 한다. 우리가 지금까지 다룬 행렬들은 행렬의 모든 성분을 컴퓨터가 저장하였다. 그러나 행렬이 매우 큰 경우, 예를 들면 Float64 타입의 \\(100K \\times 100K\\)(\\(1K=1,000\\)) 행렬은 성분을 저장하는 데만 80 Gbytes 의 저장공간을 차지하므로 개인 컴퓨터에서는 처리가 거의 불가능하며, 실제로 많이 다루는 시스템은 이것보다 훨씬 클 수 가 있다. 다행히 우리가 관심있는 시스템 가운데 상당수는 행렬의 대부분의 성분이 \\(0\\) 인데, 이 경우 행렬의 모든 성분을 저장하는 것이 아니라 \\(0\\) 이 아닌 성분만을 그 인덱스와 함께 저장하여 더 작은 저장공간에서 더 빠르게 계산 할 수 있다. 수치해석에서는 이렇게 행렬의 인덱스와 값을 저장하고, 인덱스가 지정되지 않은 행렬을 \\(0\\) 으로 간주하는 행렬을 성긴 행렬이라 하며, 우리가 지금 까지 다뤘던, 인덱스에 따라 순차적으로 성분을 저장하는 행렬을 밀집 행렬 (dense matrix) 이라 한다.\n다차원 배열에 대해서도 성긴 배열을 생각 할 수 있으며 Julia 의 표준 라이브러리에 포함된 SparseArrays 모듈을 이용하여 1차원 배열인 성긴 벡터와, 2차원 배열인 성긴 행렬을 지원한다. Julia 에서의 희소행렬은 내부적으로 아래와 같이 구현되어 있다. 5개의 멤버를 갖는 구조체이며 행렬의 크기와, 행, 열, 값을 갖는다. SmarseMatrixCSC 의 CSC 는 희소행렬을 내부적으로 저장할 때 쓰는 일종의 압축 방식을 표현한다.\nstruct SparseMatrixCSC{Tv,Ti&lt;:Integer} &lt;: AbstractSparseMatrixCSC{Tv,Ti}\n    m::Int                  # Number of rows\n    n::Int                  # Number of columns\n    colptr::Vector{Ti}      # Column j is in colptr[j]:(colptr[j+1]-1)\n    rowval::Vector{Ti}      # Row indices of stored values\n    nzval::Vector{Tv}       # Stored values, typically nonzeros\nend\n가장 기본적인 생성 방법은 sparse() 함수를 이용하는 것이다. 아래의 예에서 A 는 밀집행렬이며 이것을 sparse 함수를 통해 희소행렬로 만들었다. 혹은 sparse(I, J, V) 를 통해서도 생성할 수 있는데, I 는 행 인덱스를 나타내는 벡터, J 는 열 인덱스를 나타내는 벡터, V 는 값을 나타내는 벡터이다. 즉, B=sparse(I, J, V) 라면,\n\\[\nB_{I[i], J[i]}=V[i], \\, i=1,\\,2,\\ldots\n\\]\n이다.\nIn [1]: using LinearAlgebra, SparseArrays\n\nIn [2]: A = Matrix(1.0I, 3, 3)\nOut[2]: 3×3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\nIn [3]: sparse(A)\nOut[3]: 3×3 SparseMatrixCSC{Float64, Int64} with 3 stored entries:\n 1.0   ⋅    ⋅ \n  ⋅   1.0   ⋅ \n  ⋅    ⋅   1.0\n\nIn [4]: B = sparse([1, 1, 2, 3], [1, 3, 2, 3], [-1.0, 2.0, 0.0, 4.0])\nOut[4]: 3×3 SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n -1.0   ⋅   2.0\n   ⋅   0.0   ⋅ \n   ⋅    ⋅   4.0\n\nIn [5]: dropzeros(B)\nOut[5]: 3×3 SparseMatrixCSC{Float64, Int64} with 3 stored entries:\n -1.0   ⋅   2.0\n   ⋅    ⋅    ⋅ \n   ⋅    ⋅   4.0\n마지막의 dropzeros() 함수는 희소 행렬 내의 \\(0\\) 을 제거하여 저장공간을 줄인다. B=sparse(I, J, V) 형식으로 생성하면, B 행렬의 크기는 I 와 J 벡터의 최대값으로 정해지지만, 행렬의 크기를 정할 수 있다. 예를 들어,\nIn [6]: sparse([1, 2], [1, 3], [1, -1], 4, 4)\nOut[6]: 4×4 SparseMatrixCSC{Int64, Int64} with 2 stored entries:\n 1  ⋅   ⋅  ⋅\n ⋅  ⋅  -1  ⋅\n ⋅  ⋅   ⋅  ⋅\n와 같이 sparse(I, J, V, m, n) 형식으로 생성하면 이 희소행렬은 \\(m \\times n\\) 행렬이 된다. 희소벡터는 sparsevec(I, V, m) 형식으로 생성 할 수 있다.\nIn [7]: sparsevec([1, 4], [2, -1], 5)\nOut[7]: 5-element SparseVector{Int64, Int64} with 2 stored entries:\n  [1]  =  2\n  [4]  =  -1\n영행렬 혹은 영벡터는 spzeros() 함수를 통해 생성한다. 성긴 단위행렬은 sparse(I, 4, 4) 와 같이 생성한다. 단 I 는 LinearAlgebra 모듈에 정의되어 있으므로 using LinearAlgebra 를 한 후 사용할 수 있다.\nusing LinearAlgebra, SparseArrays\nsm1 = spzeros(Float32, 10, 10) # Float32 타입의 값을 갖는 10x10 성긴행렬\nsm2 = spzeros(5, 5) # 타입이 지정되지 않으면 Float64 타입의 값을 갖는다.\nsv = spzeros(4) #Float64 타입의 4 차원 벡터\nsI = sparse(I, 4, 4) # 4xt 단위행렬\n\n\n\n타입으로 정의된 행렬\nLinearAlgebra.jl 은 선형대수학에서 사용되는 특별한 명칭이 붙은 행렬중 일부를 특별히 별도의 타입으로 지정하였다. 아주 단순한 예를 들자면 선형 시스템 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 를 풀 때, \\(\\boldsymbol{A}\\) 가 대각성분을 제외한 성분이 모두 \\(0\\) 인 대각행렬이라면 쉽게 풀 수 있으며, 상삼각행렬이나, 하삼각행렬이라도 일반적인 행렬에 비해서도 훨씬 쉽게 풀 수 있다. 그러나 컴퓨터가 임의로 \\(\\boldsymbol{A}\\) 가 어떤 행렬인지 결정하게 하기는 힘들며, 때때로 바람직 하지 않은 오류를 낼 수 있다. Julia 에서는 다중 디스패치를 이용할 수 있으므로 행렬 \\(\\boldsymbol{A}\\) 를 각각의 형태에 맞는 타입으로(대각행렬이라든가, 상삼각행렬이라든가) 정해 줄 수 있다면 이에 맞춰서 선형 시스템을 푸는 함수를 공통적으로 정의 할 수 있다. 즉 solve_linearsystem_diagonal, solve_linearsystem_uppertriangula 등을 따로 정의 할 필요 없이 solve_linearsystem(A::Diatonal), solve_linearsystem(A::UpperTriangula) 와 같이 할 수 있다는 뜻이다.\nLinearAlgebra.jl 에 정의된 특수한 타입으로서의 행렬의 목록은 아래와 같다.\n\n\n\n\n\n\n경고\n\n\n\n아래의 목록에 정의된 행렬의 타입들 가운데 상당수는 성긴행렬이다. 굳이 밀집행렬로 바꾸고 싶다면 Matrix(A) 를 사용한다.\n\n\n\n\n\n\n\n\n\n\n\n타입\n명칭\n설명\n\n\n\n\nUniformScaling\nUniform scaling operator\nc\\(\\boldsymbol{I}\\)\n\n\nDiagonal\n대각행렬 (Diagonal matrix)\n\n\n\nBidiagonal\n상/하 쌍대각 행렬 (Upper/lower bidiagonal matrix)\n\n\n\nTridiagonal\n삼중 대각 행렬 (Tridiagonal matrix)\n\n\n\nSymTridiagonal\n대칭 삼중 대각 행렬 (Symmetric tridiagonal matrix)\n\n\n\nUpperTriangular\n상삼각행렬 (Upper triangular matrix)\n\\(i&gt;j \\implies A_{ij}=0\\)\n\n\nUnitUpperTriangular\n단위 상삼각행렬 (Upper triangular matrix with unit diagonal)\n상삼각행렬이며 대각성분이 \\(1\\)\n\n\nLowerTriangular\n하삼각행렬 (Lower triangular matrix)\n\\(i&lt;j \\implies A_{ij}=0\\)\n\n\nUnitLowerTriangular\n단위 하삼각행렬 (Lower triangular matrix with unit diagonal)\n하삼각행렬이며 대각성분이 \\(1\\)\n\n\nUpperHessenberg\n상 헤센베르크 행렬 (Upper Hessenberg matrix)\n\n\n\nSymmetric\n대칭 행렬 (Symmetric matrix)\n\\(\\boldsymbol{A} =\\boldsymbol{A}^T\\)\n\n\nHermitian\n에르미트 행렬 (Hermitian matrix)\n\\(\\boldsymbol{A} =\\boldsymbol{A}^\\ast\\)\n\n\n\n\n\nUniformScaling\nUniformScaling 은 단위행렬에 상수를 곱한것을 말한다. UniformScaling(2.0) 은 (2.0 이 Float64 타입의 부동소수이므로) Float64 타입의 성분을 갖는 단위행렬이다. 다만 아직까지는 차원이 정해지지 않으며 다른 행렬과 연산될 때 적절한 차원을 갖게 된다. 단위행렬을 나타내는 I 를 대신 사용 할 수 있으며, UniformScaling(2.0)==2.0I 이다.\nIn [1]: using LinearAlgebra, SparseArrays\n\nIn [2]: 2.0I + 3\nOut[2]: 5.0\n\nIn [3]: 2.0I + [0  1; 2 3]\nOut[3]: 2×2 Matrix{Float64}:\n 2.0  1.0\n 2.0  5.0\n\n\n\nDiagonal\n대각행렬을 나타내는 타입이다. \\(n\\) 차원 벡터를 입력하면 차례로 대각성분이 되는 대각행렬을 만든다.\nIn [4]: Diagonal([1, 10, 100])\nOut[4]: 3×3 Diagonal{Int64, Vector{Int64}}:\n 1   ⋅    ⋅\n ⋅  10    ⋅\n ⋅   ⋅  100\nDiagonal 타입의 행렬에 UniformScaling 을 더하면, 아마 여러분이 예상한 결과가 나올 것이다.\nIn [5]: Diagonal([1, 10, 100]) + 3.0I\nOut[5]: 3×3 Diagonal{Float64, Vector{Float64}}:\n 4.0    ⋅      ⋅ \n  ⋅   13.0     ⋅ \n  ⋅     ⋅   103.0\n\n\n\nBidiagonal, Tridiagonal, SymTridiagonal\n\\(m\\times n\\) 행렬 \\(A_{ij}\\) 에서 \\(A_{ii},\\, i=1,\\ldots,\\, \\min \\{m,\\,n\\}\\) 을 대각(diagonal) 성분이라 한다. 대각 성분의 바로 오른쪽 성분, 즉 \\(A_{i,\\, i+1}\\) 을 상대각 (superdialgonal) 성분이라 하며, 왼쪽 성분, 즉 \\(A_{i+1,\\,i}\\) 을 하대각(subdiagonal) 성분이라 한다.(적절한 번역어를 못찾아서 임의로 붙인 이름이다.)\n대각행렬과 대각성분 근처의 일부만을 제외한 모든 성분이 \\(0\\) 인 행렬을 띠행렬 (Band matrix)이라 한다. 대각성분과 상대각 성분/하대각 성성분 가운데 하나를 제외한 모든 성분이 \\(0\\) 인 행렬을 각각 상쌍대각 행렬/하쌍대각 행렬이라 한다. 아래의 보기에서 \\(\\boldsymbol{B}_U\\) 는 상쌍대각행렬, \\(\\boldsymbol{B}_L\\) 은 하쌍대각행렬이다.\n\\[\n\\boldsymbol{B}_U = \\begin{bmatrix} 4 & 1 & 0 &0  \\\\ 0 & 3 & 1 & 0 \\\\ 0 & 0 & 2 &  2 \\\\ 0 & 0 & 0 & 5 \\end{bmatrix} ,\\qquad \\boldsymbol{B}_L = \\begin{bmatrix} 4 & 0 & 0 &0  \\\\ 1 & 3 & 0 & 0 \\\\ 0 & 1 & 2 &  0 \\\\ 0 & 0 & 2 & 5 \\end{bmatrix}\n\\]\n쌍대각 행렬은 Bidiagonal 객체로 표현되며, 두가지 방법으로 구성 할 수 있다. 첫번째 방법은 생성자에(객체의 생성자이므로 객체와 같은 이름을 가진다.) 첫번째 인자로 대각성분을, 두번째 인자로 \\(0\\) 이 아닌 대각성분의 위/아래 성분을, 세번째 인자로 상쌍대각행렬이면 :U 를 하쌍대각행렬이면 :L 을 입력하는 방법이다.\nIn [6]: Bu = Bidiagonal([4, 3, 2, 5], [1, 1, 0], :U)\nOut[6]: 4×4 Bidiagonal{Int64, Vector{Int64}}:\n 4  1  ⋅  ⋅\n ⋅  3  1  ⋅\n ⋅  ⋅  2  0\n ⋅  ⋅  ⋅  5\n\nIn [7]: Bl = Bidiagonal([4, 3, 2, 5], [1, 1, 2], :L)\nOut[7]: 4×4 Bidiagonal{Int64, Vector{Int64}}:\n 4  ⋅  ⋅  ⋅\n 1  3  ⋅  ⋅\n ⋅  1  2  ⋅\n ⋅  ⋅  2  5\nBidiangoal 타입 행렬을 구성하는 두번째 방법은 이미 존재하는 행렬로부터 대각성분을 포함한 \\(0\\) 이 아닌 성분을 가져오는 방법이다. 다음을 보면 쉽게 이해 할 수 있을 것이다.\nIn [9]: A = [1 1 1 1; 2 2 2 2; 3 3 3 3; 4 4 4 4]; Bidiagonal(A, :U)\nOut[9]: 4×4 Bidiagonal{Int64, Vector{Int64}}:\n 1  1  ⋅  ⋅\n ⋅  2  2  ⋅\n ⋅  ⋅  3  3\n ⋅  ⋅  ⋅  4\n\nIn [10]: Bidiagonal(A, :L)\nOut[10]: 4×4 Bidiagonal{Int64, Vector{Int64}}:\n 1  ⋅  ⋅  ⋅\n 2  2  ⋅  ⋅\n ⋅  3  3  ⋅\n ⋅  ⋅  4  4\n\n대각성분, 상대각성분, 하대각성분을 제외한 성분이 모두 \\(0\\) 인 성분을 삼중대각행렬 (Tridiagonal matrix) 라 하며 LinearAlgebra.jl 에서는 Tridiagonal 타입으로 정의된다. 아래의 행렬 \\(\\boldsymbol{C}\\) 는 삼중 대각행렬이다.\n\\[\n\\boldsymbol{C} = \\begin{bmatrix} 4 & 1 & 0 & 0 & 0 \\\\ 2 & 3 & 1 & 0 & 0 \\\\ 0 & 3 &1& 2 &  0 \\\\ 0 & 0 & 2& 5 & 1 \\\\ 0 & 0 & 0 &3 & 6 \\end{bmatrix}\n\\]\n삼중대각행렬을 구성하는 방법은 쌍대각행렬을 구성하는 방법과 비슷하게 두가지 방법이다. 하나는 대각행렬 아래 성분들을 나타내는 벡터, 대각성분벡터, 대각성분 위의 성분들을 나타내는 벡터를 차례로 입력하는 것이다.\n위의 행렬 \\(\\boldsymbol{C}\\) 를 구성한다면\nIn [11]: C = Tridiagonal([2, 3, 2, 3], [4, 3, 1, 5, 6], [1, 1, 2, 1])\nOut[11]: 5×5 Tridiagonal{Int64, Vector{Int64}}:\n 4  1  ⋅  ⋅  ⋅\n 2  3  1  ⋅  ⋅\n ⋅  3  1  2  ⋅\n ⋅  ⋅  2  5  1\n ⋅  ⋅  ⋅  3  6\n와 같이 할 수 있다.\n다른 방법은 이미 존재하는 행렬로부터 구성하는 것이다.\nIn [13]: D = [1 2 3 4 5]' *ones(Int64, 5)'\nOut[13]: 5×5 Matrix{Int64}:\n 1  1  1  1  1\n 2  2  2  2  2\n 3  3  3  3  3\n 4  4  4  4  4\n 5  5  5  5  5\n\nIn [13]: Tridiagonal(D)\nOut[13]: 5×5 Tridiagonal{Int64, Vector{Int64}}:\n 1  1  ⋅  ⋅  ⋅\n 2  2  2  ⋅  ⋅\n ⋅  3  3  3  ⋅\n ⋅  ⋅  4  4  4\n ⋅  ⋅  ⋅  5  5\nSymTridiagonal 은 대칭인 삼중대각행렬을 나타내는 타입이다. 대칭행렬이므로 대각행렬의 위 띠와 아래띠가 같다. 이것은 어떻게 구성할까? 여러분이 짐작할 수 있듯이 대각성분과, 띠 성분을 벡터로 입력하면 된다.\nIn [14]: SymTridiagonal([1,2, 3, 4, 5], [-1, -2, -3, -4])\nOut[14]: 5×5 SymTridiagonal{Int64, Vector{Int64}}:\n  1  -1   ⋅   ⋅   ⋅\n -1   2  -2   ⋅   ⋅\n  ⋅  -2   3  -3   ⋅\n  ⋅   ⋅  -3   4  -4\n  ⋅   ⋅   ⋅  -4   5\n\n\n\nUpperTriangular, LowerTriangular\n상삼각행렬과 하삼각행렬을 다루기 위한 타입은 각각 UpperTriangular, LowerTriangular 이다. 거기에 대각성분이 \\(1\\) 인 행렬로 특별히 UnitUpperTriangular, UnitLowerTriangular 타입이 준비되어 있다. 이미 존재하는 행렬로부터 필요한 만큼의 행렬 원소를 취하여 행렬을 구성 할 수 있다.\nIn [15]: A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]\nOut[15]: 3×3 Matrix{Float64}:\n 1.0  2.0  3.0\n 4.0  5.0  6.0\n 7.0  8.0  9.0\n\nIn [16]: UpperTriangular(A)\nOut[16]: 3×3 UpperTriangular{Float64, Matrix{Float64}}:\n 1.0  2.0  3.0\n  ⋅   5.0  6.0\n  ⋅    ⋅   9.0\n\nIn [17]: LowerTriangular(A)\nOut[17]: 3×3 LowerTriangular{Float64, Matrix{Float64}}:\n 1.0   ⋅    ⋅ \n 4.0  5.0   ⋅ \n 7.0  8.0  9.0\n\nIn [18]: UnitUpperTriangular(A)\nOut[18]: 3×3 UnitUpperTriangular{Float64, Matrix{Float64}}:\n 1.0  2.0  3.0\n  ⋅   1.0  6.0\n  ⋅    ⋅   1.0\n\nIn [19]: UnitLowerTriangular(A)\nOut[19]: 3×3 UnitLowerTriangular{Float64, Matrix{Float64}}:\n 1.0   ⋅    ⋅ \n 4.0  1.0   ⋅ \n 7.0  8.0  1.0\n\n\n\n헤센베르그 행렬\n헤센베르그 행렬은 상헤센베르그 행렬(Upper Hessenberg matrix) 과 하헤센베르그 행렬(Lower Hessenberg matrix) 로 이루어진다. 상헤센베르그 행렬(Upper Hessenberg matrix) 은 정사각행렬이며 행렬의 좌하단 모서리 부근이 모두 \\(0\\) 인 행렬이다. 하헤센베르그 행렬(Lower Hessenberg matrix) 는 정사각 행렬이며 행렬의 우하단 모서리 부근이 모두 \\(0\\) 인 행렬이다. 아래의 보기에서 \\(\\boldsymbol{H}_U\\) 는 상헤센베르그 행렬, \\(\\boldsymbol{H}_L\\) 은 하헤센베르그 행렬이다.\n\\[\n\\boldsymbol{H}_U = \\begin{bmatrix} 3 & 4 & 2 & 3\\\\ 1 & 4 & 2 & 3\\\\ 0 & 2 & 3 & 5 \\\\ 0 & 0 & 1 & 1\\\\\\end{bmatrix}\n,\\qquad \\boldsymbol{H}_L = \\begin{bmatrix} 1 & 2 & 0 & 0 \\\\ 7 & 2 & 3 & 0 \\\\ 3 & 4 & 3 & 7 \\\\ 5 & 3 & 1 &2 \\end{bmatrix}\n\\]\nJulia 에서는 상헤센베르그 행렬 가운데 첫번째 subdiagonal elements 아래의 성분을 0 으로 하는 행렬만 따로 UpperHessenberg 타입으로 정의한다. 임의의 정사각 행렬에 대해 UpperHessenberg 생성자를 취하면 다음과 같다.\nIn [20]: HH = [3  4  2  3; 1  4  2  3; 1  2  3  5 ; 1  2  1  1]\nOut[20]: 4×4 Matrix{Int64}:\n 3  4  2  3\n 1  4  2  3\n 1  2  3  5\n 1  2  1  1\n\nIn [21]: HU = UpperHessenberg(HH)\nOut[21]: 4×4 UpperHessenberg{Int64, Matrix{Int64}}:\n 3  4  2  3\n 1  4  2  3\n ⋅  2  3  5\n ⋅  ⋅  1  1\n\n\n\n대칭행렬과 에르미트 행렬\n어떤 행렬 \\(\\boldsymbol{A}\\) 의 행과 열을 바꾼 행렬을 그 행렬의 전치행렬 (transposed matrix) 라 하고 \\(\\boldsymbol{A}^T\\) 이라 한다. 즉 \\((\\boldsymbol{A}^T)_{ij} = (\\boldsymbol{A})_{ji}\\) 이다. 행렬 \\(\\boldsymbol{A}\\) 행과 열을 바꾸고 켤레복소수를 취한것을 켤레전치 행렬(conjugate transpose matrix) 혹은 에르미트 전치 행렬(Hermite transpose matrix)라 하고 \\(\\boldsymbol{A}^\\ast\\) 나 \\(\\boldsymbol{A}^\\dagger\\) 라 쓴다. 전자는 수학에서, 후자는 물리학에서 주로 쓰는 표현이다. \\(\\boldsymbol{A}=\\boldsymbol{A}^T\\) 이면 대칭행렬 이라 한다. \\(\\boldsymbol{A}=\\boldsymbol{A}^\\ast\\) 이면 에르미트 행렬(Hermitian matrix), 혹은 자기수반 행렬(Self-adjoint matrix) 라 한다. 예를 들어 \\(\\boldsymbol{A} =\\begin{bmatrix} 2+3i & i \\\\ 2i & 3\\end{bmatrix}\\) 에 대해,\n\\[\n\\boldsymbol{A}^T =\\begin{bmatrix} 2+3i & 2i \\\\ i & 3\\end{bmatrix},\\qquad \\boldsymbol{A}^\\ast = \\begin{bmatrix} 2-3i & -i \\\\ -2i & 3\\end{bmatrix}\n\\]\n이다. 행렬 \\(\\boldsymbol{A}\\) 가 실수 성분만을 가진다면 \\(\\boldsymbol{A}^T = \\boldsymbol{A}^\\ast\\) 이다.\n대칭행렬에 대한 타입은 Symmetric 이다. 이미 존재 하는 행렬에서 하삼각부분이나 상삼각부분을 취하여 대칭행렬로 만든다.\nIn [22]: A = [1 0 2 0 3; 0 4 0 5 0; 6 0 7 0 8; 0 9 0 1 0; 2 0 3 0 4]\nOut[22]: 5×5 Matrix{Int64}:\n 1  0  2  0  3\n 0  4  0  5  0\n 6  0  7  0  8\n 0  9  0  1  0\n 2  0  3  0  4\n\nIn [23]: Supper = Symmetric(A, :U)\nOut[23]: 5×5 Symmetric{Int64, Matrix{Int64}}:\n 1  0  2  0  3\n 0  4  0  5  0\n 2  0  7  0  8\n 0  5  0  1  0\n 3  0  8  0  4\n\nIn [24]: Slower = Symmetric(A, :L)\nOut[24]: 5×5 Symmetric{Int64, Matrix{Int64}}:\n 1  0  6  0  2\n 0  4  0  9  0\n 6  0  7  0  3\n 0  9  0  1  0\n 2  0  3  0  4\n행렬 A 의 하삼각 부분을 취하여 대칭행렬로 만들 때는 Symmetric(A, :U) 라 하고, 하삼각 부분을 취하여 대칭행렬로 만들 때는 Symmetric(A, :L) 라 한다. 이 때 :U 나 :L 을 입력하지 않으면 :U 를 기본값으로 하여 대칭행렬을 만든다.\n에르미트 행렬에 대한 타입은 Hermite 이며 마찬가지로 Hermite(A, :U) 나 Hermite(A, :L) 로 에르미트행렬을 만든다. 역시 기본값은 :U 이다.\nIn [25]: A = [1 0 2+2im 0 3-3im; 0 4 0 5 0; 6-6im 0 7 0 8+8im; 0 9 0 1 0; 2+2im 0 3-3im 0 4];\n\nIn [26]: Hupper = Hermitian(A)\nOut[26]: 5×5 Hermitian{Complex{Int64}, Matrix{Complex{Int64}}}:\n 1+0im  0+0im  2+2im  0+0im  3-3im\n 0+0im  4+0im  0+0im  5+0im  0+0im\n 2-2im  0+0im  7+0im  0+0im  8+8im\n 0+0im  5+0im  0+0im  1+0im  0+0im\n 3+3im  0+0im  8-8im  0+0im  4+0im\n\nIn [27]: Hlower = Hermitian(A, :L)\nOut[27]: 5×5 Hermitian{Complex{Int64}, Matrix{Complex{Int64}}}:\n 1+0im  0+0im  6+6im  0+0im  2-2im\n 0+0im  4+0im  0+0im  9+0im  0+0im\n 6-6im  0+0im  7+0im  0+0im  3+3im\n 0+0im  9+0im  0+0im  1+0im  0+0im\n 2+2im  0+0im  3-3im  0+0im  4+0im",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "Julia 에서의 행렬 계산"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/04_matrix_algebra.html#linearalgebra.jl-의-기본-연산자와-함수",
    "href": "src/numerical_analysis_using_julia/04_matrix_algebra.html#linearalgebra.jl-의-기본-연산자와-함수",
    "title": "Julia 에서의 행렬 계산",
    "section": "3 LinearAlgebra.jl 의 기본 연산자와 함수",
    "text": "3 LinearAlgebra.jl 의 기본 연산자와 함수\n우리는 앞서 가우스 소거법과 LU 분해 그리고 그람-그람 슈미트 과정을 통한 QR 분해를 구현하였다. 그러나 앞으로는 이것을 버리고 Julia 에서 제공하는 LinearAlgebra 모듈을 사용하도록 하자. Julia 의 LinearAlgebra 모듈은 선형대수학에서 사용하는 많은 기능을 포함하고 있다. 여기서는 중요한 것만 설명할 것이며 자세한 것은 LinearAlgbra.jl 공식 문서 를 참고하자. LinearAlgebra 를 우리가 지금껏 작성한 함수와 그 속도를 비교해보면 LinearAlgebra 쪽이 훨씬 빠르다. 그리고 LinearAlgebra module 은 많은 프로그래밍 언어에서 사용중이며, 수십년의 역사를 가진 BLAS(Basic Linear Algebra Subprograms) 과 LAPACK(Linear Algebra PACKage) 에 기반하여 만들어졌으므로 믿을만 하다. 많은 함수는 희소행렬과 밀집행렬에 대해 공통적으로 사용 할 수 있다.(다중 디스패치!!!)\n\n\n기본 연산자와 함수\nLininearAlgebra.jl 은 행렬 A(\\(\\boldsymbol{A}\\)), B(\\(\\boldsymbol{B}\\)) 와 벡터 u(\\(\\boldsymbol{u}\\)), v(\\(\\boldsymbol{v}\\)), 스칼라 a(\\(a\\)), b(\\(b\\)) 에 대해 다음과 같은 함수를 지원한다. (LinearAlgebra.jl 이 지원하는 함수중 일부이다.)\n\n연산자\n\n\n\n\n\n\n\n연산자\n설명\n\n\n\n\n+, -, *\n수학적으로 정의된 스칼라, 벡터, 행렬 사이의 더하기, 빼기, 곱하기 연산\n\n\n\\\nA \\ B 일 경우 AX==B 를 만족하는 행렬 A 를 구한다. 구하는 방법은 A 가 어떤 행렬인지에 따라 달라진다.\n\n\n/\n행렬간의 연산일 경우 (B' / A') 를 구한다.\n\n\nu⋅v (\\cdot+[tab])\n\\(\\boldsymbol{u} \\cdot \\boldsymbol{v}\\)\n\n\n×(u, v) (\\times+[tab])\n\\(\\boldsymbol{u \\times v}\\)\n\n\n\n\n\n\n기본적인 함수\n\n\n\n함수\n설명\n비고\n\n\n\n\ntr(A)\n\\(\\text{tr}(\\boldsymbol{A})\\)\n\n\n\ndet(A)\n\\(\\det(\\boldsymbol{A})\\)\n\n\n\ninv(A)\n\\(\\boldsymbol{A}^{-1}\\)\nA 가 정사각행렬일 경우\n\n\ntranspose(A)\n\\(\\boldsymbol{A}^{T}\\)\nA 의 전치행렬\n\n\nA' or adjoint(A)\n\\(\\boldsymbol{A}^\\dagger\\)\nA 의 에르미트 전치행렬\n\n\ndiag(A)\n\\([A_{11},\\,A_{22},\\ldots]\\)\n대각성분\n\n\ndot(u, v)\nu⋅v 와 같다\n\n\n\ndot(u, A, v)\ndot(u, A*v) 와 같다\n\n\n\ncross(u, v)\n×(u, v) 와 같다\n벡터의 외적\n\n\nnorm(u, p) or norm(A, p)\n벡터의 \\(L_p\\)-노름\n노름과 조건수 참고\n\n\nopnorm(A, p::Real=2)\n행렬의 \\(L_p\\)-노름\n노름과 조건수 참고\n\n\nnormalize(a, p::Real=2)\n벡터, 행렬의 정규화\nnorm(a, p)==1 되도록 normalize 한다.\n\n\nexp(A)\nexponential of \\(\\boldsymbol{A}\\)\n\\(\\displaystyle \\sum_{k=1}^\\infty \\dfrac{\\boldsymbol{A}^k}{k!}\\)",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "Julia 에서의 행렬 계산"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/04_matrix_algebra.html#선형-시스템",
    "href": "src/numerical_analysis_using_julia/04_matrix_algebra.html#선형-시스템",
    "title": "Julia 에서의 행렬 계산",
    "section": "4 선형 시스템",
    "text": "4 선형 시스템\n우리는 앞서 LU 분해를 통해 선형 시스템을 푸는 코드를 작성하였다. 이제는 LinearAlgebra.jl 이 제공하는 \\ 연산자를 이용하면 쉽게 풀 수 있다. 일반적인 정사각 행렬에 대해서는 성긴 행렬이든 밀집 행렬이든 LU 분해를 통해 선형 시스템을 쉽게 풀 수 도록 해 준다. 예를 들어,\nIn [1]: using LinearAlgebra\n\nIn [2]: A=[4 2 3;3 1 2;3 3 4];b=[2; 1 ;-1]\nOut[2]: 3-element Vector{Int64}:\n  2\n  1\n -1\n\nIn [3]: A\\b\nOut[3]: 3-element Vector{Float64}:\n  2.0\n  3.0000000000000013\n -4.000000000000001\n와 같이 풀 수 있다.",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "Julia 에서의 행렬 계산"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/06_calculus_of_one_variable_function.html",
    "href": "src/numerical_analysis_using_julia/06_calculus_of_one_variable_function.html",
    "title": "일변수 함수의 미분과 적분",
    "section": "",
    "text": "이 장에서는 수치해석적으로 주어진 함수의 미분을 구하는 방법을 알아본다. 앞서 설명했듯이함수 \\(f: X\\subset \\mathbb{R} \\to \\mathbb {R}\\) 이 \\(x_0 \\in X\\) 에서 미분가능하다는 것은 다음의 극한이 존재한다는 것이다.\n\\[\nf'(x_0)=\\lim_{h\\to 0} \\dfrac{f(x_0+h)- f(x_0)}{h}\n\\]\n여기서 \\(h\\) 는 음수도, 양수도 가능하다. 그리고 우리가 앞서 배웠듯이 컴퓨터가 다룰수 있는 가장 \\(0\\) 에 가깝지만 가장 작은 수에는 한계가 있으므로 이러한 극한을 다룰수 없다. 따라서 수치해석적으로 미분을 계산할 때는 우리가 관심있는 영역 \\([a,\\,b]\\subset X\\) 를 분할하여 수열을 만들어 다룰 수 밖에 없다. 즉 우리는 \\(x_1=a&lt;x_2&lt;\\cdots &lt;x_n=b\\) 에 대해 \\(f(x_i) = y_i\\) 로 정하고 수열 \\((x_i)\\) 와 \\((y_i)\\) 를 이용하여 수치해석적으로 미분을 구한다. 이것은 미분가능한 함수가 주어졌을 때 뿐만 아니라 이산적인 값 \\(\\{(x_i,\\, y_i)\\}\\) 가 주어졌을 때도 동일하게 사용 할 수 있다. 우리는 \\([a,\\,b]\\) 를 일정한 간격으로 분할한, 즉 \\(x_{i+1}-x_i =h\\) 가 상수일 경우만 생각하기로 한다.\n\n\n\n수열 \\(y_1,\\,y_2,\\ldots\\) 에 대해 전방 차분 (forward difference) 는 \\(\\Delta_F y_i = y_{i+1}-y_i\\) 로 정의된다. 후방 차분 (backward difference) 는 \\(\\Delta_B y_i = y_{i}-y_{i-1}\\) 로 정의된다. 함수 \\(f(x)\\) 에 대해 어떤 특정한 간격 \\(h&gt;0\\) 가 주어졌을 때 전방 차분은 \\(\\Delta_F f(x) = f(x+h)-f(x)\\) 이며 후방차분은 \\(\\Delta_B f(x) = f(x)-f(x-h)\\) 이다. 앞서 말했듯이 수치해석에서는 \\(h\\to 0\\) 극한을 사용할 수 없으므로 차분을 이용하여 미분값을 계산한다.\n\n\n\n\n함수 \\(f\\) 가 \\(C^2\\) 함수일 때 \\(f\\) 에 대한 테일러 전개는 아래와 같다.\n\\[\n\\begin{aligned}\nf(x-h) &= f(x) - f'(x)h + \\dfrac{f''(\\xi_1)}{2} h^2,  \\\\\nf(x+h) &= f(x) + f'(x)h + \\dfrac{f''(\\xi_2)}{2} h^2.\n\\end{aligned}\n\\tag{1}\\]\n\\(h&gt;0\\) 일 때 전방차분과 후방차분을 이용하여\n\\[\n\\begin{aligned}\nf'(x) &= \\dfrac{f(x+h)-f(x)}{h} + O(h) = \\dfrac{\\Delta_F f(x)}{h} + O(h) \\\\\n&= \\dfrac{f(x)-f(x-h)}{h} + O(h) = \\dfrac{\\Delta_B f(x)}{h} + O(h)\n\\end{aligned}\n\\tag{2}\\]\n로 근사 할 수 있다.\n\n\n\n\n2차와 3차 테일러 다항식 까지 전개한다면 \\[\n\\begin{aligned}\nf(x-h) &= f(x) - f'(x)h + \\dfrac{f''(x)}{2} h^2 - \\dfrac{f^{(3)}(\\xi_1)}{6} h^3,  \\\\\n&= f(x) - f'(x)h + \\dfrac{f''(x)}{2} h^2 - \\dfrac{f^{(3)}(x)}{6} h^3 + \\dfrac{f^{(4)}(\\xi'_1)}{24}h^4,  \\\\\nf(x+h) &= f(x) + f'(x)h + \\dfrac{f''(x)}{2} h^2 + \\dfrac{f^{(3)}(\\xi_2)}{6} h^3, \\\\\n&= f(x) + f'(x)h + \\dfrac{f''(x)}{2} h^2 + \\dfrac{f^{(3)}(x)}{6} h^3 + \\dfrac{f^{(4)}(\\xi'_2)}{24}h^4\n\\end{aligned}\n\\tag{3}\\]\n를 만족하는 \\(\\xi_1,\\,\\xi'_1\\in (x-h,\\, x),\\, \\xi_2,\\,\\xi'_2 \\in (x,\\,x+h)\\) 가 존재한다.\n이로부터\n\\[\n\\begin{aligned}\nf(x+h)-f(x-h) &= 2f'(x) h + \\dfrac{1}{6} \\left(f^{(3)}(\\xi_2) +f^{(3)}(\\xi_1) \\right)h^3, \\\\\nf(x+h) -2 f(x) + f(x-h) &= f''(x) h^2 + \\dfrac{1}{24}\\left(f^{(4)}(\\xi'_1) +f^{(4)}(\\xi'_2) \\right)h^4\n\\end{aligned}\n\\]\n이므로 우리는 이것을 이용하여 1계 뿐만 아니라 2계 도함수에 대한 근사값도 구할 수 있다. 여기서 \\(f^{(3)}(\\xi_2) +f^{(3)}(\\xi_1)\\) 를 보자. \\(\\xi_1\\in [x-h,\\,x],\\, \\xi_2 \\in [x,\\,x+h]\\) 인데, \\(f\\in C^3_{[x-h,x+h]}\\) 이면 따름정리 : 여러 점의 경우 에 의해 \\(f^{(3)}(\\xi) = \\frac{1}{2}\\left(f^{(3)}(\\xi_2) +f^{(3)}(\\xi_1) \\right)\\) 를 만족하는 \\(\\xi\\in[x-h,\\,x+h]\\) 가 존재하며, 같은 이유로 \\(f\\in C^4_{[x-h,\\,x+h]}\\) 이면 \\(f^{(4)}(\\xi')=\\frac{1}{2}\\left(f^{(4)}(\\xi'_1) +f^{(4)}(\\xi'_2) \\right)\\) 를 만족하는 \\(\\xi'\\in [x-h,\\,x+h]\\) 가 항상 존재한다. 따라서 다음과 같이 도함수와 2계 도함수를 근사 할 수 있다.\n\\[\n\\begin{aligned}\nf'(x) &= \\dfrac{f(x+h)-f(x-h)}{2h} - \\dfrac{f^{(3)}(\\xi)}{6}h^2 ,\\\\\nf''(x) &=  \\dfrac{f(x+h) - 2f(x) + f(x-h)}{h^2} - \\dfrac{f^{(4)}(\\xi')}{12}h^2\n\\end{aligned}\n\\tag{4}\\]\n이 때 수치해석적으로 계산한 미분의 오차는 \\(h^2\\) 에 비례한다. 따라서 \\(h\\) 을 작게 잡을 수록 오차가 작아지며 충분히 작을 때 전방차분이나 후방차분보다 오차가 작을 것을 기대 할 수 있다. 위의 식에 의해 구한 미분의 추정값을 중앙 차분 (central difference) 라고 한다. 아래 그림은 함수 \\(f\\) 에 대한 전방 차분, 후방 차분, 중앙 차분값을 그림으로 표현하였다. 실제 미분값은 중앙차분에 의한 값과 거의 같다.\n\n\n\nFinite difference\n\n\n양 끝점에서는 도함수를 구할 수 없는데 이때는 전방차분이나 후방차분과 비슷한 방법을 사용하여 구할 수 있다.\n\\[\n\\begin{aligned}\nf(x+2h) & = f(x) + f'(x)(2h) + \\dfrac{f''(x)}{2}(2h)^2 + \\dfrac{f^{(3)}(x)}{6}(2h)^3 + O(h^4) \\\\\nf(x-2h) &= f(x) - f'(x)(2h) + \\dfrac{f''(x)}{2}(2h)^2 - \\dfrac{f^{(3)}(x)}{6}(2h)^3 + O(h^4),\n\\end{aligned}\n\\]\n\\[\n\\begin{aligned}\ny'_1 &= \\dfrac{-y_{3}+4y_{2}-3y_1}{2h} + O(h^2),\\\\\ny'_n &= \\dfrac{3y_{n}-4x_{n-1}+y_{n-2}}{2h} + O(h^2).\n\\end{aligned}\n\\tag{5}\\]\n\n\n\n\n\\(h\\) 값이 작을 수록 오차가 작아지지만 \\(h\\) 값이 어느 이하로 작아지면 에러가 발생한다. 아래는 쉬운 예를 보여준다. 우리는 \\(f(x)=e^x\\) 의 도함수는 자기 자신과 같으며, \\(f(0)=f'(0)=1\\) 임을 알고 있다. 앞의 전방, 후반 차분법과 보통의 차분법에 대해 \\(h\\) 값을 변화시키며 \\(f'(0)\\) 의 값을 계산하였다. \\(h\\) 값이 충분히 작지 않을 때는 오차가 발생하였으나 어느 정도 작아지면 그 값이 정확하고 안정적이다. 그러나 \\(h\\) 값이 \\(10^{-13}\\) 보다 작아지면 roundoff 에러가 발생하여 불안정해지는 것을 알 수 있다.\n\n\n\nRoundioff-Finite difference\n\n\n\n\n\n\n지금까지 1차와 2차 테일러 전개를 이용하여 미분계수를 \\(O(h)\\) 나 \\(O(h^2)\\) 의 오차로 구하는 방법을 소개하였다. 고차 테일러 전개를 이용하면 더 정확하게 미분값을 구할 수 있다. 4차 테일러 다항식과 나머지 값은 다음과 같다.\n\\[\n\\begin{aligned}\nf(x-2h) &= f(x) - f'(x) \\cdot (2h) + \\dfrac{f''(x)}{2}(2h)^2  \\\\\n&\\qquad \\qquad - \\dfrac{f'''(x)}{6} (2h)^3 + \\dfrac{f^{(4)}(x)}{24}(2h)^4 - \\dfrac{f^{(5)}(\\xi_1)}{120} (2h)^5\\,\\\\\nf(x-h) &= f(x) - f'(x) \\cdot (h) + \\dfrac{f''(x)}{2}(h)^2  \\\\\n&\\qquad \\qquad - \\dfrac{f'''(x)}{6} (h)^3 + \\dfrac{f^{(4)}(x)}{24}(h)^4 - \\dfrac{f^{(5)}(\\xi_2)}{120} (h)^5\\,\\\\\nf(x+h) &= f(x) + f'(x) \\cdot (h) + \\dfrac{f''(x)}{2}(h)^2 \\\\\n&\\qquad \\qquad + \\dfrac{f'''(x)}{6} (h)^3 + \\dfrac{f^{(4)}(x)}{24}(h)^4 + \\dfrac{f^{(5)}(\\xi_3)}{120} (h)^5\\,\\\\\nf(x+2h) &= f(x) + f'(x) \\cdot (2h) + \\dfrac{f''(x)}{2}(2h)^2 \\\\\n&\\qquad \\qquad + \\dfrac{f'''(x)}{6} (2h)^3 + \\dfrac{f^{(4)}(x)}{24}(2h)^4 + \\dfrac{f^{(5)}(\\xi_4)}{120} (2h)^5\\,\\\\\n\\end{aligned}\n\\tag{6}\\]\n이로부터,\n\\[\n\\begin{aligned}\nf(x-2h) -8f(x-h) + 8f(x+h)  - f(x+2h) &= 12 f'(x) h+ O (h^5) \\,,\\\\\n-f(x-2h) + 16f(x-h) -30 f(x) + 16 f(x+h) - f(x+2h) &= 12 f''(x) h^2 + O(h^5) .\n\\end{aligned}\n\\]\n임을 안다. 즉,\n\\[\n\\begin{aligned}\nf'(x) & = \\dfrac{f(x-2h) -8f(x-h) + 8f(x+h)  - f(x+2h)}{12h} + O(h^5)\\,,\\\\\nf''(x) &= \\dfrac{-f(x-2h) + 16f(x-h) -30 f(x) + 16 f(x+h) - f(x+2h)}{12h^2} + O(h^4)\n\\end{aligned}\n\\tag{7}\\]\n이다.\n다음 그림은 함수 \\(f(x) = x\\sin (x)\\) 에 대해 \\(h\\) 를 변화시켜 가면서로 잡고 위에서 설명한 두가지 방법을 이용하여 도함수를 구했을때의 그래프(“3 Points”, “5 Points”) 와 \\(f'(x) = \\sin (x) + x\\cos (x)\\) 의 그래프 (“Analytical”) 를 같이 그린 것이다. \\(h=1\\times 10^{-1}\\) 에서는 첫번째 수치미분보다 두번째 수치미분이 좀 더 실제 값에 가까우며 \\(1 \\times 10^{-2}\\) 부터 \\(1.0 \\times 10^{-14}\\) 까지는 두 방법 모두 상당히 정확한 값을 보여준다. 그러나 \\(h\\) 값이 \\(1.0\\times 10^{-15}\\) 보다 작아지면서부터는 뚜렷하게 오차를 보여준다. 이것은 수치 미분을 구할 때 분모를 \\(h\\) 로 나누게 되는데, 이 값이 작을수록 round-off 에러가 발생하기 때문이다. 따라서 적당한 \\(h\\) 값을 잡는 것이 중요하다.\n\n\n\n\nDerivative",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "일변수 함수의 미분과 적분"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/06_calculus_of_one_variable_function.html#일변수-함수의-미분",
    "href": "src/numerical_analysis_using_julia/06_calculus_of_one_variable_function.html#일변수-함수의-미분",
    "title": "일변수 함수의 미분과 적분",
    "section": "",
    "text": "이 장에서는 수치해석적으로 주어진 함수의 미분을 구하는 방법을 알아본다. 앞서 설명했듯이함수 \\(f: X\\subset \\mathbb{R} \\to \\mathbb {R}\\) 이 \\(x_0 \\in X\\) 에서 미분가능하다는 것은 다음의 극한이 존재한다는 것이다.\n\\[\nf'(x_0)=\\lim_{h\\to 0} \\dfrac{f(x_0+h)- f(x_0)}{h}\n\\]\n여기서 \\(h\\) 는 음수도, 양수도 가능하다. 그리고 우리가 앞서 배웠듯이 컴퓨터가 다룰수 있는 가장 \\(0\\) 에 가깝지만 가장 작은 수에는 한계가 있으므로 이러한 극한을 다룰수 없다. 따라서 수치해석적으로 미분을 계산할 때는 우리가 관심있는 영역 \\([a,\\,b]\\subset X\\) 를 분할하여 수열을 만들어 다룰 수 밖에 없다. 즉 우리는 \\(x_1=a&lt;x_2&lt;\\cdots &lt;x_n=b\\) 에 대해 \\(f(x_i) = y_i\\) 로 정하고 수열 \\((x_i)\\) 와 \\((y_i)\\) 를 이용하여 수치해석적으로 미분을 구한다. 이것은 미분가능한 함수가 주어졌을 때 뿐만 아니라 이산적인 값 \\(\\{(x_i,\\, y_i)\\}\\) 가 주어졌을 때도 동일하게 사용 할 수 있다. 우리는 \\([a,\\,b]\\) 를 일정한 간격으로 분할한, 즉 \\(x_{i+1}-x_i =h\\) 가 상수일 경우만 생각하기로 한다.\n\n\n\n수열 \\(y_1,\\,y_2,\\ldots\\) 에 대해 전방 차분 (forward difference) 는 \\(\\Delta_F y_i = y_{i+1}-y_i\\) 로 정의된다. 후방 차분 (backward difference) 는 \\(\\Delta_B y_i = y_{i}-y_{i-1}\\) 로 정의된다. 함수 \\(f(x)\\) 에 대해 어떤 특정한 간격 \\(h&gt;0\\) 가 주어졌을 때 전방 차분은 \\(\\Delta_F f(x) = f(x+h)-f(x)\\) 이며 후방차분은 \\(\\Delta_B f(x) = f(x)-f(x-h)\\) 이다. 앞서 말했듯이 수치해석에서는 \\(h\\to 0\\) 극한을 사용할 수 없으므로 차분을 이용하여 미분값을 계산한다.\n\n\n\n\n함수 \\(f\\) 가 \\(C^2\\) 함수일 때 \\(f\\) 에 대한 테일러 전개는 아래와 같다.\n\\[\n\\begin{aligned}\nf(x-h) &= f(x) - f'(x)h + \\dfrac{f''(\\xi_1)}{2} h^2,  \\\\\nf(x+h) &= f(x) + f'(x)h + \\dfrac{f''(\\xi_2)}{2} h^2.\n\\end{aligned}\n\\tag{1}\\]\n\\(h&gt;0\\) 일 때 전방차분과 후방차분을 이용하여\n\\[\n\\begin{aligned}\nf'(x) &= \\dfrac{f(x+h)-f(x)}{h} + O(h) = \\dfrac{\\Delta_F f(x)}{h} + O(h) \\\\\n&= \\dfrac{f(x)-f(x-h)}{h} + O(h) = \\dfrac{\\Delta_B f(x)}{h} + O(h)\n\\end{aligned}\n\\tag{2}\\]\n로 근사 할 수 있다.\n\n\n\n\n2차와 3차 테일러 다항식 까지 전개한다면 \\[\n\\begin{aligned}\nf(x-h) &= f(x) - f'(x)h + \\dfrac{f''(x)}{2} h^2 - \\dfrac{f^{(3)}(\\xi_1)}{6} h^3,  \\\\\n&= f(x) - f'(x)h + \\dfrac{f''(x)}{2} h^2 - \\dfrac{f^{(3)}(x)}{6} h^3 + \\dfrac{f^{(4)}(\\xi'_1)}{24}h^4,  \\\\\nf(x+h) &= f(x) + f'(x)h + \\dfrac{f''(x)}{2} h^2 + \\dfrac{f^{(3)}(\\xi_2)}{6} h^3, \\\\\n&= f(x) + f'(x)h + \\dfrac{f''(x)}{2} h^2 + \\dfrac{f^{(3)}(x)}{6} h^3 + \\dfrac{f^{(4)}(\\xi'_2)}{24}h^4\n\\end{aligned}\n\\tag{3}\\]\n를 만족하는 \\(\\xi_1,\\,\\xi'_1\\in (x-h,\\, x),\\, \\xi_2,\\,\\xi'_2 \\in (x,\\,x+h)\\) 가 존재한다.\n이로부터\n\\[\n\\begin{aligned}\nf(x+h)-f(x-h) &= 2f'(x) h + \\dfrac{1}{6} \\left(f^{(3)}(\\xi_2) +f^{(3)}(\\xi_1) \\right)h^3, \\\\\nf(x+h) -2 f(x) + f(x-h) &= f''(x) h^2 + \\dfrac{1}{24}\\left(f^{(4)}(\\xi'_1) +f^{(4)}(\\xi'_2) \\right)h^4\n\\end{aligned}\n\\]\n이므로 우리는 이것을 이용하여 1계 뿐만 아니라 2계 도함수에 대한 근사값도 구할 수 있다. 여기서 \\(f^{(3)}(\\xi_2) +f^{(3)}(\\xi_1)\\) 를 보자. \\(\\xi_1\\in [x-h,\\,x],\\, \\xi_2 \\in [x,\\,x+h]\\) 인데, \\(f\\in C^3_{[x-h,x+h]}\\) 이면 따름정리 : 여러 점의 경우 에 의해 \\(f^{(3)}(\\xi) = \\frac{1}{2}\\left(f^{(3)}(\\xi_2) +f^{(3)}(\\xi_1) \\right)\\) 를 만족하는 \\(\\xi\\in[x-h,\\,x+h]\\) 가 존재하며, 같은 이유로 \\(f\\in C^4_{[x-h,\\,x+h]}\\) 이면 \\(f^{(4)}(\\xi')=\\frac{1}{2}\\left(f^{(4)}(\\xi'_1) +f^{(4)}(\\xi'_2) \\right)\\) 를 만족하는 \\(\\xi'\\in [x-h,\\,x+h]\\) 가 항상 존재한다. 따라서 다음과 같이 도함수와 2계 도함수를 근사 할 수 있다.\n\\[\n\\begin{aligned}\nf'(x) &= \\dfrac{f(x+h)-f(x-h)}{2h} - \\dfrac{f^{(3)}(\\xi)}{6}h^2 ,\\\\\nf''(x) &=  \\dfrac{f(x+h) - 2f(x) + f(x-h)}{h^2} - \\dfrac{f^{(4)}(\\xi')}{12}h^2\n\\end{aligned}\n\\tag{4}\\]\n이 때 수치해석적으로 계산한 미분의 오차는 \\(h^2\\) 에 비례한다. 따라서 \\(h\\) 을 작게 잡을 수록 오차가 작아지며 충분히 작을 때 전방차분이나 후방차분보다 오차가 작을 것을 기대 할 수 있다. 위의 식에 의해 구한 미분의 추정값을 중앙 차분 (central difference) 라고 한다. 아래 그림은 함수 \\(f\\) 에 대한 전방 차분, 후방 차분, 중앙 차분값을 그림으로 표현하였다. 실제 미분값은 중앙차분에 의한 값과 거의 같다.\n\n\n\nFinite difference\n\n\n양 끝점에서는 도함수를 구할 수 없는데 이때는 전방차분이나 후방차분과 비슷한 방법을 사용하여 구할 수 있다.\n\\[\n\\begin{aligned}\nf(x+2h) & = f(x) + f'(x)(2h) + \\dfrac{f''(x)}{2}(2h)^2 + \\dfrac{f^{(3)}(x)}{6}(2h)^3 + O(h^4) \\\\\nf(x-2h) &= f(x) - f'(x)(2h) + \\dfrac{f''(x)}{2}(2h)^2 - \\dfrac{f^{(3)}(x)}{6}(2h)^3 + O(h^4),\n\\end{aligned}\n\\]\n\\[\n\\begin{aligned}\ny'_1 &= \\dfrac{-y_{3}+4y_{2}-3y_1}{2h} + O(h^2),\\\\\ny'_n &= \\dfrac{3y_{n}-4x_{n-1}+y_{n-2}}{2h} + O(h^2).\n\\end{aligned}\n\\tag{5}\\]\n\n\n\n\n\\(h\\) 값이 작을 수록 오차가 작아지지만 \\(h\\) 값이 어느 이하로 작아지면 에러가 발생한다. 아래는 쉬운 예를 보여준다. 우리는 \\(f(x)=e^x\\) 의 도함수는 자기 자신과 같으며, \\(f(0)=f'(0)=1\\) 임을 알고 있다. 앞의 전방, 후반 차분법과 보통의 차분법에 대해 \\(h\\) 값을 변화시키며 \\(f'(0)\\) 의 값을 계산하였다. \\(h\\) 값이 충분히 작지 않을 때는 오차가 발생하였으나 어느 정도 작아지면 그 값이 정확하고 안정적이다. 그러나 \\(h\\) 값이 \\(10^{-13}\\) 보다 작아지면 roundoff 에러가 발생하여 불안정해지는 것을 알 수 있다.\n\n\n\nRoundioff-Finite difference\n\n\n\n\n\n\n지금까지 1차와 2차 테일러 전개를 이용하여 미분계수를 \\(O(h)\\) 나 \\(O(h^2)\\) 의 오차로 구하는 방법을 소개하였다. 고차 테일러 전개를 이용하면 더 정확하게 미분값을 구할 수 있다. 4차 테일러 다항식과 나머지 값은 다음과 같다.\n\\[\n\\begin{aligned}\nf(x-2h) &= f(x) - f'(x) \\cdot (2h) + \\dfrac{f''(x)}{2}(2h)^2  \\\\\n&\\qquad \\qquad - \\dfrac{f'''(x)}{6} (2h)^3 + \\dfrac{f^{(4)}(x)}{24}(2h)^4 - \\dfrac{f^{(5)}(\\xi_1)}{120} (2h)^5\\,\\\\\nf(x-h) &= f(x) - f'(x) \\cdot (h) + \\dfrac{f''(x)}{2}(h)^2  \\\\\n&\\qquad \\qquad - \\dfrac{f'''(x)}{6} (h)^3 + \\dfrac{f^{(4)}(x)}{24}(h)^4 - \\dfrac{f^{(5)}(\\xi_2)}{120} (h)^5\\,\\\\\nf(x+h) &= f(x) + f'(x) \\cdot (h) + \\dfrac{f''(x)}{2}(h)^2 \\\\\n&\\qquad \\qquad + \\dfrac{f'''(x)}{6} (h)^3 + \\dfrac{f^{(4)}(x)}{24}(h)^4 + \\dfrac{f^{(5)}(\\xi_3)}{120} (h)^5\\,\\\\\nf(x+2h) &= f(x) + f'(x) \\cdot (2h) + \\dfrac{f''(x)}{2}(2h)^2 \\\\\n&\\qquad \\qquad + \\dfrac{f'''(x)}{6} (2h)^3 + \\dfrac{f^{(4)}(x)}{24}(2h)^4 + \\dfrac{f^{(5)}(\\xi_4)}{120} (2h)^5\\,\\\\\n\\end{aligned}\n\\tag{6}\\]\n이로부터,\n\\[\n\\begin{aligned}\nf(x-2h) -8f(x-h) + 8f(x+h)  - f(x+2h) &= 12 f'(x) h+ O (h^5) \\,,\\\\\n-f(x-2h) + 16f(x-h) -30 f(x) + 16 f(x+h) - f(x+2h) &= 12 f''(x) h^2 + O(h^5) .\n\\end{aligned}\n\\]\n임을 안다. 즉,\n\\[\n\\begin{aligned}\nf'(x) & = \\dfrac{f(x-2h) -8f(x-h) + 8f(x+h)  - f(x+2h)}{12h} + O(h^5)\\,,\\\\\nf''(x) &= \\dfrac{-f(x-2h) + 16f(x-h) -30 f(x) + 16 f(x+h) - f(x+2h)}{12h^2} + O(h^4)\n\\end{aligned}\n\\tag{7}\\]\n이다.\n다음 그림은 함수 \\(f(x) = x\\sin (x)\\) 에 대해 \\(h\\) 를 변화시켜 가면서로 잡고 위에서 설명한 두가지 방법을 이용하여 도함수를 구했을때의 그래프(“3 Points”, “5 Points”) 와 \\(f'(x) = \\sin (x) + x\\cos (x)\\) 의 그래프 (“Analytical”) 를 같이 그린 것이다. \\(h=1\\times 10^{-1}\\) 에서는 첫번째 수치미분보다 두번째 수치미분이 좀 더 실제 값에 가까우며 \\(1 \\times 10^{-2}\\) 부터 \\(1.0 \\times 10^{-14}\\) 까지는 두 방법 모두 상당히 정확한 값을 보여준다. 그러나 \\(h\\) 값이 \\(1.0\\times 10^{-15}\\) 보다 작아지면서부터는 뚜렷하게 오차를 보여준다. 이것은 수치 미분을 구할 때 분모를 \\(h\\) 로 나누게 되는데, 이 값이 작을수록 round-off 에러가 발생하기 때문이다. 따라서 적당한 \\(h\\) 값을 잡는 것이 중요하다.\n\n\n\n\nDerivative",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "일변수 함수의 미분과 적분"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/06_calculus_of_one_variable_function.html#일변수-함수의-적분-뉴턴-코츠-방법",
    "href": "src/numerical_analysis_using_julia/06_calculus_of_one_variable_function.html#일변수-함수의-적분-뉴턴-코츠-방법",
    "title": "일변수 함수의 미분과 적분",
    "section": "2 일변수 함수의 적분 : 뉴턴-코츠 방법",
    "text": "2 일변수 함수의 적분 : 뉴턴-코츠 방법\n수치해석적으로 적분을 구하는 방법을 알아보도록 한다. 다항식이나 삼각함수, 지수함수를 포함한 몇면 함수에 대해서는 우리가 이미 프로그래밍 언어에 내장되어 있는 기본적인 함수로 존재하므로 쉽게 구할 수 있다. 예를 들어 \\([0, \\theta]\\) 영역에서의 \\(\\sin x\\) 함수의 적분은\n\\[\n\\int_0^\\theta \\sin x \\, dx = -\\cos \\theta  +1\n\\]\n이라는 것을 안다. 그러나 대부분의 함수는 수치해석적으로 구할 수 밖에 없다. 수학적으로는 우리는 어떤 구간에서 연속인 함수라면 그 구간에서 적분이 존재한다는 것을 알고 있다. 또한 \\([a,\\,b]\\) 구간에서 불연속인 점이 유한개이면 적분이 존재한다는 것도 알고 있다1. 만약 적분구간이 부분적으로 연속인 유한개의 구간으로 이루어져 있다면, 각각의 유한개의 구간에 대한 적분의 합으로 생각 할 수 있으므로, 여기서는 연속인 경우만 다루기로 한다. 미분과 마찬가지로 \\([a,\\,b]\\) 구간이 \\(x_1=a&lt;x_2&lt;\\cdots &lt;x_{n-1}&lt;x_n=b\\) 인 \\(n\\) 개의 점을 이용하여 \\(n-1\\) 개의 부분구간(subintervals)로 분할되었다고 가정한다. 이렇게 적분을 유한개의 구간으로 나누어 구간의 합으로 계산하는 방법을 구적법(quadrature) 라고 한다.\n\n\n뉴턴 코츠(Newton-Cotes) 방법\n많은 경우 구간의 간격 \\(x_{i+1}-x_i\\) 가 항상 같으며, 이 경우 적분을 구적법으로 구하는 것을 Newton-Cotes 방법이라고 한다. 구간의 간격을 \\(h\\) 라고 하자. 즉 \\([a,\\,b]\\) 구간을 \\(a=x_1&lt;\\cdots &lt;x_n=b\\) 로 등간격으로 나누었다고 하자. 이 때, 양 끝점을 포함하여 구간을 나눌 수도 있고, 양 끝점을 빼고 구간을 나눌 수도 있다. 양 끝점을 포함하는 것을 닫힌 Newton-Cotes 방법(closed Newton-Cotes method) 이라고 하고, 양 끝점을 빼는 것을 열린 Newton-Cotes 방법(open Newton-Cotes method) 이라고 한다. 여기서는 닫힌 Newton-Cotes 방법에 대해서 주로 다루기로 한다. 우선 \\([a,\\,b]\\) 구간을 \\(n\\) 개의 점 \\(x_1,\\ldots,\\,x_n\\) 을 이용하여 \\(n-1\\) 개의 등간격으로 분할하면 각 \\(x_i\\) 는 다음과 같다.\n\\[\nx_i = a + (i-1)h = a+ (i-1)\\dfrac{(b-a)}{n-1},\\qquad i=1,\\ldots,\\,n\n\\]\n이 때 적분값을 \\(f(x_1), \\ldots,\\,f(x_n)\\) 의 선형결합으로 다음과 같이 표현하는 것이 Newton-Cotes 방법이다.\n\\[\n\\begin{aligned}\n\\int_{a}^b f(x)\\, dx &\\approx \\sum_{k=1}^n w_i f(x_i)\\qquad & & \\text{closed Newton-Cotes method}\\\\\n&\\approx \\sum_{i=2}^{n-1} w_i f(x_i) \\qquad & & \\text{open Newton-Cotes method}\n\\end{aligned}\n\\]\n즉 우리가 여기서 구해야 할 것은 각 구간에서의 weight factor \\(w_i\\) 이다. Newton-Cotes 방법을 이용한 대표적인 적분방법은 사다리꼴 방법과 Simpson 방법이다.\n\n\n\n\nTrapzoidal method 와 Simpson method\n\n\n\n중점법은 구간 \\([x_i,\\, x_{i+1}]\\) 의 중점 \\(\\dfrac{1}{2}(x_i + x_{i+1})\\) 에서의 함수값을 이용하여 적분값을 계산하는 방법이다. 사다리꼴 방법은 \\([x_i,\\,x_{i+1}]\\) 의 적분을 \\((x_i,\\, f(x_i))\\) 와 \\((x_{i+1},\\, f(x_{i+1}))\\) 을 1차 함수로 근사하여 적분값을 계산한다. Simpson 방법은 두가지가 있는데 각각은 이어지는 세 점이나 네 점을 각각 2차함수와 3차함수로 근사하여 적분하는 방법이다.\n\n\n\n중점을 이용한 적분\n중점을 이용한 적분은 구간 \\([a,\\,b]\\) 와 함수 \\(f(x)\\) 가 주어졌을 때 가장 간단하고 빠르게 적분을 구하는 방법이다. \\([a,\\,b]\\) 구간을 \\(n-1\\) 개의 구간으로 나누어,\n\\[\na=x_1 &lt; x_2 &lt; \\cdots &lt; x_n=b\n\\]\n이며 \\(i=1,\\ldots,\\,n-1\\) 에 대해 \\(x_{i+1}-x_i = h\\) 라고 하자.\n\\[\n\\int_{a}^{b}f(x)\\,dx = \\sum_{i=1}^{n-1}\\int_{x_i}^{x_{i+1}}f(x)\\, dx\n\\]\n임을 안다. \\([x_{i},\\, x_{i+1}]\\) 구간에 대한 적분을 구할 때 구간의 양 끝점에 대한 중점 \\(x^m_i = \\dfrac{x_{i+1}+x_{i}}{2}\\) 에서의 함수값을 사용하는 방법이다. 즉,\n\\[\n\\int_{x_{i}}^{x_{i+1}} f(x)\\,dx\\approx f\\left(\\dfrac{x_{i+1}+x_i}{2}\\right) h = f(x^m_i) h\n\\]\n로 근사하는 방법이다. 테일러 정리에 의해\n\\[\nf(x) = f(x^m_i)+f'(x^m_i)(x-x_m) + \\dfrac{1}{2}f^{(2)}(\\xi) (x-x_i^m)^2\n\\]\n을 만족하는 \\(\\xi_i\\in [x_{i},\\, x_{i+1}]\\) 이 존재한다는 것을 안다. 위 식을 적분하면\n\\[\n\\int_{x_i}^{x_{i+1}} f(x)\\, dx = f(x_i^m)h + \\dfrac{1}{24}f^{(2)}(\\xi_i)h^3\n\\]\n이며, 따라서 \\([a,\\,b]\\) 구간에서의 적분은\n\\[\n\\int_a^b f(x) \\,dx= \\sum_{i=1}^{n-1} f\\left(\\dfrac{x_{i}+x_{i+1}}{2}\\right) h + \\dfrac{h^3}{24} \\sum_{i=1}^{n-1}f^{(2)}(\\xi_i)\n\\]\n이다. \\(f\\in C^2_{[a,\\,b]}\\) 라면 따름정리 : 여러 점의 경우 에 의해 \\(\\displaystyle \\sum_{i=1}^{n-1}f^{(2)}(\\xi_i) = (n-1)f^{(2)}(\\xi)\\) 를 만족하는 \\(\\xi\\in [a,\\,b]\\) 가 존재하므로,\n\\[\n\\int_a^b f(x) \\, dx =  \\sum_{i=1}^{n-1} f\\left(\\dfrac{x_{i}+x_{i+1}}{2}\\right) h + \\dfrac{(n-1)h^3}{24} f^{(2)}(\\xi)\n\\]\n를 만족한다. 적분의 근사값을 \\(I_M[a, b, n]\\) 을\n\\[\nI_M [f,\\,a,\\,b,\\,n] = \\sum_{i=1}^{n-1}f\\left(\\dfrac{x_{i}+x_{i+1}}{2}\\right) h\n\\]\n이라고 할 수 있으며, \\(M=\\max \\{ |f^{(2)}(x)| : x\\in [a,\\,b] \\}\\) 일 때 중점을 이용한 적분의 오차는 \\(E_M [f,\\,a,\\,b,\\,n]=\\dfrac{(n-1)h^3}{24} M=\\dfrac{(b-a)M}{24}h^2\\) 보다 작거나 같다. 즉 \\(O(E_M) =h^2\\) 이다.\n\n\n\n사다리꼴 방법 를 이용한 적분\n사다리꼴 방법은 \\([a,\\,b]\\) 구간에 대한 함수 \\(f(x)\\) 가 주어졌거나 수열 \\(x_1,\\ldots,\\,x_n\\) 과 \\(f(x_i)= y_i\\) 가 주어졌을 때 사용할 수 있다. 여기서도\n\\[\na=x_1&lt;x_2&lt;\\cdots &lt;x_n=b\n\\]\n가 성립한다고 하자. 함수 \\(f(x)\\) 를 \\([x_i,\\, x_{i+1}]\\) 구간에서 1차 다항식 \\(\\tilde{f}(x) = \\dfrac{y_{i+1}-y_i}{x_{i+1}-x_i}(x-x_i)+y_i\\) 으로 근사하는 것을 사다리꼴 방법 (trapzoidal method) 이라고 한다.\n\n\\([x_{i-1},\\, x_i]\\) 구간에서 \\((x_{i-1},\\, f(x_{i-1}))\\) 과 \\((x_{i},\\, f(x_i))\\) 를 1차 다항식으로 근사하면 다항식을 이용한 보간법의 오차 의 정리 1 에서 보았듯이 다음을 만족하는 \\(\\xi\\in [x_{i-1},\\, x_i]\\) 가 존재한다. \\[\n\\begin{aligned}\nf(x) = \\tilde{f}(x) + \\dfrac{f^{(2)}(\\xi_i)}{2}(x-x_{i-1})(x-x_i).\\\\\n\\end{aligned}\n\\]\n이것을 \\([x_{i-1},\\, x_i]\\) 구간에서 적분하면 다음을 얻는다.\n\\[\n\\begin{aligned}\n\\int_{x_{i-1}}^{x_i} f(x)\\, dx = \\dfrac{h}{2}(f(x_{i-1})+f(x_i)) -\\dfrac{f^{(2)}(\\xi)}{12} h^3\n\\end{aligned}\n\\]\n전체 구간 \\([a,\\,b]\\) 에 대해 적분하면\n\\[\n\\int_{a}^b f(x)\\, dx= \\dfrac{h}{2}(f(x_1)+ f(x_n)) + \\sum_{i=2}^{n-1} hf(x_i) - \\dfrac{h^3}{12}\\sum_{i=1}^{n-1} f^{(2)}(\\xi_i)\n\\]\n를 얻는다. 사다리꼴 방법에 의한 적분값 \\(I_T\\) 는\n\\[\nI_T[f, a, b, n] = \\dfrac{h}{2}\\left(f(x_1)+ f(x_n) + \\sum_{i=2}^{n-1} f(x_i)\\right)\n\\tag{8}\\]\n이다. 이제 적분의 오차를 알아보자. \\(f^{(2)}(x)\\) 가 연속이므로 \\(\\displaystyle \\dfrac{1}{n-1}\\sum_{i=1}^{n-1} f^{(2)}(\\xi_i)= f^{(2)}(\\xi)\\) 를 만족하는 \\(\\xi\\in [a,\\,b]\\) 가 존재하며2 따라서 사다리꼴 방법에 의한 적분에 대한 에러 \\(E_T\\) 는\n\\[\nE_T[f, a, b, n] = \\dfrac{h^3}{12}(n-1)f^{(2)}(\\xi) = \\dfrac{h^3}{12}\\dfrac{b-a}{h}f^{(2)}(\\xi) = \\dfrac{(b-a)f^{(2)}(\\xi)}{12}h^2 = O(h^2)\n\\tag{9}\\]\n이다.\n\n\n\nSimpson 1/3 적분\n\\([x_{i-1},\\,x_{i+1}]\\) 구간에서의 적분을 생각하자. 테일러 정리에 의해\n\\[\nf(x) = f(x_i) + f'(x_i)(x-x_i) + \\dfrac{f''(x_i)}{2}(x-x_i)^2 + \\dfrac{f^{(3)}(x_i)}{6}(x-x_i)^3 + \\dfrac{f^{(4)}(\\xi_i)}{24}(x-x_i)^4\n\\]\n를 만족하는 \\(\\xi_i \\in [x_{i-1},\\, x_{i+1}]\\) 이 존재한다. 양변을 적분하면\n\\[\n\\begin{aligned}\n\\int_{x_{i-1}}^{x_{i+1}}f(x)\\,dx &= f(x_i)(2h) + \\dfrac{f''(x_i)}{3}h^3 + \\dfrac{f^{(4)}(\\xi_i)}{60}h^5\n\\end{aligned}\n\\]\n이다. 또한 식 4 로부터\n\\[\nf''(x) =  \\dfrac{f(x+h) - 2f(x) + f(x-h)}{h^2} - \\dfrac{f^{(4)}(\\xi_i')}{36}h^5\n\\]\n를 만족하는 \\(\\xi_i'\\in [x_{i-1},\\,x_{i+1}]\\) 가 존재한다는 것을 알고 있다. 따라서\n\\[\n\\begin{aligned}\n\\int_{x_{i-1}}^{x_{i+1}}f(x)\\,dx &= f(x_i)(2h) + \\dfrac{h}{3}\\left( f(x_{i+1}) -2f(x_i) + f(x_{x-i}) \\right)  + \\left(\\dfrac{f^{(4)}(\\xi_i)}{60} - \\dfrac{f^{(4)}(\\xi_i')}{36} \\right)h^5 \\\\\n&=\\dfrac{1}{3} \\left[f(x_{i-1}) + 4f(x_{i}) + f(x_{i+1})\\right] -  \\left( \\dfrac{f^{(4)}(\\xi_i')}{36} - \\dfrac{f^{(4)}(\\xi_i)}{60} \\right)h^5\n\\end{aligned}\n\\]\n따라서 우리는 Simpson 1/3 적분에서의 오차가 \\(O(h^5)\\) 임을 알 수 있다. 여기서는 \\(\\xi_i\\) 와 \\(\\xi_i'\\) 에서의 4계 도함수값이 필요했지만 실제로는\n\\[\n\\begin{aligned}\n\\int_{x_{i-1}}^{x_{i+1}}f(x)\\,dx =\\dfrac{h}{3} \\left[f(x_{i-1}) + 4f(x_{i}) + f(x_{i+1})\\right] -  \\dfrac{f^{(4)}(\\overline{\\xi}_i)}{90}h^5\n\\end{aligned}\n\\]\n를 만족하는 \\(\\overline{\\xi}_i \\in [x_{i-1},\\,x_{i+1}]\\) 가 존재한다(Atkinson, Kendall E. (1989). An Introduction to Numerical Analysis (2nd ed.). John Wiley & Sons. 을 참고하라)\n이제 \\([a,\\,b]\\) 구간을 \\(a=x_1&lt;x_2&lt;\\cdots&lt;x_{2m}&lt;x_{2m+1}=b\\) 의 \\(2m\\) 개의 구간으로 나누어 적분하여 합치는 것을 생각하자. Simpson 1/3 적분은 2개의 구간을 한꺼번에 적분하므로 \\(2m+1\\) 개의 위치가 필요하다. 에러도 \\(2m+1\\) points 에 대한 중간값 정리를 사용하면 다음을 만족하는 \\(\\xi \\in [x_1,\\,x_{2m+1}]\\) 이 존재한다.\n\\[\n\\begin{aligned}\n\\int_{a}^b f(x)\\, dx &= \\dfrac{h}{3} \\left[f(x_1) + 4f(x_2) + 2f(x_3) + 4f(x_4) + 2f(x_5)+\\cdots \\right.\\\\\n&\\qquad \\cdots \\left.+ 4f(x_{2m-2})+2f(x_{2m-1}) + 4f(x_{2m})+f(x_{2m+1})\\right] - m\\dfrac{f^{(4)}(\\xi)}{90}h^5\n\\end{aligned}\n\\]\n따라서 Simpson 1/3 적분값은 다음과 같다. \\[\n\\mathcal{I}_{1/3}[f,\\,a,\\,b,\\, 2n+1] = \\dfrac{h}{3} \\left[f(x_1) + f(x_{2m+1}) + 4\\left(\\sum_{k=1}^m  f(x_{2k})\\right) + 2\\left(\\sum_{k=1}^{m-1} f(x_{2k+1})\\right)\\right]\n\\tag{10}\\]\n\n\n\nSimpson 3/8 적분\nSimpson 1/3 적분이 전체 \\(n-1\\) 개의 구간을 2개씩 묶어서 적분하여 합쳤다면 3/8 적분은 3개씩 묶어서 합친다. 라그랑쥬 다항식을 이용하면,\n\\[\nL_4(x) = f(x_{i-1})l_{i-1}(x) + f(x_i)l_i(x) + f(x_{i+1})l_{i+1}(x) + f(x_{i+2})l_{i+2}(x)\n\\]\n에 대해\n\\[\nf(x) = L_4 (x) + \\dfrac{f^{(4)}(\\xi_i)}{4!}\\prod_{j=1}^4(x-x_{j-2})\n\\]\n를 만족하는 \\(\\xi_i\\in [x_{i-1},\\, x_{i+2}]\\) 가 존재한다.\n\\[\n\\begin{aligned}\n\\int_{x_{i-1}}^{x_{i+2}} f(x)\\, dx = \\dfrac{3h}{8} \\left( f(x_{i-1}) + 3 f(x_{i}) + 3f(x_{i+1}) + f(x_{i+2})\\right) - \\dfrac{3}{80}f^{(4)}(\\xi) h^5\n\\end{aligned}\n\\]\n를 얻는다. 이것을 \\([a,\\,b]\\) 구간을 \\(a=x_1&lt;\\cdots &lt;x_{3m+1}=b\\) 이며 \\(x_{i+1}-x_i = h=\\text{const.}\\) 라면\n\\[\n\\begin{aligned}\n\\int_a^b f(x)\\, dx &= \\dfrac{3h}{8} \\left[f(x_1) + f(x_{3m+1}) + 3\\sum_{i=0}^{m-1} \\left(f(x_{3i+2}) + f(x_{3i+3})\\right)  + 2\\sum_{i=1}^{m-1} f(x_{3i+1})\\right] - \\dfrac{3m}{80}f^{(4)} (\\xi) h^5\n\\end{aligned}\n\\]\n를 만족하는 \\(\\xi \\in [a,\\,b]\\) 가 존재한다. 여기서\n\\[\n\\mathcal{I}_{3/8}[f,\\,a,\\,b,\\, 3m+1]=\\dfrac{3h}{8} \\left[f(x_1) + f(x_{3m+1}) + 3\\sum_{i=0}^{m-1} \\left(f(x_{3i+2}) +f(x_{3i+3})\\right) +  + 2\\sum_{i=1}^{m-1} f(x_{3i+1})\\right]\n\\tag{11}\\]\n는 Simpson 3/8 적분값이며 그 오차는 \\(- \\dfrac{3m}{80}f^{(4)} (\\xi) h^5\\) 이다.\n\n\n아래 그림은 \\(\\displaystyle \\int_0^1 \\exp(x)\\, dx\\) 를 세가지 방법으로, 구간을 변화시켜 가며 구하여 실제값인 \\((e-1)\\) 로 나눈 비율을 표현하였다. \\(N_{points}\\) 가 작을 때는 계산값간의 다소간의 차이가 있으며 실제 값과도 차이가 있지만 \\(N_{points}\\) 값이 커질수록 세 방법 모두 실제 값에 수렴해 나간다는 것을 볼 수 있다. 또 하나 유의할 것은 Simpson 3/8 방법이 Simpson 1/3 방법보다 다소 복잡함에도 불구하고 일반적으로 실제 값과의 차이는 Simpson 1/3 방법이 더 작다. 이런 이유로 단순이 Simpson 방법이라고 할 때는 Simpson 1/3 방법을 말한다.\n\n\n\n수치 적분\n\n\nfunction integrate_trapzoidal(\n    f::Function, \n    a::Number, \n    b::Number, \n    n::Integer)\n    \n    a, b = minmax(a, b)\n    h = (b-a)/(n-1)\n    x = range(a, b, length = n)\n    ff = f.(x)\n    result = 0.5*(ff[1]+ff[end])\n    result += sum(ff[2:end-1])\n    return result*h\nend\n\nfunction integrate_simpson_1_3(\n    f::Function, \n    a::Number, \n    b::Number, \n    n::Integer)\n    \n    @assert n %2 == 1\n    a, b = minmax(a, b)\n    h = (b-a)/(n-1)\n    x = range(a, b, length = n)\n    ff = f.(x)\n    result = (ff[1]+ff[end])\n    result += 4*sum(ff[2:2:end-1])\n    result += 2*sum(ff[3:2:end-2])\n    return result * h/3\nend\n\nfunction integrate_simpson_3_8(\n    f::Function, \n    a::Number, \n    b::Number, \n    n::Integer)\n    \n    @assert n %3 == 1\n    a, b = minmax(a, b)\n    h = (b-a)/(n-1)\n    x = range(a, b, length = n)\n    println(\"h=$h, dx=$(x[10]-x[9])\")\n    ff = f.(x)\n    result = (ff[1]+ff[end])\n    result += 3*sum(ff[2:3:end-2])\n    result += 3*sum(ff[3:3:end-1])\n    result += 2*sum(ff[4:3:end-3])\n    return result * h * 3 / 8\nend",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "일변수 함수의 미분과 적분"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/06_calculus_of_one_variable_function.html#리처드슨-외삽법과-롬버그-적분",
    "href": "src/numerical_analysis_using_julia/06_calculus_of_one_variable_function.html#리처드슨-외삽법과-롬버그-적분",
    "title": "일변수 함수의 미분과 적분",
    "section": "3 리처드슨 외삽법과 롬버그 적분",
    "text": "3 리처드슨 외삽법과 롬버그 적분\n\n리처드슨 외삽법\n오차가 작은 알고리즘을 사용하는 것은 일반적으로 오차가 큰 알고리즘을 계산하는 것보다 자원을 많이 사용한다. 리차드슨 외삽법은 오차가 큰 알고리즘에 의한 계산값을 사용하여 오차가 작은 계산값을 얻는 방법으로 많은 경우 같은 오차의 알고리즘으로 직접 계산하는 것보다 자원을 덜 소모하는 경우가 많아 다양한 분야에 널리 사용된다.\n어떤 값 \\(M\\) 을 계산하는데 매개변수 \\(h\\) 에 대해 그 truncation 오차가 \\(O(h)\\) 인 방법을 사용하여 \\(N_1(h)\\) 를 얻었다고 하자. 이 때 우리는\n\\[\nM - N_1(h) = k_1 h + k_2 h^2 + O(h^3)\n\\tag{12}\\]\n라고 생각 할 수 있다. 이것을 약간 변형하면,\n\\[\nM-N_1\\left(\\dfrac{h}{2}\\right) = k_1 \\dfrac{h}{2} + k_2 \\dfrac{h^2}{4} + O(h^3)\n\\tag{13}\\]\n이며 \\(2\\times\\)(식 13)\\(-\\)(식 12) 를 계산하면,\n\\[\n\\begin{aligned}\nM&=\\left[2N_1\\left(\\dfrac{h}{2}\\right) - N_1(h) \\right] - k_2 \\dfrac{h^2}{2} + O(h^3) = N_2(h) + O(h^2) \\\\\n&\\qquad \\qquad \\text{where} \\; N_2(h) = \\left[2N_1\\left(\\dfrac{h}{2}\\right) - N_1(h) \\right]\n\\end{aligned}\n\\]\n이다. 즉 \\(O(h)\\) 인 방법을 이용하여 truncation 오차가 \\(O(h^2)\\) 인 추정값 \\(N_2(h)\\) 를 얻었다. 이렇게 정확도가 낮은 값을 이용하여 정확도가 높은 값을 얻는 것을 리처드슨 외삽법이라고 한다. 리처드슨 외삽법은 truncation 오차가 다항식 꼴인 방법에 대해 항상 사용 할 수 있다.\n\\(M\\) 에 대해 tuncation 오차가 \\(O(h^2)\\) 인 방법을 사용하여 \\(N_2(h)\\) 를 얻었다고 하자.\n\\[\n\\begin{aligned}\nM - N_2 (h) &= k_2h^2 + k^3 h^3 + O(h^4) , \\\\\nM - N_2 \\left(\\dfrac{h}{2}\\right) &= k_2\\dfrac{h^2}{4} + k_3 \\dfrac{h^3}{8} + O(h^4)\n\\end{aligned}\n\\]\n를 이용하여,\n\\[\n\\begin{aligned}\nM &= \\dfrac{1}{3}\\left[4N_2 \\left(\\dfrac{h}{2}\\right)-N_2(h)\\right] - k_3 \\dfrac{h^3}{6} + O(h^4) = N_3(h) + O(h^3) \\\\\n&\\qquad \\qquad \\text{where} \\; N_3(h)=\\dfrac{1}{3}\\left[4N_2 \\left(\\dfrac{h}{2}\\right)-N_2(h)\\right]\n\\end{aligned}\n\\]\n를 얻는다. 즉 \\(O(h^2)\\) 인 방법을 이용하여 \\(O(h^3)\\) 인 값을 얻었다.\n이것을 일반화하여 보자. \\(O(h^m)\\) 인 방법을 사용하여 \\(M\\) 의 값을 \\(N_m(h)\\) 로 얻었다고 하자.\n\\[\n\\begin{aligned}\nM - N_m(h) &=  k_m h^m + k_{m+1}h^{m+1} + O(h^{m+2}), \\\\\nM - N_m\\left(\\dfrac{h}{2}\\right) & = k_m \\left(\\dfrac{h}{2}\\right)^m + k_{m+1}\\left(\\dfrac{h}{2}\\right)^{m+1} + O(h^{m+2})\n\\end{aligned}\n\\]\n를 이용하여,\n\\[\n\\begin{aligned}\nM &= \\dfrac{1}{2^m-1}\\left[ 2^m N_m \\left(\\dfrac{h}{2}\\right)-N_m (h)\\right] - \\dfrac{k_{m+1}}{2(2^m-1)}h^{m+1} + O(h^{m+2}) \\\\\n&= N_{m+1}(h) + O(h^{m+1})\n\\end{aligned}\n\\tag{14}\\]\n을 얻는다.\n\n\n짝수승 오차의 리차드슨 외삽법\n수치해석에서 많은 경우 truncation error 가 변수의 짝수승에만 관련이 있다. 즉,\n\\[\nM = N_1(h) + k_2h^2 + k_4 h^4 + k_6 h^6 + \\cdots\n\\]\n라고 하자. \\(O(h^{2m})\\) 오차를 가진 \\(N_{2m}(h)\\) 를 얻었다고 하자.\n\\[\n\\begin{aligned}\nM - N_{2m}(h) &= k_{2m}h^{2m} + O(h^{2m+2}), \\\\\nM - N_{2m}\\left(\\dfrac{h}{2}\\right) &= k_{2m} \\left(\\dfrac{h}{2}\\right)^{2m} + O(h^{2m+2})\n\\end{aligned}\n\\]\n로부터,\n\\[\n\\begin{aligned}\nM &= \\dfrac{1}{4^{m} -1} \\left[4^{m}N_{2m} \\left(\\dfrac{h}{2}\\right) - N_{2m}(h)\\right] + O(h^{2m+2}), \\\\\n\\end{aligned}\n\\]\n를 얻는다. 즉\n\\[\nN_{2m+2}(h) =  \\dfrac{1}{4^{m} -1} \\left[4^{m}N_{2m} \\left(\\dfrac{h}{2}\\right) - N_{2m}(h)\\right]\n\\tag{15}\\]\n를 얻는다.\n\n\n\n\n롬버그 적분\n\n\n\n\n\n\n주의\n\n\n\n교과서적인 교재에서 \\(R_{k, j}\\) 로 쓰는 표기법은 리처드슨 외삽법의 표기법을 좀 꼬아서 사용하기 때문에 개인적으로 마음에 들지 않았다. 여기서는 리처드슨 외사법의 표기법을 거의 그대로 가지고 오는 방법으로 표기하도록 하겠다. 다른 교재들과는 다르므로 혼동을 줄 수 있다.\n\n\n앞서 사다리꼴 방법을 통해 \\(O(h^2)\\) 의 오차를 갖는 함수 \\(f\\) 의 적분값을 얻었다. 이것을 짝수승 오차의 리차드슨 외삽법과 결합하면 \\(O(h^4)\\) 의 오차를 갖는 적분값을 계산 할 수 있을 것이다.\n식 8 의 사다리꼴 적분 \\(I_T[f, a, b, n]\\) 에서 \\(n\\) 을 \\(2^k\\) 로 잡았을 때의 적분을 \\(N_{k, 1}\\) 이라고 하자. 즉,\n\\[\nN_{k, 1} = I_T[f, a, b, 2^k] = \\dfrac{h}{2}\\left(f(x_1)+ f(x_{2^k}) + \\sum_{i=2}^{2^k-1} f(x_i)\\right)\n\\tag{16}\\]\n이라고 하자. 이 때의 오차는 \\(O(h^2)\\) 이다. \\(k=1,\\ldots, k_M\\) 에 대해 \\(N_{k, 1}\\) 을 구할 수 있다. \\(m\\le k_M-1\\) 에 대해 \\(N_{1, m}, \\ldots, N_{k_M-m+1, m}\\) 의 값을 구하였다고 하자. 식 15 를 이용하여, \\(O(h^{2m+2})\\) 의 오차를 갖는 \\(2^k-1\\) 개의 구간을 갖는 적분 \\(N_{k, m+1}\\) 은 \\[\nN_{k, m+1} = \\dfrac{1}{4^{m} -1} \\left[4^{m}N_{k+1, m}  - N_{k, m}\\right] + O(h^{2m+2}), \\qquad k = 1, \\ldots k_M-m+1\n\\]\n를 통해 얻을 수 있다.\nfunction rhomberg(f::Function, a::Number, b::Number, order::Integer = 4)\n    @assert order &gt; 2\n    N = zeros(order, order) \n    N[:, 1]= [integrate_trapzoidal(f, a, b, 2^k) for k in 1:order]\n    for m = 1:order, k = 1:order-m\n        N[k, m+1] = 1.0/(4^m-1.0) *(4^m * N[k+1, m]- N[k, m]) \n    end\n    return N[1, end]\nend\n함수 \\(f(x)\\) 를 \\([a,\\,b]\\) 구간에서 \\(n=2^{k_{M}}-1\\) 개의 구간, 즉 \\(a=x_1 &lt; \\cdots &lt; x_n=b\\) 의 구간에서의 사다리꼴 적분을 수행했다면 \\(h= \\dfrac{b-a}{n-1}\\) 에 대해 \\(O(h^2)\\) 의 정확도를 갖는 적분이지만 롬버그 적분을 통해 \\(O(h^{2{k_M}+2})\\) 의 정확도를 갖는 적분값을 구할 수 있다. 더구나. 실제로 계산하는 함수값의 갯수는 \\(n\\) 개이며 나머지는 이미 계산된 값들에 대한 단순한 사칙연산이므로 훨씬 빠르게 계산 할 수 있다.\n예를 들어 우리는 \\(\\displaystyle \\int_0^1 \\sqrt{x}\\, dx=\\frac{2}{3}\\) 임을 안다. 롬버그 적분을 통해 \\(k_M=4\\) 으로 계산한 결과는 \\(0.665693\\) 이며 이것보보다 오차가 작은 사다리꼴 적분을 얻기 위해서는 구간을 35개의 구간으로, 즉 \\(x_1=0,\\, x_{36}=1\\) 로 나누어야 한다.",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "일변수 함수의 미분과 적분"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/06_calculus_of_one_variable_function.html#가우스-구적법",
    "href": "src/numerical_analysis_using_julia/06_calculus_of_one_variable_function.html#가우스-구적법",
    "title": "일변수 함수의 미분과 적분",
    "section": "4 가우스 구적법",
    "text": "4 가우스 구적법\n함수 \\(f(x)\\) 를 \\([a,\\,b]\\) 구간에서 적분 할 때 \\([a,\\,b]\\) 구간에서 \\(n\\) 개의 점 \\(x_1,\\ldots,\\,x_n\\) 을 선택하여\n\\[\n\\int_a^b f(x) \\, dx \\approx a_1 f(x_1)+ \\cdots + a_n f(x_n)\n\\]\n로 근사하는 것을 가우스 구적법 (Gaussian quadrature) 라고 한다. 뉴턴 코츠 방법은 점 \\(x_1,\\ldots,\\,x_n\\) 이 등간격인데 반해 가우스 구적법은 등간격일 필요가 없으며, 적분을 잘 근사하는 점을 찾아야 한다는 것이다. 가우스 구적법은 \\(x_1,\\ldots,\\,x_n\\) 을 선택해야 하며 등간격일 필요가 없다. 이 \\(x_1,\\ldots,\\,x_n\\) 을 노드(nodes) 라고 한다.\n\n본격적으로 들어가기 전에 이미 미적분학에서 배웠을 한가지를 확인하고 가자. 우리는 임의의 구간 \\([a,\\,b]\\) 에 대한 함수 \\(f(x)\\) 의 적분을 \\([-1,\\,1]\\) 구간에 대한 적분으로 바꿀 수 있다. 즉,\n\\[\n\\int_{a}^b f(x)\\, dx = \\int_{-1}^1 f\\left(\\dfrac{(b-a)t+ (b+a)}{2}\\right)\\,\\left(\\dfrac{b-a}{2}\\right) dt\n\\tag{17}\\]\n이다.\n\n르장드르 다항식을 이용한 가우스 구적법\n\\(n\\) 차 르장드르 다항식 \\(P_n(x)\\) 은 다음과 같은 성질을 가진다.\n  (\\(1\\)) \\(P_n(x)\\) 는 \\(n\\) 차 다항식으로 최고차항의 계수는 항상 \\(1\\) 이다.\n  (\\(2\\)) \\(\\displaystyle \\int_{-1}^1 P_n (x) \\, P_m (x)\\, dx = \\dfrac{\\delta_{mn}}{2n+1}\\) 이다.\n  (\\(3\\)) \\(P_0(x) = 1,\\, P_1(x) = x\\) 이며 아래의 점화식으로 고차 다항식을 구할 수 있다.\n\\[\n(n+1)P_{n+1}(x) - (2n+1)xP_{n}(x) + nP_{n-1}(x)=0\n\\]\n  (\\(4\\)) \\(P_n(-x) = (-1)^nP_n(x)\\), \\(P_n(1) = 1\\).\n  (\\(5\\)) \\(n\\ge 1\\) 에 대한 \\(P_n(x)\\) 는 \\([-1,\\,1]\\) 구간에서 \\(n\\) 개의 서로 다른 근을 갖는다.\n  (\\(6\\)) 임의의 \\(n\\) 차 다항식은 \\(P_1(x),\\ldots,\\,P_n(x)\\) 의 선형결합으로 표현 할 수 있다.\n\n\n\n명제 1 \\(P_n(x)\\) 에 대한 \\(n\\) 개의 근을 \\(x_1,\\ldots,\\,x_n\\) 이라고 하고 \\(c_i = \\displaystyle \\int_{-1}^1 \\prod_{j=1,\\, j\\ne i}^n \\dfrac{x-x_j}{x_i-x_j}\\, dx\\) 라고 하면 임의의 다항식 \\(p(x)\\) 에 대해 다음이 성립한다.\n\\[\n\\int_{-1}^1 p(x) \\, dx = \\sum_{i=1}^n c_i p(x_i).\n\\]\n\n\n\n\n(증명). (\\(1\\)) 우선 \\(p(x)\\) 의 차수가 \\(n\\) 보다 작은 경우를 보자. \\(p(x)\\) 를 라그랑쥬 다항식에 대해 표현하면\n\\[\np(x) = \\sum_{i=1}^n p(x_i)l_i(x) = \\sum_{i=1}^n \\prod_{j=1,\\, j\\ne i}^n \\dfrac{x-x_j}{x_i-x_j} p(x_i)\n\\]\n이며,\n\\[\n\\begin{aligned}\n\\int_{-1}^1 p(x)\\, dx &=\\int_{-1}^1 \\left[\\sum_{i=1}^n \\prod_{j=1,\\, j\\ne i}^n \\dfrac{x-x_j}{x_i-x_j} p(x_i)\\right]\\, dx \\\\\n&= \\sum_{i=1}^n  \\left[\\prod_{j=1,j\\ne i}^n \\int_{-1}^1 \\dfrac{x-x_j}{x_i-x_j}\\, dx \\right] p(x_i)  = \\sum_{i=1}^n c_i p(x_i)\n\\end{aligned}\n\\]\n이다.\n(\\(2\\)) 이제 \\(p(x)\\) 의 차수 \\(m\\) 이 \\(n\\) 보다 크거나 같고 \\(2n\\) 보다 작은 경우를 보자. 다항식의 나누기를 생각하면,\n\\[\np(x) =  q(x)P_n (x) + r(x)\n\\]\n를 생각 할 수 있다. 이 때 \\(x_i,\\, i=1,\\ldots,\\,n\\) 은 \\(P_n(x)\\) 의 근이므로\n\\[\np(x_i) = r(x_i)\n\\]\n이다. 여기서 \\(q(x)\\) 는 \\(m-n\\) 차 다항식이고 \\(r(x)\\) 는 \\(n\\) 보다 차수를 갖는 다항식이다. 르장드르 다항식의 성질 (\\(6\\)) 으로 부터 우리는 \\(q(x)\\) 가 \\(P_1(x),\\ldots,\\,P_{m-n}\\) 의 선형결합으로 표현 될 수 있다는 것을 안다. \\(m&lt;2n\\) 이므로 \\(m&lt;n\\) 이며, 르장드르 다항식의 성질 (\\(2\\)) 에 의해 \\(\\int q(x)P_n(x) = 0\\) 이다. 따라서\n\\[\n\\int_{-1}^1 p(x) = \\int_{-1}^1 r(x) = \\sum_{i=1}^n\\left[\\prod_{j=1,j\\ne i}^n \\int_{-1}^1 \\dfrac{x-x_j}{x_i-x_j}\\, dx \\right] r(x_i) = \\sum_{i=1}^n c_i p(x_i)\n\\]\n이다.\n\n이제 \\(P_n(x)\\) 에 대한 근을 통해 \\(\\displaystyle C_n^i = \\left[\\prod_{j=1,j\\ne i}^n \\int_{-1}^1 \\dfrac{x-x_j}{x_i-x_j}\\, dx \\right]\\) 를 테이블로 가지고 있다면 우리는 적분을 쉽게 계산 할 수 있다. 아래는 \\(n=2\\) 부터 \\(n=7\\) 까지의 테이블이다.\n\n르장드르 함수를 이요한 가우스 구적법 {#tbl-gauss_quadrature} \n\n\norder\nPoint\nWeight\n\n\n\n\n2\n-0.577350269189626\n1.000000000000000\n\n\n2\n0.577350269189626\n1.000000000000000\n\n\n3\n0.000000000000000\n0.888888888888889\n\n\n3\n-0.774596669241483\n0.555555555555556\n\n\n3\n0.774596669241483\n0.555555555555556\n\n\n4\n-0.339981043584856\n0.652145154862546\n\n\n4\n0.339981043584856\n0.652145154862546\n\n\n4\n-0.861136311594053\n0.347854845137454\n\n\n4\n0.861136311594053\n0.347854845137454\n\n\n5\n0.000000000000000\n0.568888888888889\n\n\n5\n-0.538469310105683\n0.478628670499367\n\n\n5\n0.538469310105683\n0.478628670499367\n\n\n5\n-0.906179845938664\n0.236926885056189\n\n\n5\n0.906179845938664\n0.236926885056189\n\n\n6\n0.661209386466264\n0.360761573048139\n\n\n6\n-0.661209386466264\n0.360761573048139\n\n\n6\n-0.238619186083197\n0.467913934572691\n\n\n6\n0.238619186083197\n0.467913934572691\n\n\n6\n-0.932469514203152\n0.171324492379170\n\n\n6\n0.932469514203152\n0.171324492379170\n\n\n7\n0.000000000000000\n0.417959183673469\n\n\n7\n0.405845151377397\n0.381830050505119\n\n\n7\n-0.405845151377397\n0.381830050505119\n\n\n7\n-0.741531185599394\n0.279705391489277\n\n\n7\n0.741531185599394\n0.279705391489277\n\n\n7\n-0.949107912342758\n0.129484966168870\n\n\n7\n0.949107912342758\n0.129484966168870\n\n\n\n르장드르 함수를 이용한 가우스 구적법은 NAJ.jl 의 integrate_gauss_quadrature 함수로 구현되었다. 위의 테이블을 이용하여 쉽게 구한다. 간단한 예로 함수 \\(f(x)=x^4\\) 의 \\([0,\\,1]\\) 구간에서의 적분을 \\(n=3\\) 에서 구하는 방법은 아래와 같다. 답은 0.2 가 정확히 나온다.\nusing NAJ\nintegrate_gauss_quadrature(x-&gt;x^4, 3, 0, 1)\n르장드르 함수를 이용한 가우스 구적법은 적분하고자 하는 함수가 매끄럽고 적분 구간에서 발산하지 않을 때 사용할 수 있다.",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "일변수 함수의 미분과 적분"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/06_calculus_of_one_variable_function.html#footnotes",
    "href": "src/numerical_analysis_using_julia/06_calculus_of_one_variable_function.html#footnotes",
    "title": "일변수 함수의 미분과 적분",
    "section": "각주",
    "text": "각주\n\n\n더 정확히 말하자면 불연속인 점이 무한개라도 가산(countable) 이면 적분이 존재하지만, 어짜피 불연속인 점이 무한개일 경우는 여기서 다루지 않는다.↩︎\n최대 최소 정리 을 생각하자. \\([a,\\,b]\\) 구간에서 연속인 함수 \\(g(x)\\) 는 최대값 \\(g_M\\) 과 최소값 \\(g_m\\) 을 가진다. \\(\\{x_1,\\ldots,\\,x_n\\}\\subset [a,\\,b]\\) 라면 \\(g_m \\le g(x_i) \\le g_M\\) 이며, \\[\ng_m \\le \\dfrac{g(x_1)+ \\cdots + g(x_n)}{n}  \\le g_M\n\\] 이다. 중간값 정리에 의해 \\(g(\\overline{\\xi}) =  \\dfrac{g(x_1)+ \\cdots + g(x_n)}{n}\\) 를 만족하는 \\(\\overline{\\xi}\\in [a,\\,b]\\) 가 존재한다.↩︎",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "일변수 함수의 미분과 적분"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/10_least_square_problem.html",
    "href": "src/numerical_analysis_using_julia/10_least_square_problem.html",
    "title": "최소자승 문제",
    "section": "",
    "text": "\\(\\mathbb{C}^{n\\times 1}\\) 에서의 벡터 \\(\\boldsymbol{v}\\) 에 대해 다음과 같이 정의된 \\(\\boldsymbol{H}_v\\) 를 하우스홀더 행렬 (Householder matrix) 이라 한다.\n\\[\n\\begin{aligned}\n\\boldsymbol{H}_{\\boldsymbol{v}} := I_n- \\dfrac{2\\boldsymbol{v}\\boldsymbol{v}^{\\ast}}{\\|\\boldsymbol{v}\\|^2}, \\qquad \\text{i. e. }\\quad\n(\\boldsymbol{H}_{\\boldsymbol{v}})_{ij} := \\delta_{ij} - \\dfrac{2 v_i \\overline{v_j}}{\\|\\boldsymbol{v}\\|^2}.\n\\end{aligned}\n\\]\n여기서 \\(\\boldsymbol{v}\\boldsymbol{v}^{\\ast}\\) 는 벡터의 내적이 아니라 \\(n\\times 1\\) 행렬 \\(\\boldsymbol{v}\\) 와 \\(1 \\times n\\) 행렬 \\(\\boldsymbol{v}^{\\ast}\\) 가 곱해진 \\(n \\times n\\) 행렬을 의미한다. 벡터 \\(\\boldsymbol{x}\\in \\mathbb{C}^n\\) 에 대해 \\(\\boldsymbol{H}_{\\boldsymbol{v}} \\boldsymbol{x}\\in \\mathbb{C}^n\\) 을 하우스홀더 변환 이라 한다. \\(\\boldsymbol{v}\\) 가 단위벡터일 경우, 즉 \\(\\|\\boldsymbol{v}\\|=1\\) 라면 좀 더 간단하게 쓸 수 있다.\n\\[\n\\boldsymbol{H}_{\\boldsymbol{v}} = I_n- 2\\boldsymbol{v}\\boldsymbol{v}^{\\ast},\\qquad \\text{where } \\|\\boldsymbol{v}\\|=1.\n\\]\n\n\n\n명제 1 위와 같이 정의된 하우스홀더 행렬 \\(\\boldsymbol{H}_{\\boldsymbol{v}}\\) 은 다음의 특징을 가진다.\n  (\\(1\\)) 에르미트 행렬이다. 즉 \\(\\boldsymbol{H}_{\\boldsymbol{v}}=  \\boldsymbol{H}_{\\boldsymbol{v}}^\\ast\\).\n  (\\(2\\)) 유니타리 행렬이다. 즉 \\(\\boldsymbol{H}_{\\boldsymbol{v}} (\\boldsymbol{H}_{\\boldsymbol{v}})^\\ast = I\\).\n\n\n\n\n(증명). (\\(1\\)) \\(\\boldsymbol{v}\\) 가 단위벡터일 경우에만 보여도 된다. \\(\\boldsymbol{H} = \\boldsymbol{H}_{\\boldsymbol{v}}\\) 라 하면,\n\\[\n(\\boldsymbol{H}^\\ast)_{ij} = \\overline{H_{ji}}= \\delta_{ij}-2 \\overline{v_j \\overline{v_i}} = \\delta_{ij}-2 v_i \\overline{v_j} = (\\boldsymbol{H})_{ij}\n\\]\n이므로 \\(\\boldsymbol{H}_{\\boldsymbol{v}}\\) 는 에르미트 행렬이다.\n(\\(2\\)) 또한,\n\\[\n\\begin{aligned}\n\\left(\\boldsymbol{H} (\\boldsymbol{H}^\\ast)\\right)_{ij} &= \\left((\\boldsymbol{H})^2\\right)_{ij} = \\sum_{k}(\\delta_{ik}-2 v_i \\overline{v_k})(\\delta_{kj} -2 v_k \\overline{v_j}) \\\\\n&= \\sum_k \\delta_{ik}\\delta_{kj} - 2\\sum_k \\delta_{ik}v_k \\overline{v_j} - 2 \\sum_k \\delta_{kj} v_i \\overline{v_k} + 4 \\sum_{k} v_i \\overline{v_j} v_k \\overline{v_k} \\\\\n&= \\delta_{ij} - 2 v_i \\overline{v_{j}} - 2 v_i \\overline{v_j} + 4 v_i \\overline{v_j} = \\delta_{ij}\n\\end{aligned}\n\\]\n이다. \\(\\square\\)\n\n\n따라서 \\(\\mathbb{R}^n\\) 에서 생각 할 경우 하우스홀더 행렬은 대칭행렬이며, 직교행렬(orthogonal matrix) 이다.\n\n\n\n하우스 홀더 변환이 리플렉션(reflection, 반사) 라고 불린다. 수학적으로 \\(\\mathbb{R}^n\\) 공간에서 벡터 \\(\\boldsymbol{v}\\) 만으로 \\(\\boldsymbol{v}\\) 와 수직이며 원점을 지나는 평면이 유일하게 정의될 수 있다. 임의의 벡터 \\(\\boldsymbol{x} \\in \\mathbb{F}^n\\) 에 대해,\n\\[\n\\begin{aligned}\n(\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x})_k &=  x_k - \\dfrac{2}{\\|\\boldsymbol{v}\\|^2}  \\sum_{j=1}^n v_k \\overline{v_j} x_j\\\\\n\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x} &= \\boldsymbol{x} - 2 \\dfrac{\\langle \\boldsymbol{x},\\,  \\boldsymbol{v} \\rangle \\boldsymbol{v}}{\\|\\boldsymbol{v}\\|^2}\n\\end{aligned}\n\\]\n이며,\n\\[\n\\begin{aligned}\n\\dfrac{1}{2 }(\\boldsymbol{x}+\\boldsymbol{Hx}) &= \\boldsymbol{x} - \\langle \\boldsymbol{v,\\,  x}\\rangle \\boldsymbol{v} = \\boldsymbol{x} - \\text{Proj}_{\\boldsymbol{v}} \\boldsymbol{x} \\\\\n\\boldsymbol{x}-\\boldsymbol{Hx} &= 2\\langle \\boldsymbol{v ,\\, x} \\rangle  \\boldsymbol{v} = 2\\, \\text{Proj}_{\\boldsymbol{v}}\\boldsymbol{x}\n\\end{aligned}\n\\]\n이다. 즉 \\(\\boldsymbol{x}\\) 와 \\(\\boldsymbol{Hx}\\) 는 \\(\\boldsymbol{v}\\) 에 의해 정의되는 평면에 대해 대칭이다.\n\n\n\nHouseholder 반사\n\n\n\\(\\boldsymbol{x}\\) 를 \\(\\boldsymbol{v}\\) 와 평행한 부분과 수직한 부분으로 분리하자. 즉 \\(\\boldsymbol{x}_{\\|} = \\text{Proj}_{\\boldsymbol{v}}\\boldsymbol{x}\\), \\(\\boldsymbol{x}_{\\perp} = \\boldsymbol{x}-\\text{Proj}_{\\boldsymbol{v}}\\boldsymbol{x}\\) 라 하면, \\(\\boldsymbol{x} = \\boldsymbol{x}_{\\|} + \\boldsymbol{x}_{\\perp}\\) 이며 \\(\\boldsymbol{x}\\cdot \\boldsymbol{v} = \\boldsymbol{x}_{\\|}\\cdot \\boldsymbol{v}\\) 이다.\n\\[\n\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x} = \\boldsymbol{x} - 2 \\boldsymbol{x}_{\\|} = \\boldsymbol{x}_{\\perp} - \\boldsymbol{x}_{\\|}\n\\]\n이다.\n\n\n\n\n\n명제 2 \\(\\mathbb{F}^m\\) 에서의 벡터 \\(\\boldsymbol{x}\\) 과 표준 기저 \\(\\{\\boldsymbol{e}_1,\\ldots,\\,\\boldsymbol{e}_m\\}\\) 를 생각하자. \\(\\alpha\\) 를 \\(\\boldsymbol{x}\\) 의 첫번째 성분 \\(x_1 = re^{i\\theta}\\) 에 대해 다음과 같이 정의한다.\n\\[\n\\alpha = \\left\\{ \\begin{array}{ll} \\|\\boldsymbol{x}\\|_2  & \\text{where } \\mathbb{F}=\\mathbb{R}, \\\\ e^{i\\theta}\\|\\boldsymbol{x}\\|_2 \\qquad & \\text{where } \\mathbb{F} =\\mathbb{C}. \\end{array} \\right.\n\\]\n\\(\\boldsymbol{x}\\) 에 대해 \\(\\boldsymbol{v}\\) 를 다음과 같이 정하자.\n\\[\n\\boldsymbol{v} = \\boldsymbol{x} - \\alpha \\boldsymbol{e}_1, \\\\\n\\]\n이 때 \\(\\boldsymbol{x}\\) 의 \\(\\boldsymbol{v}\\) 에 대한 하우스홀더 변환 \\(\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x}\\) 는 다음과 같다.\n\\[\n\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x} = \\boldsymbol{x}-\\boldsymbol{v} = \\alpha \\boldsymbol{e}_1.\n\\]\n\n\n(증명). \\(\\alpha \\overline{x}_1 = \\overline{\\alpha}x_1 = |x_1| \\|\\boldsymbol{x}\\|_2\\) 이며 \\(|\\alpha|^2 = \\|\\boldsymbol{x}\\|_2^2\\) 이다. \\(a=\\alpha\\overline{x}_1=\\overline{\\alpha}x_1\\) 이라 놓고 다음을 계산해 보자. \\[\n\\begin{aligned}\n\\langle \\boldsymbol{x},\\,\\boldsymbol{v}\\rangle & = \\langle \\, \\boldsymbol{x} , \\boldsymbol{x}-\\alpha \\boldsymbol{e}_1\\rangle = \\|\\boldsymbol{x}\\|_2^2-\\overline{\\alpha} x_1  = \\|\\boldsymbol{x}\\|_2^2 - a\\\\\n\\langle \\boldsymbol{v},\\,\\boldsymbol{v}\\rangle &= \\langle \\boldsymbol{x} -\\alpha \\boldsymbol{e}_1,\\, \\boldsymbol{x} -\\alpha\\boldsymbol{e}_1 \\rangle  = \\|\\boldsymbol{x}\\|^2 - \\overline{\\alpha} x_1 -\\alpha \\overline{x_1} + |\\alpha|^2 = 2(\\|\\boldsymbol{x}\\|_2^2 -a) \\\\\n&= 2 \\langle \\boldsymbol{x},\\, \\boldsymbol{v} \\rangle\n\\end{aligned}\n\\]\n이므로, (잠시 \\(\\|\\boldsymbol{x}\\|_2\\) 를 \\(\\|\\boldsymbol{x}\\|\\) 라 하자.)\n\\[\n\\boldsymbol{H}_\\boldsymbol{v} \\boldsymbol{x} = \\boldsymbol{x} - 2\\dfrac{\\langle \\boldsymbol{x},\\, \\boldsymbol{v}\\rangle}{\\|\\boldsymbol{v}\\|^2} \\boldsymbol{v} = \\boldsymbol{x}-\\boldsymbol{v} = \\alpha \\boldsymbol{e}_1\n\\]\n이다. \\(\\square\\)\n\n\n이미 설명한 그람 슈미트 방법과 유사하게\n이제 \\(\\boldsymbol{Q}_1= \\boldsymbol{Q},\\, \\boldsymbol{A}=\\boldsymbol{A}_1\\) 이라 놓으면,\n\\[\n\\boldsymbol{Q}_1\\boldsymbol{A}_1 = \\begin{bmatrix}\\alpha _{1} & \\ast &\\cdots &\\ast \\\\0 & & &\\\\ \\vdots & & \\boldsymbol{A}_2 & \\\\ 0 & & & \\end{bmatrix}\n\\]\n꼴이 된다. 이제 행렬 \\(m \\times n\\) 행렬 \\(\\boldsymbol{A}_k\\) 가 \\(k\\) 번째 행까지는 상삼각 행렬의 모양을 따른다고 하자. 즉 \\(j\\le k\\) 이고 \\(i&gt;k\\) 이면 \\((\\boldsymbol{A}_k)_{ij}=0\\) 이라 하자. 이 때 \\(\\boldsymbol{A}_k\\) 의 \\(k\\) 번째 행부터 \\(m\\) 행, \\(k\\) 번째 열부터 \\(m\\) 열까지를 \\(\\boldsymbol{A}'_k\\) 라 하고,(julia 로 표현하면 Ak[k:end, k:end] 가 될 것이다) 이 \\(\\boldsymbol{A}'_k\\) 에 대해 앞서 \\(\\boldsymbol{A}\\) 에 했던 것과 똑같은 과정을 수행하는 하우스홀더 행렬을 \\(\\boldsymbol{Q}'_k\\) 라 하면 \\(\\boldsymbol{Q}'_k \\boldsymbol{A}'_k\\) 는 \\(\\boldsymbol{Q}_1\\boldsymbol{A}_1\\) 처럼 첫번째 열에서는 첫번째 행을 제외한 나며지 행의 값이 \\(0\\) 이 된다. 만약\n\\[\n\\boldsymbol{Q}_k = \\begin{bmatrix} \\boldsymbol{I}_{k-1} & 0 \\\\ 0 & \\boldsymbol{Q}_k'\\end{bmatrix}\n\\]\n이라 하면, \\((k-1)\\times (k-1)\\) 단위행렬 \\(I_{k-1}\\) 과 \\(\\boldsymbol{A}_k\\) 를 \\(k\\) 행 과 \\(k\\) 열 부터 잘라 \\(\\boldsymbol{A}_{k} = \\begin{bmatrix} B_{k} & C_{k} \\\\ 0 &\\boldsymbol{A}'_{k}\\end{bmatrix}\\) 로 만들자. \\(B_k\\) 는 \\((k-1) \\times (k-1)\\) 행렬이며 \\(\\boldsymbol{A}'_{k}\\) 는 \\((m-k+1)\\times (n-k+1)\\) 행렬이다. \\(\\boldsymbol{A}_k\\) 가 \\(k\\) 열까지 상삼각 행렬 모양이므로 \\(B_k\\) 아래는 \\(0\\) 행렬이다. 두 행렬의 곱은 \\[\n\\boldsymbol{Q}_k \\boldsymbol{A}_k = \\begin{bmatrix} \\boldsymbol{I}_{k-1} & 0 \\\\ 0 & \\boldsymbol{Q}_k' \\end{bmatrix} \\begin{bmatrix} B_{k} & C_{k} \\\\ 0 &\\boldsymbol{A}'_{k}\\end{bmatrix} = \\begin{bmatrix} B_k & C_k \\\\ 0 & \\boldsymbol{Q}'_k \\boldsymbol{A'}_k \\end{bmatrix}\n\\]\n이 되고 \\(\\boldsymbol{Q}'_k \\boldsymbol{A}'_k\\) 의 첫번째 열은 첫번째 행을 제외하면 모두 \\(0\\) 이므로 \\(\\boldsymbol{Q}_k \\boldsymbol{A}_k\\) 는 \\(k\\) 열까지 상삼각 행렬 꼴이 된다.\n\\(L = \\min\\{m,\\,n\\}\\) 이라 하면 \\(\\boldsymbol{Q}_L \\boldsymbol{Q}_{L-1} \\cdots \\boldsymbol{Q}_1 \\boldsymbol{A}\\) 는 상삼각행렬꼴이 된다. 이를 \\(\\boldsymbol{R}\\) 이라 하자. \\(\\boldsymbol{Q}'_k\\) 가 하우스홀더 행렬이므로\n\\[\n\\boldsymbol{Q}_k \\boldsymbol{Q}_k^\\ast = \\begin{bmatrix} \\boldsymbol{I}_{k-1} & 0 \\\\ 0 & \\boldsymbol{Q}_k'\\end{bmatrix} \\begin{bmatrix} \\boldsymbol{I}_{k-1} & 0 \\\\ 0 & (\\boldsymbol{Q}_k')^\\ast\\end{bmatrix} = \\begin{bmatrix} I_{k-1} & 0 \\\\0 & \\boldsymbol{Q}_k'\n(\\boldsymbol{Q}_k')^\\ast\\end{bmatrix} = I\n\\]\n이다. 즉 \\(\\boldsymbol{Q}_k\\) 도 직교행렬이다. \\(\\boldsymbol{Q}_k\\) 가 에르미트 행렬임은 쉽게 보일 수 있다. 이제,\n\\[\n\\boldsymbol{Q}_L \\cdots \\boldsymbol{Q}_1 \\boldsymbol{A} = \\boldsymbol{R} \\implies \\boldsymbol{A} = \\boldsymbol{Q}_1^\\ast \\cdots \\boldsymbol{Q}_L^\\ast \\boldsymbol{R}\n\\]\n임은 쉽게 보일 수 있다. 직교행렬의 곱은 직교행렬이므로 \\(\\boldsymbol{Q}_1^\\ast \\cdots \\boldsymbol{Q}_L^\\ast\\) 도 직교행렬이다. 따라서 QR 분해를 할 수 있다.\n\n\n\n\n\n\\(W\\) 가 내적벡터공간 \\(V\\) 의 부분공간이라 하자. 이 때 그람슈미트 과정을 통해 \\(W\\) 의 정규기저벡터 \\(\\{\\hat{\\boldsymbol{u}}_1,\\ldots,\\,\\hat{\\boldsymbol{u}}_m\\}\\) 을 구할 수 있다. 이 때 \\(\\boldsymbol{v} \\in V\\) 의 \\(W\\) 에 대한 정사영 \\(\\text{Proj}_W \\boldsymbol{v}\\) 는 다음과 같이 정의된다.\n\\[\n\\text{Proj}_W \\boldsymbol{v} = \\sum_{i=1}^m \\langle \\boldsymbol{v},\\,\\hat{\\boldsymbol{u}}_i \\rangle\\,\\hat{\\boldsymbol{u}}_i\n\\]\n\\(\\text{Proj}_W \\boldsymbol{v}\\) 는 \\(W\\) 에 속한 벡터이며, 벡터에 대한 정사영과 마찬가지로 임의의 \\(\\boldsymbol{w} \\in W\\) 에 대해\n\\[\n\\langle \\boldsymbol{w},\\,  \\boldsymbol{v}-\\text{Proj}_W \\boldsymbol{v}\\rangle = \\boldsymbol{0}\n\\]\n이다. \\(\\boldsymbol{v} = \\text{Proj}_W \\boldsymbol{v} + (\\boldsymbol{v} - \\text{Proj}_W\\boldsymbol{v} )\\) 이므로 벡터 \\(\\boldsymbol{v}\\) 를 \\(W\\) 에 속하는 벡터와, \\(W\\) 에 직교하는 벡터로 분해 할 수 있다.\n\n내적벡터공간 \\(V\\) 의 두 벡터 \\(\\boldsymbol{v}_1,\\,\\boldsymbol{v}_2\\) 의 거리는 \\(\\|\\boldsymbol{v}_1-\\boldsymbol{v}_2\\| = \\sqrt{\\langle \\boldsymbol{v}_1-\\boldsymbol{v}_2,\\,\\boldsymbol{v}_1-\\boldsymbol{v}_2 \\rangle}\\) 로 정의된다. \\(V\\) 와 그 부분공간 \\(W\\) 를 생각하자. \\(V\\) 의 벡터 \\(\\boldsymbol{v}\\) 와 \\(W\\) 사이의 거리 \\(d(\\boldsymbol{v},\\,W)\\) 는 \\(W\\) 에 속한 벡터 가운데 \\(\\boldsymbol{v}\\) 와의 거리가 가장 작은 벡터 \\(\\boldsymbol{v}_0\\) 와의 거리로 정의된다. 즉,\n\\[\nd(\\boldsymbol{v},\\,W) = \\min_{\\boldsymbol{w}\\in W} \\| \\boldsymbol{v} - \\boldsymbol{w}\\|\n\\]\n이다. 여기서 \\(d(\\boldsymbol{v},\\,W) = d(\\boldsymbol{v},\\, \\text{Proj}_W \\boldsymbol{v})\\) 임을 보이고자 한다. \\(W\\) 의 정규기저벡터 \\(\\{\\hat{\\boldsymbol{u}}_1,\\ldots,\\,\\hat{\\boldsymbol{u}}_n\\}\\) 을 생각하자. 그리고 \\(V\\) 의 정규기저 벡터는 앞의 \\(W\\) 의 정규기저벡터를 확장하여 \\(\\{\\hat{\\boldsymbol{u}}_1,\\ldots,\\,\\hat{\\boldsymbol{u}}_n,\\,\\hat{\\boldsymbol{f}}_1,\\ldots,\\,\\hat{\\boldsymbol{f}}_m\\}\\) 라 하자. 그렇다면 \\(\\langle \\hat{\\boldsymbol{u}}_i,\\, \\hat{\\boldsymbol{f}}_j \\rangle = 0\\), \\(\\langle \\hat{\\boldsymbol{f}}_i ,\\,\\hat{\\boldsymbol{f}}_j \\rangle = \\delta_{ij}\\) 이다. 이제 이 정규기저벡터로 \\(\\boldsymbol{v}\\in V\\) 를 표현하면,\n\\[\n\\boldsymbol{v} = a_1 \\hat{\\boldsymbol{u}}_1 + \\cdots + a_n \\hat{\\boldsymbol{u}}_n + b_1 \\hat{\\boldsymbol{f}}_1 + \\cdots + b_m \\hat{\\boldsymbol{f}}_m\n\\]\n이다. 임의의 \\(\\boldsymbol{w} = c_1 \\hat{\\boldsymbol{u}}_1 + \\cdots + c_n \\hat{\\boldsymbol{u}}_n \\in W\\) 와 \\(\\boldsymbol{v}\\) 와의 거리의 제곱은\n\\[\n\\begin{aligned}\n\\left(d(\\boldsymbol{v},\\,\\boldsymbol{w}) \\right)^2&= (a_1-c_1)^2 + \\cdots + (a_n - c_n)^2 + b_1^2 + \\cdots + b_m^2 \\ge b_1^2 + \\cdots +b_m ^2\n\\end{aligned}\n\\]\n이므로 \\(a_1=c_1, \\cdots , a_n = c_n\\) 일 때 \\(d(\\boldsymbol{v},\\,W)\\) 가 최소값이 됨을 알 수 있다. 즉,\n\\[\nd(\\boldsymbol{v},\\,W) = \\|\\boldsymbol{v}-\\text{Proj}_W \\boldsymbol{v}\\|\n\\]\n이다.\n선형 시스템에서 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 를 만족시키는 해가 없지만 \\(\\|\\boldsymbol{Ax}-\\boldsymbol{b}\\|\\) 를 최소화 하는 \\(\\boldsymbol{x}\\) 를 구하고자 할 경우를 생각하자. \\(\\boldsymbol{A}\\) 가 \\(m\\times n\\) 행렬이고 \\(\\boldsymbol{x}\\in \\mathbb{F}^n,\\,\\boldsymbol{b}\\in \\mathbb{F}^m\\) 이라 하자. \\(\\boldsymbol{A}\\) 의 \\(i\\) 번째 행을 \\(\\boldsymbol{a}_i\\) 라 하면 \\(\\boldsymbol{a}_i \\in \\mathbb{F}^m\\) 이며,\n\\[\n\\boldsymbol{A} = \\begin{bmatrix} \\boldsymbol{a}_1 & \\boldsymbol{a}_2 & \\cdots & \\boldsymbol{a}_n\\end{bmatrix}\n\\]\n이다. \\(\\boldsymbol{x} = \\begin{bmatrix}x_1 & x_2 & \\ldots & x_n\\end{bmatrix}^T\\) 이라 하면, \\(\\boldsymbol{Ax}= x_1 \\boldsymbol{a}_1 + \\cdots x_n \\boldsymbol{a}_n\\) 이다. 즉 \\(\\boldsymbol{Ax}\\) 는 \\(\\boldsymbol{a}_1,\\ldots,\\boldsymbol{a}_n\\) 에 의해 정해지는 \\(\\mathbb{F}^n\\) 의 부분공간의 한 벡터이며, \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 는 이 부분공간의 벡터 가운데 \\(\\boldsymbol{b}\\) 와 같도록 하는 계수 \\(x_1,\\ldots,\\,x_n\\) 을 찾는 것이라고 이해 할 수 있다.\n\n\\(m=n,\\, \\text{rank}(\\boldsymbol{A})=n\\) 이면 \\(\\boldsymbol{A}\\) 가 가역행렬이므로 \\(\\boldsymbol{x}\\) 의 정확한 해가 반드시 존재한다. QR 분해의 경우 \\(\\boldsymbol{R}\\) 은 대각성분이 양수인 \\(n \\times n\\) 상삼각행렬이 된다.\n\\(m&gt;n\\) 이라면 \\(\\text{rank}(\\boldsymbol{A}) \\le n&lt; m\\) 이므로 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 를 만족하는 해가 존재하지 않을 수 있다.\n\\(m&lt;n\\) 이라면\n\n– to be continued",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "최소자승 문제"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/10_least_square_problem.html#하우스홀더-행렬과-qr-분해",
    "href": "src/numerical_analysis_using_julia/10_least_square_problem.html#하우스홀더-행렬과-qr-분해",
    "title": "최소자승 문제",
    "section": "",
    "text": "\\(\\mathbb{C}^{n\\times 1}\\) 에서의 벡터 \\(\\boldsymbol{v}\\) 에 대해 다음과 같이 정의된 \\(\\boldsymbol{H}_v\\) 를 하우스홀더 행렬 (Householder matrix) 이라 한다.\n\\[\n\\begin{aligned}\n\\boldsymbol{H}_{\\boldsymbol{v}} := I_n- \\dfrac{2\\boldsymbol{v}\\boldsymbol{v}^{\\ast}}{\\|\\boldsymbol{v}\\|^2}, \\qquad \\text{i. e. }\\quad\n(\\boldsymbol{H}_{\\boldsymbol{v}})_{ij} := \\delta_{ij} - \\dfrac{2 v_i \\overline{v_j}}{\\|\\boldsymbol{v}\\|^2}.\n\\end{aligned}\n\\]\n여기서 \\(\\boldsymbol{v}\\boldsymbol{v}^{\\ast}\\) 는 벡터의 내적이 아니라 \\(n\\times 1\\) 행렬 \\(\\boldsymbol{v}\\) 와 \\(1 \\times n\\) 행렬 \\(\\boldsymbol{v}^{\\ast}\\) 가 곱해진 \\(n \\times n\\) 행렬을 의미한다. 벡터 \\(\\boldsymbol{x}\\in \\mathbb{C}^n\\) 에 대해 \\(\\boldsymbol{H}_{\\boldsymbol{v}} \\boldsymbol{x}\\in \\mathbb{C}^n\\) 을 하우스홀더 변환 이라 한다. \\(\\boldsymbol{v}\\) 가 단위벡터일 경우, 즉 \\(\\|\\boldsymbol{v}\\|=1\\) 라면 좀 더 간단하게 쓸 수 있다.\n\\[\n\\boldsymbol{H}_{\\boldsymbol{v}} = I_n- 2\\boldsymbol{v}\\boldsymbol{v}^{\\ast},\\qquad \\text{where } \\|\\boldsymbol{v}\\|=1.\n\\]\n\n\n\n명제 1 위와 같이 정의된 하우스홀더 행렬 \\(\\boldsymbol{H}_{\\boldsymbol{v}}\\) 은 다음의 특징을 가진다.\n  (\\(1\\)) 에르미트 행렬이다. 즉 \\(\\boldsymbol{H}_{\\boldsymbol{v}}=  \\boldsymbol{H}_{\\boldsymbol{v}}^\\ast\\).\n  (\\(2\\)) 유니타리 행렬이다. 즉 \\(\\boldsymbol{H}_{\\boldsymbol{v}} (\\boldsymbol{H}_{\\boldsymbol{v}})^\\ast = I\\).\n\n\n\n\n(증명). (\\(1\\)) \\(\\boldsymbol{v}\\) 가 단위벡터일 경우에만 보여도 된다. \\(\\boldsymbol{H} = \\boldsymbol{H}_{\\boldsymbol{v}}\\) 라 하면,\n\\[\n(\\boldsymbol{H}^\\ast)_{ij} = \\overline{H_{ji}}= \\delta_{ij}-2 \\overline{v_j \\overline{v_i}} = \\delta_{ij}-2 v_i \\overline{v_j} = (\\boldsymbol{H})_{ij}\n\\]\n이므로 \\(\\boldsymbol{H}_{\\boldsymbol{v}}\\) 는 에르미트 행렬이다.\n(\\(2\\)) 또한,\n\\[\n\\begin{aligned}\n\\left(\\boldsymbol{H} (\\boldsymbol{H}^\\ast)\\right)_{ij} &= \\left((\\boldsymbol{H})^2\\right)_{ij} = \\sum_{k}(\\delta_{ik}-2 v_i \\overline{v_k})(\\delta_{kj} -2 v_k \\overline{v_j}) \\\\\n&= \\sum_k \\delta_{ik}\\delta_{kj} - 2\\sum_k \\delta_{ik}v_k \\overline{v_j} - 2 \\sum_k \\delta_{kj} v_i \\overline{v_k} + 4 \\sum_{k} v_i \\overline{v_j} v_k \\overline{v_k} \\\\\n&= \\delta_{ij} - 2 v_i \\overline{v_{j}} - 2 v_i \\overline{v_j} + 4 v_i \\overline{v_j} = \\delta_{ij}\n\\end{aligned}\n\\]\n이다. \\(\\square\\)\n\n\n따라서 \\(\\mathbb{R}^n\\) 에서 생각 할 경우 하우스홀더 행렬은 대칭행렬이며, 직교행렬(orthogonal matrix) 이다.\n\n\n\n하우스 홀더 변환이 리플렉션(reflection, 반사) 라고 불린다. 수학적으로 \\(\\mathbb{R}^n\\) 공간에서 벡터 \\(\\boldsymbol{v}\\) 만으로 \\(\\boldsymbol{v}\\) 와 수직이며 원점을 지나는 평면이 유일하게 정의될 수 있다. 임의의 벡터 \\(\\boldsymbol{x} \\in \\mathbb{F}^n\\) 에 대해,\n\\[\n\\begin{aligned}\n(\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x})_k &=  x_k - \\dfrac{2}{\\|\\boldsymbol{v}\\|^2}  \\sum_{j=1}^n v_k \\overline{v_j} x_j\\\\\n\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x} &= \\boldsymbol{x} - 2 \\dfrac{\\langle \\boldsymbol{x},\\,  \\boldsymbol{v} \\rangle \\boldsymbol{v}}{\\|\\boldsymbol{v}\\|^2}\n\\end{aligned}\n\\]\n이며,\n\\[\n\\begin{aligned}\n\\dfrac{1}{2 }(\\boldsymbol{x}+\\boldsymbol{Hx}) &= \\boldsymbol{x} - \\langle \\boldsymbol{v,\\,  x}\\rangle \\boldsymbol{v} = \\boldsymbol{x} - \\text{Proj}_{\\boldsymbol{v}} \\boldsymbol{x} \\\\\n\\boldsymbol{x}-\\boldsymbol{Hx} &= 2\\langle \\boldsymbol{v ,\\, x} \\rangle  \\boldsymbol{v} = 2\\, \\text{Proj}_{\\boldsymbol{v}}\\boldsymbol{x}\n\\end{aligned}\n\\]\n이다. 즉 \\(\\boldsymbol{x}\\) 와 \\(\\boldsymbol{Hx}\\) 는 \\(\\boldsymbol{v}\\) 에 의해 정의되는 평면에 대해 대칭이다.\n\n\n\nHouseholder 반사\n\n\n\\(\\boldsymbol{x}\\) 를 \\(\\boldsymbol{v}\\) 와 평행한 부분과 수직한 부분으로 분리하자. 즉 \\(\\boldsymbol{x}_{\\|} = \\text{Proj}_{\\boldsymbol{v}}\\boldsymbol{x}\\), \\(\\boldsymbol{x}_{\\perp} = \\boldsymbol{x}-\\text{Proj}_{\\boldsymbol{v}}\\boldsymbol{x}\\) 라 하면, \\(\\boldsymbol{x} = \\boldsymbol{x}_{\\|} + \\boldsymbol{x}_{\\perp}\\) 이며 \\(\\boldsymbol{x}\\cdot \\boldsymbol{v} = \\boldsymbol{x}_{\\|}\\cdot \\boldsymbol{v}\\) 이다.\n\\[\n\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x} = \\boldsymbol{x} - 2 \\boldsymbol{x}_{\\|} = \\boldsymbol{x}_{\\perp} - \\boldsymbol{x}_{\\|}\n\\]\n이다.\n\n\n\n\n\n명제 2 \\(\\mathbb{F}^m\\) 에서의 벡터 \\(\\boldsymbol{x}\\) 과 표준 기저 \\(\\{\\boldsymbol{e}_1,\\ldots,\\,\\boldsymbol{e}_m\\}\\) 를 생각하자. \\(\\alpha\\) 를 \\(\\boldsymbol{x}\\) 의 첫번째 성분 \\(x_1 = re^{i\\theta}\\) 에 대해 다음과 같이 정의한다.\n\\[\n\\alpha = \\left\\{ \\begin{array}{ll} \\|\\boldsymbol{x}\\|_2  & \\text{where } \\mathbb{F}=\\mathbb{R}, \\\\ e^{i\\theta}\\|\\boldsymbol{x}\\|_2 \\qquad & \\text{where } \\mathbb{F} =\\mathbb{C}. \\end{array} \\right.\n\\]\n\\(\\boldsymbol{x}\\) 에 대해 \\(\\boldsymbol{v}\\) 를 다음과 같이 정하자.\n\\[\n\\boldsymbol{v} = \\boldsymbol{x} - \\alpha \\boldsymbol{e}_1, \\\\\n\\]\n이 때 \\(\\boldsymbol{x}\\) 의 \\(\\boldsymbol{v}\\) 에 대한 하우스홀더 변환 \\(\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x}\\) 는 다음과 같다.\n\\[\n\\boldsymbol{H}_{\\boldsymbol{v}}\\boldsymbol{x} = \\boldsymbol{x}-\\boldsymbol{v} = \\alpha \\boldsymbol{e}_1.\n\\]\n\n\n(증명). \\(\\alpha \\overline{x}_1 = \\overline{\\alpha}x_1 = |x_1| \\|\\boldsymbol{x}\\|_2\\) 이며 \\(|\\alpha|^2 = \\|\\boldsymbol{x}\\|_2^2\\) 이다. \\(a=\\alpha\\overline{x}_1=\\overline{\\alpha}x_1\\) 이라 놓고 다음을 계산해 보자. \\[\n\\begin{aligned}\n\\langle \\boldsymbol{x},\\,\\boldsymbol{v}\\rangle & = \\langle \\, \\boldsymbol{x} , \\boldsymbol{x}-\\alpha \\boldsymbol{e}_1\\rangle = \\|\\boldsymbol{x}\\|_2^2-\\overline{\\alpha} x_1  = \\|\\boldsymbol{x}\\|_2^2 - a\\\\\n\\langle \\boldsymbol{v},\\,\\boldsymbol{v}\\rangle &= \\langle \\boldsymbol{x} -\\alpha \\boldsymbol{e}_1,\\, \\boldsymbol{x} -\\alpha\\boldsymbol{e}_1 \\rangle  = \\|\\boldsymbol{x}\\|^2 - \\overline{\\alpha} x_1 -\\alpha \\overline{x_1} + |\\alpha|^2 = 2(\\|\\boldsymbol{x}\\|_2^2 -a) \\\\\n&= 2 \\langle \\boldsymbol{x},\\, \\boldsymbol{v} \\rangle\n\\end{aligned}\n\\]\n이므로, (잠시 \\(\\|\\boldsymbol{x}\\|_2\\) 를 \\(\\|\\boldsymbol{x}\\|\\) 라 하자.)\n\\[\n\\boldsymbol{H}_\\boldsymbol{v} \\boldsymbol{x} = \\boldsymbol{x} - 2\\dfrac{\\langle \\boldsymbol{x},\\, \\boldsymbol{v}\\rangle}{\\|\\boldsymbol{v}\\|^2} \\boldsymbol{v} = \\boldsymbol{x}-\\boldsymbol{v} = \\alpha \\boldsymbol{e}_1\n\\]\n이다. \\(\\square\\)\n\n\n이미 설명한 그람 슈미트 방법과 유사하게\n이제 \\(\\boldsymbol{Q}_1= \\boldsymbol{Q},\\, \\boldsymbol{A}=\\boldsymbol{A}_1\\) 이라 놓으면,\n\\[\n\\boldsymbol{Q}_1\\boldsymbol{A}_1 = \\begin{bmatrix}\\alpha _{1} & \\ast &\\cdots &\\ast \\\\0 & & &\\\\ \\vdots & & \\boldsymbol{A}_2 & \\\\ 0 & & & \\end{bmatrix}\n\\]\n꼴이 된다. 이제 행렬 \\(m \\times n\\) 행렬 \\(\\boldsymbol{A}_k\\) 가 \\(k\\) 번째 행까지는 상삼각 행렬의 모양을 따른다고 하자. 즉 \\(j\\le k\\) 이고 \\(i&gt;k\\) 이면 \\((\\boldsymbol{A}_k)_{ij}=0\\) 이라 하자. 이 때 \\(\\boldsymbol{A}_k\\) 의 \\(k\\) 번째 행부터 \\(m\\) 행, \\(k\\) 번째 열부터 \\(m\\) 열까지를 \\(\\boldsymbol{A}'_k\\) 라 하고,(julia 로 표현하면 Ak[k:end, k:end] 가 될 것이다) 이 \\(\\boldsymbol{A}'_k\\) 에 대해 앞서 \\(\\boldsymbol{A}\\) 에 했던 것과 똑같은 과정을 수행하는 하우스홀더 행렬을 \\(\\boldsymbol{Q}'_k\\) 라 하면 \\(\\boldsymbol{Q}'_k \\boldsymbol{A}'_k\\) 는 \\(\\boldsymbol{Q}_1\\boldsymbol{A}_1\\) 처럼 첫번째 열에서는 첫번째 행을 제외한 나며지 행의 값이 \\(0\\) 이 된다. 만약\n\\[\n\\boldsymbol{Q}_k = \\begin{bmatrix} \\boldsymbol{I}_{k-1} & 0 \\\\ 0 & \\boldsymbol{Q}_k'\\end{bmatrix}\n\\]\n이라 하면, \\((k-1)\\times (k-1)\\) 단위행렬 \\(I_{k-1}\\) 과 \\(\\boldsymbol{A}_k\\) 를 \\(k\\) 행 과 \\(k\\) 열 부터 잘라 \\(\\boldsymbol{A}_{k} = \\begin{bmatrix} B_{k} & C_{k} \\\\ 0 &\\boldsymbol{A}'_{k}\\end{bmatrix}\\) 로 만들자. \\(B_k\\) 는 \\((k-1) \\times (k-1)\\) 행렬이며 \\(\\boldsymbol{A}'_{k}\\) 는 \\((m-k+1)\\times (n-k+1)\\) 행렬이다. \\(\\boldsymbol{A}_k\\) 가 \\(k\\) 열까지 상삼각 행렬 모양이므로 \\(B_k\\) 아래는 \\(0\\) 행렬이다. 두 행렬의 곱은 \\[\n\\boldsymbol{Q}_k \\boldsymbol{A}_k = \\begin{bmatrix} \\boldsymbol{I}_{k-1} & 0 \\\\ 0 & \\boldsymbol{Q}_k' \\end{bmatrix} \\begin{bmatrix} B_{k} & C_{k} \\\\ 0 &\\boldsymbol{A}'_{k}\\end{bmatrix} = \\begin{bmatrix} B_k & C_k \\\\ 0 & \\boldsymbol{Q}'_k \\boldsymbol{A'}_k \\end{bmatrix}\n\\]\n이 되고 \\(\\boldsymbol{Q}'_k \\boldsymbol{A}'_k\\) 의 첫번째 열은 첫번째 행을 제외하면 모두 \\(0\\) 이므로 \\(\\boldsymbol{Q}_k \\boldsymbol{A}_k\\) 는 \\(k\\) 열까지 상삼각 행렬 꼴이 된다.\n\\(L = \\min\\{m,\\,n\\}\\) 이라 하면 \\(\\boldsymbol{Q}_L \\boldsymbol{Q}_{L-1} \\cdots \\boldsymbol{Q}_1 \\boldsymbol{A}\\) 는 상삼각행렬꼴이 된다. 이를 \\(\\boldsymbol{R}\\) 이라 하자. \\(\\boldsymbol{Q}'_k\\) 가 하우스홀더 행렬이므로\n\\[\n\\boldsymbol{Q}_k \\boldsymbol{Q}_k^\\ast = \\begin{bmatrix} \\boldsymbol{I}_{k-1} & 0 \\\\ 0 & \\boldsymbol{Q}_k'\\end{bmatrix} \\begin{bmatrix} \\boldsymbol{I}_{k-1} & 0 \\\\ 0 & (\\boldsymbol{Q}_k')^\\ast\\end{bmatrix} = \\begin{bmatrix} I_{k-1} & 0 \\\\0 & \\boldsymbol{Q}_k'\n(\\boldsymbol{Q}_k')^\\ast\\end{bmatrix} = I\n\\]\n이다. 즉 \\(\\boldsymbol{Q}_k\\) 도 직교행렬이다. \\(\\boldsymbol{Q}_k\\) 가 에르미트 행렬임은 쉽게 보일 수 있다. 이제,\n\\[\n\\boldsymbol{Q}_L \\cdots \\boldsymbol{Q}_1 \\boldsymbol{A} = \\boldsymbol{R} \\implies \\boldsymbol{A} = \\boldsymbol{Q}_1^\\ast \\cdots \\boldsymbol{Q}_L^\\ast \\boldsymbol{R}\n\\]\n임은 쉽게 보일 수 있다. 직교행렬의 곱은 직교행렬이므로 \\(\\boldsymbol{Q}_1^\\ast \\cdots \\boldsymbol{Q}_L^\\ast\\) 도 직교행렬이다. 따라서 QR 분해를 할 수 있다.\n\n\n\n\n\n\\(W\\) 가 내적벡터공간 \\(V\\) 의 부분공간이라 하자. 이 때 그람슈미트 과정을 통해 \\(W\\) 의 정규기저벡터 \\(\\{\\hat{\\boldsymbol{u}}_1,\\ldots,\\,\\hat{\\boldsymbol{u}}_m\\}\\) 을 구할 수 있다. 이 때 \\(\\boldsymbol{v} \\in V\\) 의 \\(W\\) 에 대한 정사영 \\(\\text{Proj}_W \\boldsymbol{v}\\) 는 다음과 같이 정의된다.\n\\[\n\\text{Proj}_W \\boldsymbol{v} = \\sum_{i=1}^m \\langle \\boldsymbol{v},\\,\\hat{\\boldsymbol{u}}_i \\rangle\\,\\hat{\\boldsymbol{u}}_i\n\\]\n\\(\\text{Proj}_W \\boldsymbol{v}\\) 는 \\(W\\) 에 속한 벡터이며, 벡터에 대한 정사영과 마찬가지로 임의의 \\(\\boldsymbol{w} \\in W\\) 에 대해\n\\[\n\\langle \\boldsymbol{w},\\,  \\boldsymbol{v}-\\text{Proj}_W \\boldsymbol{v}\\rangle = \\boldsymbol{0}\n\\]\n이다. \\(\\boldsymbol{v} = \\text{Proj}_W \\boldsymbol{v} + (\\boldsymbol{v} - \\text{Proj}_W\\boldsymbol{v} )\\) 이므로 벡터 \\(\\boldsymbol{v}\\) 를 \\(W\\) 에 속하는 벡터와, \\(W\\) 에 직교하는 벡터로 분해 할 수 있다.\n\n내적벡터공간 \\(V\\) 의 두 벡터 \\(\\boldsymbol{v}_1,\\,\\boldsymbol{v}_2\\) 의 거리는 \\(\\|\\boldsymbol{v}_1-\\boldsymbol{v}_2\\| = \\sqrt{\\langle \\boldsymbol{v}_1-\\boldsymbol{v}_2,\\,\\boldsymbol{v}_1-\\boldsymbol{v}_2 \\rangle}\\) 로 정의된다. \\(V\\) 와 그 부분공간 \\(W\\) 를 생각하자. \\(V\\) 의 벡터 \\(\\boldsymbol{v}\\) 와 \\(W\\) 사이의 거리 \\(d(\\boldsymbol{v},\\,W)\\) 는 \\(W\\) 에 속한 벡터 가운데 \\(\\boldsymbol{v}\\) 와의 거리가 가장 작은 벡터 \\(\\boldsymbol{v}_0\\) 와의 거리로 정의된다. 즉,\n\\[\nd(\\boldsymbol{v},\\,W) = \\min_{\\boldsymbol{w}\\in W} \\| \\boldsymbol{v} - \\boldsymbol{w}\\|\n\\]\n이다. 여기서 \\(d(\\boldsymbol{v},\\,W) = d(\\boldsymbol{v},\\, \\text{Proj}_W \\boldsymbol{v})\\) 임을 보이고자 한다. \\(W\\) 의 정규기저벡터 \\(\\{\\hat{\\boldsymbol{u}}_1,\\ldots,\\,\\hat{\\boldsymbol{u}}_n\\}\\) 을 생각하자. 그리고 \\(V\\) 의 정규기저 벡터는 앞의 \\(W\\) 의 정규기저벡터를 확장하여 \\(\\{\\hat{\\boldsymbol{u}}_1,\\ldots,\\,\\hat{\\boldsymbol{u}}_n,\\,\\hat{\\boldsymbol{f}}_1,\\ldots,\\,\\hat{\\boldsymbol{f}}_m\\}\\) 라 하자. 그렇다면 \\(\\langle \\hat{\\boldsymbol{u}}_i,\\, \\hat{\\boldsymbol{f}}_j \\rangle = 0\\), \\(\\langle \\hat{\\boldsymbol{f}}_i ,\\,\\hat{\\boldsymbol{f}}_j \\rangle = \\delta_{ij}\\) 이다. 이제 이 정규기저벡터로 \\(\\boldsymbol{v}\\in V\\) 를 표현하면,\n\\[\n\\boldsymbol{v} = a_1 \\hat{\\boldsymbol{u}}_1 + \\cdots + a_n \\hat{\\boldsymbol{u}}_n + b_1 \\hat{\\boldsymbol{f}}_1 + \\cdots + b_m \\hat{\\boldsymbol{f}}_m\n\\]\n이다. 임의의 \\(\\boldsymbol{w} = c_1 \\hat{\\boldsymbol{u}}_1 + \\cdots + c_n \\hat{\\boldsymbol{u}}_n \\in W\\) 와 \\(\\boldsymbol{v}\\) 와의 거리의 제곱은\n\\[\n\\begin{aligned}\n\\left(d(\\boldsymbol{v},\\,\\boldsymbol{w}) \\right)^2&= (a_1-c_1)^2 + \\cdots + (a_n - c_n)^2 + b_1^2 + \\cdots + b_m^2 \\ge b_1^2 + \\cdots +b_m ^2\n\\end{aligned}\n\\]\n이므로 \\(a_1=c_1, \\cdots , a_n = c_n\\) 일 때 \\(d(\\boldsymbol{v},\\,W)\\) 가 최소값이 됨을 알 수 있다. 즉,\n\\[\nd(\\boldsymbol{v},\\,W) = \\|\\boldsymbol{v}-\\text{Proj}_W \\boldsymbol{v}\\|\n\\]\n이다.\n선형 시스템에서 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 를 만족시키는 해가 없지만 \\(\\|\\boldsymbol{Ax}-\\boldsymbol{b}\\|\\) 를 최소화 하는 \\(\\boldsymbol{x}\\) 를 구하고자 할 경우를 생각하자. \\(\\boldsymbol{A}\\) 가 \\(m\\times n\\) 행렬이고 \\(\\boldsymbol{x}\\in \\mathbb{F}^n,\\,\\boldsymbol{b}\\in \\mathbb{F}^m\\) 이라 하자. \\(\\boldsymbol{A}\\) 의 \\(i\\) 번째 행을 \\(\\boldsymbol{a}_i\\) 라 하면 \\(\\boldsymbol{a}_i \\in \\mathbb{F}^m\\) 이며,\n\\[\n\\boldsymbol{A} = \\begin{bmatrix} \\boldsymbol{a}_1 & \\boldsymbol{a}_2 & \\cdots & \\boldsymbol{a}_n\\end{bmatrix}\n\\]\n이다. \\(\\boldsymbol{x} = \\begin{bmatrix}x_1 & x_2 & \\ldots & x_n\\end{bmatrix}^T\\) 이라 하면, \\(\\boldsymbol{Ax}= x_1 \\boldsymbol{a}_1 + \\cdots x_n \\boldsymbol{a}_n\\) 이다. 즉 \\(\\boldsymbol{Ax}\\) 는 \\(\\boldsymbol{a}_1,\\ldots,\\boldsymbol{a}_n\\) 에 의해 정해지는 \\(\\mathbb{F}^n\\) 의 부분공간의 한 벡터이며, \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 는 이 부분공간의 벡터 가운데 \\(\\boldsymbol{b}\\) 와 같도록 하는 계수 \\(x_1,\\ldots,\\,x_n\\) 을 찾는 것이라고 이해 할 수 있다.\n\n\\(m=n,\\, \\text{rank}(\\boldsymbol{A})=n\\) 이면 \\(\\boldsymbol{A}\\) 가 가역행렬이므로 \\(\\boldsymbol{x}\\) 의 정확한 해가 반드시 존재한다. QR 분해의 경우 \\(\\boldsymbol{R}\\) 은 대각성분이 양수인 \\(n \\times n\\) 상삼각행렬이 된다.\n\\(m&gt;n\\) 이라면 \\(\\text{rank}(\\boldsymbol{A}) \\le n&lt; m\\) 이므로 \\(\\boldsymbol{Ax}=\\boldsymbol{b}\\) 를 만족하는 해가 존재하지 않을 수 있다.\n\\(m&lt;n\\) 이라면\n\n– to be continued",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "최소자승 문제"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/14_approximation.html",
    "href": "src/numerical_analysis_using_julia/14_approximation.html",
    "title": "Approximation",
    "section": "",
    "text": "아래 그림과 같이 \\(\\{(x_i,\\,y_i) : i = 1,\\ldots, N\\}\\) 가 주어졌을 때 이 데이터에 가장 근접하는 선형 방정식 \\(y=ax+b\\) 를 찾아야 할 때가 있다.\n\n\n\n\n\n\n그림 1: 선형 최소 자승법\n\n\n\n아래와 같은 함수 \\(E(a,\\,b)\\) 를 보자. \\[\nE(a, b) = \\sum_{i=1}^N \\left[ y_i - (ax_i + b)\\right]^2\n\\]\n이 함수는 모든 구간에서 미분가능하다는 매우 좋은 성질을 가지고 있다. 또한 \\(a,\\,b\\) 값이 상당히 벗어날 경우 매우 커지며, \\(y_i\\) 가 \\(ax_i +b\\) 와 일치할 경우 \\(0\\) 이 된다.\n\\[\n\\begin{aligned}\n\\dfrac{\\partial E}{\\partial a} &= -2\\sum_{i=1}^N x_i(y_i - ax_i - b), \\\\\n\\dfrac{\\partial E}{\\partial b} &= -2\\sum_{i=1}^N (y_i - ax_i -b), \\\\\n\\dfrac{\\partial^2 E}{\\partial a \\partial a }& = \\sum_{i=1}^N 2{x_i}^2, \\\\\n\\dfrac{\\partial^2 E}{\\partial a \\partial b} &= \\sum_{i=1}^N 2x_i, \\\\\n\\dfrac{\\partial^2 E}{\\partial b \\partial b}&= 2N\n\\end{aligned}\n\\]\n이며 이로부터 해세 행렬 (Hassian matrix)\n\\[\n\\boldsymbol{H} = \\begin{bmatrix} \\dfrac{\\partial^2 E}{\\partial a^2 } & \\dfrac{\\partial^2 E}{\\partial a \\partial b} \\\\ \\dfrac{\\partial^2 E}{\\partial a \\partial b} & \\dfrac{\\partial^2 E}{\\partial b^2} \\end{bmatrix} = \\begin{bmatrix} {\\displaystyle \\sum_{i=1}^N 2{x_i}^2} & {\\displaystyle \\sum_{i=1}^N 2x_i}, \\\\ {\\displaystyle \\sum_{i=1}^N 2x_i} & 2N \\end{bmatrix}\n\\]\n을 얻는다. 위 해세 행렬의 행렬식은\n\\[\nD = \\det (\\boldsymbol{H}) = 4 \\left[N\\left(\\sum_i^N {x_i}^2 \\right)- \\left(\\sum_i^N x_i\\right)^2\\right]\n\\]\n이며, 코시-슈바르츠 부등식으로 \\(D\\ge 0\\) 이며 \\(D=0\\) 일 때는 \\(x_1 = \\cdots = x_i\\) 일 때임을 보일 수 있다. 이것을 제외하면 \\(D&gt;0\\) 이며 \\(E(a,\\,b)\\) 는 극소값을 가진다는 것을 안다. 극소값을 가질 때는 \\(\\dfrac{\\partial E}{\\partial a}= \\dfrac{\\partial E}{\\partial b}=0\\) 일 때이므로,\n\\[\n\\begin{aligned}\n\\dfrac{\\partial E}{\\partial a}= 0 &\\implies \\sum_i x_i y_i - a \\left(\\sum_i {x_i}^2\\right) - b \\left(\\sum_{i}x_i\\right) = 0, \\\\\n\\dfrac{\\partial E}{\\partial b} = 0 &\\implies \\sum_i y_i - a\\left(\\sum_i x_i\\right) - b N = 0\n\\end{aligned}\n\\]\n이다. 위 식은 \\(a,\\,b\\) 에 대한 연립방정식이며 이것을 풀면 다음과 같다.\n\\[\na = \\dfrac{N \\left( \\displaystyle \\sum_{i=1}^N x_i y_i\\right) - \\left(\\displaystyle \\sum_{i=1}^N x_i\\right) \\left( \\displaystyle \\sum_{i=1}^N y_i\\right)}{N \\left(\\displaystyle \\sum_{i=1}^N {x_i}^2\\right) - \\left(\\displaystyle \\sum_{i=1}^N x_i\\right)^2}, \\qquad\nb=  \\dfrac{\\left( \\displaystyle \\sum_{i=1}^N {x_i}^2\\right)  \\left( \\displaystyle \\sum_{i=1}^N y_i\\right) - \\left(\\displaystyle \\sum_{i=1}^N x_iy_i\\right) \\left( \\displaystyle \\sum_{i=1}^N x_i\\right)}{N \\left(\\displaystyle \\sum_{i=1}^N {x_i}^2\\right) - \\left(\\displaystyle \\sum_{i=1}^N x_i\\right)^2},\n\\]\n언뜻 복잡해 보이지만 프로그래밍 입장에서 보면 베열의 합, 베열의 곱의 합, 베열의 제곱의 합, 배열의 합의 제곱에 대한 사칙연산 뿐이며, 쉽게 코딩 할 수 있다.\n\n\n\n\n\\(y=be^{ax}\\) 꼴의 지수함수의 경우 각각 \\(\\ln y = ax + \\ln b\\) 로 변형시킨 후 \\(\\overline{y}=\\ln y,\\, \\overline{b} = \\ln b\\) 로 놓으면\n\\[\n\\overline{y} = ax + \\overline{b}\n\\]\n의 선형방정식이 된다. 따라서 선형방정식의 최소자승법으로 \\(a\\) 와 \\(\\overline{b}\\) 를 구할 수 있기 때문에 지수함수에 대해서는 최소자승법을 사용 할 수 있다. \\(y=dx^c\\) 꼴의 멱함수의 경우에는 \\(\\ln y = \\ln d + c\\ln x\\) 이므로 \\(\\overline{y} = \\ln y\\), \\(\\overline{x} = \\ln x\\), \\(\\overline{d} = \\ln d\\) 로 놓으면\n\\[\n\\overline{y} = c \\overline{x} + \\overline{d}\n\\]\n를 이용해 역시 최소자승법으로 \\(c,\\, d\\) 를 구할 수 있다.\n\n\n\n\n데이터 \\(\\{(x_k,\\,y_k):k=1,\\,N\\}\\) (\\(x_1&lt;x_2&lt;\\cdots &lt; x_N\\)) 과 \\(n\\) 차 다항식\n\\[\np_n (x) = a_n x^n + a_{n-1}x^{n-1} + \\cdots + a_1 x + a_0\n\\]\n에 대해\n\\[\nE(a_n,\\ldots,\\,a_0) = \\sum_{k=1}^N \\left[ y_k - p_n(x_k)\\right]^2\n\\]\n를 최소로 하는 \\(a_0,\\ldots,\\,a_n\\) 을 찾는다. 이 경우 \\(N=n+1\\) 이면 다항식을 이용한 보간법이 되어 \\(E=0\\) 이 되도록 하는 \\(a_0,\\ldots,\\,a_n\\) 이 존재한다는 것을 안다. 보통 최소자승법은 \\(N&gt;n+1\\) 일 경우의 가장 좋은 다항식 \\(p_n\\) 을 찾는 것을 말한다. 여기서도 \\(n&lt;N-1\\) 임을 가정하겠다.\n\\[\n\\begin{aligned}\nE(a_n,\\ldots,\\,a_0) &= \\sum_{k=1}^N {y_k}^2 -2 \\sum_{k=1}^N y_k p_n(x_i) + \\sum_{k=1}^N (p_n(x_k))^2\\\\\n&= \\sum_{k=1}^N {y_k}^2 - 2 \\sum_{k=1}^N \\sum_{i=0}^n a_i y_k {x_k}^j + \\sum_{k=1}^N \\sum_{i,\\,j=1}^n a_i a_j {x_k}^{i+j} \\\\\n&= \\sum_{k=1}^N {y_k}^2 - 2\\sum_{i=0}^n \\left(\\sum_{k=1}^N (x_k)^i y_k\\right) a_i + \\sum_{i, j=0}^n \\left(\\sum_{k=1}^N {x_k}^{i+j}\\right) a_i a_j\n\\end{aligned}\n\\]\n이며 \\(E\\) 를 최소로 하는 극값은 \\(i=0,\\ldots,n\\) 에 대해\n\\[\n\\dfrac{\\partial E}{\\partial a_i}=0 \\implies \\sum_{k=1}^N \\left[ (x_k)^i y_k- \\sum_{j=0}^n  (x_k)^{i+j} a_j\\right] = 0\n\\tag{1}\\]\n를 만족해야 한다. 이제 행렬 \\(\\boldsymbol{X} \\in \\mathcal{M}_{N\\times (n+1)}(\\mathbb{F}),\\,\\boldsymbol{a} \\in\\mathcal{M}_{n+1}(\\mathbb{F}),\\,\\boldsymbol{y}\\in \\mathcal{M}_N(\\mathbb{F})\\) 를 다음과 같이 정의하자.\n\\[\nX_{ij} = (x_i)^{j-1},\\qquad \\boldsymbol{a} = \\begin{bmatrix} a_0 & \\cdots & a_n\\end{bmatrix}^T, \\qquad \\boldsymbol{y} = \\begin{bmatrix} y_1 & \\cdots & y_N \\end{bmatrix}\n\\]\n그렇다면,\n\\[\n(\\boldsymbol{X}^T\\boldsymbol{X})_{ij} = \\sum_{k=1}^N X_{ki}X_{kj} = \\sum_{k=1}^N x_{k}^{i+j-2}\n\\]\n이므로 식 1 는 다음과 같은 선형방정식이 된다. 아래와 같은 형태의 방정식을 정규 방정식(normal equation) 이라고 한다.\n\\[\n\\boldsymbol{X}^T\\boldsymbol{Xa} = \\boldsymbol{X}^T\\boldsymbol{y}\n\\tag{2}\\]\n\n\n연습문제 1 위에서 정의된 \\(\\boldsymbol{X}\\) 에 대해 다음을 보여라.\n  (\\(1\\)) \\(\\text{nullity} (\\boldsymbol{X})=0\\).\n  (\\(2\\)) \\(\\boldsymbol{X}^T\\boldsymbol{X}\\) 는 가역행렬이다.\n\n\n(해답). (\\(1\\)) \\(\\text{nullity} (\\boldsymbol{x}) &gt; 0\\) 이라면 어떤 nontrivial 한 \\(\\boldsymbol{a}\\) 에 대해 \\(\\boldsymbol{Xa}=\\boldsymbol{0}\\) 이어야 한다. 그렇다면, \\(\\sum_{i=0}^n {x_k}^i a_i = 0\\) (\\(i=1,\\ldots,\\,N\\)) 인데 \\(N&gt;n+1\\) 조건에서 \\(n\\) 차 방정식이 \\(N &gt; n+1\\) 개의 근을 갖는다는 이야기이므로 모순이다. 우리는 이미 \\(x_1 &lt; \\cdots &lt; x_N\\) 을 가정했다. 따라서 \\(\\boldsymbol{Xa}=\\boldsymbol{0}\\) 을 만족하는 \\(\\boldsymbol{a}\\) 는 \\(\\boldsymbol{0}\\) 뿐이다.\n(\\(2\\)) \\(\\boldsymbol{X}^T\\boldsymbol{X}\\) 는 대칭행렬이며 \\(\\text{nullity}(\\boldsymbol{X})=0\\) 이므로 non-trivial 한 벡터 \\(\\boldsymbol{a}\\) 에 대해 \\(\\boldsymbol{a}^T\\boldsymbol{X}^T\\boldsymbol{Xa} = \\|\\boldsymbol{Xa}\\|^2&gt;0\\) 이다. 따라서 \\(\\boldsymbol{X}^T\\boldsymbol{X}\\) 는 가역이다.\n\n\n연습문제 1 에 따라 \\(\\boldsymbol{a} = (\\boldsymbol{X}^T\\boldsymbol{X})^{-1}\\boldsymbol{X}^T\\boldsymbol{y}\\) 로 정해진다. 이것을 julia 로 구현하면 다음과 같다. x, y 의 베열을 입력하면 다항식의 계수를 order 에 대한 오름차순으로 반환한다. 즉 반환값의 첫번째 성분은 상수이다.\nusing LinearAlgebra\n\nfunction least_square_poly(\n    x::AbstractVector{&lt;:Real}, \n    y::AbstractVector{&lt;:Real}, \n    order::Integer)\n    @assert length(x) == length(y)\n    @assert order ≥ 2 && order &lt; length(x)-1\n    X = [(xi)^i for xi in x, i in 0:order]\n    a = inv(X'*X) *X' * y\n    return a\nend\nNAJ.jl 에서는 같은 이름 least_square_poly 함수가 정의되어 있다. 시그너쳐는 같고 반환값은 계수가 아니라 SimplePolynomial 객체이다.\nx = collect(-3:0.1:5)\nr = polynomial_from_roots([-3, 1, 4])\ny = r.(x) \nscatter(x, y, label = \"Data\")\np = least_square_poly(x, y, 3)\nplot!(x, p.(x), label = \"LeastSquared Polynoimal\")\n\n\n\n\n\n\n그림 2: 다항식을 이용한 최소자승법",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "Approximation"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/14_approximation.html#최소-자승법",
    "href": "src/numerical_analysis_using_julia/14_approximation.html#최소-자승법",
    "title": "Approximation",
    "section": "",
    "text": "아래 그림과 같이 \\(\\{(x_i,\\,y_i) : i = 1,\\ldots, N\\}\\) 가 주어졌을 때 이 데이터에 가장 근접하는 선형 방정식 \\(y=ax+b\\) 를 찾아야 할 때가 있다.\n\n\n\n\n\n\n그림 1: 선형 최소 자승법\n\n\n\n아래와 같은 함수 \\(E(a,\\,b)\\) 를 보자. \\[\nE(a, b) = \\sum_{i=1}^N \\left[ y_i - (ax_i + b)\\right]^2\n\\]\n이 함수는 모든 구간에서 미분가능하다는 매우 좋은 성질을 가지고 있다. 또한 \\(a,\\,b\\) 값이 상당히 벗어날 경우 매우 커지며, \\(y_i\\) 가 \\(ax_i +b\\) 와 일치할 경우 \\(0\\) 이 된다.\n\\[\n\\begin{aligned}\n\\dfrac{\\partial E}{\\partial a} &= -2\\sum_{i=1}^N x_i(y_i - ax_i - b), \\\\\n\\dfrac{\\partial E}{\\partial b} &= -2\\sum_{i=1}^N (y_i - ax_i -b), \\\\\n\\dfrac{\\partial^2 E}{\\partial a \\partial a }& = \\sum_{i=1}^N 2{x_i}^2, \\\\\n\\dfrac{\\partial^2 E}{\\partial a \\partial b} &= \\sum_{i=1}^N 2x_i, \\\\\n\\dfrac{\\partial^2 E}{\\partial b \\partial b}&= 2N\n\\end{aligned}\n\\]\n이며 이로부터 해세 행렬 (Hassian matrix)\n\\[\n\\boldsymbol{H} = \\begin{bmatrix} \\dfrac{\\partial^2 E}{\\partial a^2 } & \\dfrac{\\partial^2 E}{\\partial a \\partial b} \\\\ \\dfrac{\\partial^2 E}{\\partial a \\partial b} & \\dfrac{\\partial^2 E}{\\partial b^2} \\end{bmatrix} = \\begin{bmatrix} {\\displaystyle \\sum_{i=1}^N 2{x_i}^2} & {\\displaystyle \\sum_{i=1}^N 2x_i}, \\\\ {\\displaystyle \\sum_{i=1}^N 2x_i} & 2N \\end{bmatrix}\n\\]\n을 얻는다. 위 해세 행렬의 행렬식은\n\\[\nD = \\det (\\boldsymbol{H}) = 4 \\left[N\\left(\\sum_i^N {x_i}^2 \\right)- \\left(\\sum_i^N x_i\\right)^2\\right]\n\\]\n이며, 코시-슈바르츠 부등식으로 \\(D\\ge 0\\) 이며 \\(D=0\\) 일 때는 \\(x_1 = \\cdots = x_i\\) 일 때임을 보일 수 있다. 이것을 제외하면 \\(D&gt;0\\) 이며 \\(E(a,\\,b)\\) 는 극소값을 가진다는 것을 안다. 극소값을 가질 때는 \\(\\dfrac{\\partial E}{\\partial a}= \\dfrac{\\partial E}{\\partial b}=0\\) 일 때이므로,\n\\[\n\\begin{aligned}\n\\dfrac{\\partial E}{\\partial a}= 0 &\\implies \\sum_i x_i y_i - a \\left(\\sum_i {x_i}^2\\right) - b \\left(\\sum_{i}x_i\\right) = 0, \\\\\n\\dfrac{\\partial E}{\\partial b} = 0 &\\implies \\sum_i y_i - a\\left(\\sum_i x_i\\right) - b N = 0\n\\end{aligned}\n\\]\n이다. 위 식은 \\(a,\\,b\\) 에 대한 연립방정식이며 이것을 풀면 다음과 같다.\n\\[\na = \\dfrac{N \\left( \\displaystyle \\sum_{i=1}^N x_i y_i\\right) - \\left(\\displaystyle \\sum_{i=1}^N x_i\\right) \\left( \\displaystyle \\sum_{i=1}^N y_i\\right)}{N \\left(\\displaystyle \\sum_{i=1}^N {x_i}^2\\right) - \\left(\\displaystyle \\sum_{i=1}^N x_i\\right)^2}, \\qquad\nb=  \\dfrac{\\left( \\displaystyle \\sum_{i=1}^N {x_i}^2\\right)  \\left( \\displaystyle \\sum_{i=1}^N y_i\\right) - \\left(\\displaystyle \\sum_{i=1}^N x_iy_i\\right) \\left( \\displaystyle \\sum_{i=1}^N x_i\\right)}{N \\left(\\displaystyle \\sum_{i=1}^N {x_i}^2\\right) - \\left(\\displaystyle \\sum_{i=1}^N x_i\\right)^2},\n\\]\n언뜻 복잡해 보이지만 프로그래밍 입장에서 보면 베열의 합, 베열의 곱의 합, 베열의 제곱의 합, 배열의 합의 제곱에 대한 사칙연산 뿐이며, 쉽게 코딩 할 수 있다.\n\n\n\n\n\\(y=be^{ax}\\) 꼴의 지수함수의 경우 각각 \\(\\ln y = ax + \\ln b\\) 로 변형시킨 후 \\(\\overline{y}=\\ln y,\\, \\overline{b} = \\ln b\\) 로 놓으면\n\\[\n\\overline{y} = ax + \\overline{b}\n\\]\n의 선형방정식이 된다. 따라서 선형방정식의 최소자승법으로 \\(a\\) 와 \\(\\overline{b}\\) 를 구할 수 있기 때문에 지수함수에 대해서는 최소자승법을 사용 할 수 있다. \\(y=dx^c\\) 꼴의 멱함수의 경우에는 \\(\\ln y = \\ln d + c\\ln x\\) 이므로 \\(\\overline{y} = \\ln y\\), \\(\\overline{x} = \\ln x\\), \\(\\overline{d} = \\ln d\\) 로 놓으면\n\\[\n\\overline{y} = c \\overline{x} + \\overline{d}\n\\]\n를 이용해 역시 최소자승법으로 \\(c,\\, d\\) 를 구할 수 있다.\n\n\n\n\n데이터 \\(\\{(x_k,\\,y_k):k=1,\\,N\\}\\) (\\(x_1&lt;x_2&lt;\\cdots &lt; x_N\\)) 과 \\(n\\) 차 다항식\n\\[\np_n (x) = a_n x^n + a_{n-1}x^{n-1} + \\cdots + a_1 x + a_0\n\\]\n에 대해\n\\[\nE(a_n,\\ldots,\\,a_0) = \\sum_{k=1}^N \\left[ y_k - p_n(x_k)\\right]^2\n\\]\n를 최소로 하는 \\(a_0,\\ldots,\\,a_n\\) 을 찾는다. 이 경우 \\(N=n+1\\) 이면 다항식을 이용한 보간법이 되어 \\(E=0\\) 이 되도록 하는 \\(a_0,\\ldots,\\,a_n\\) 이 존재한다는 것을 안다. 보통 최소자승법은 \\(N&gt;n+1\\) 일 경우의 가장 좋은 다항식 \\(p_n\\) 을 찾는 것을 말한다. 여기서도 \\(n&lt;N-1\\) 임을 가정하겠다.\n\\[\n\\begin{aligned}\nE(a_n,\\ldots,\\,a_0) &= \\sum_{k=1}^N {y_k}^2 -2 \\sum_{k=1}^N y_k p_n(x_i) + \\sum_{k=1}^N (p_n(x_k))^2\\\\\n&= \\sum_{k=1}^N {y_k}^2 - 2 \\sum_{k=1}^N \\sum_{i=0}^n a_i y_k {x_k}^j + \\sum_{k=1}^N \\sum_{i,\\,j=1}^n a_i a_j {x_k}^{i+j} \\\\\n&= \\sum_{k=1}^N {y_k}^2 - 2\\sum_{i=0}^n \\left(\\sum_{k=1}^N (x_k)^i y_k\\right) a_i + \\sum_{i, j=0}^n \\left(\\sum_{k=1}^N {x_k}^{i+j}\\right) a_i a_j\n\\end{aligned}\n\\]\n이며 \\(E\\) 를 최소로 하는 극값은 \\(i=0,\\ldots,n\\) 에 대해\n\\[\n\\dfrac{\\partial E}{\\partial a_i}=0 \\implies \\sum_{k=1}^N \\left[ (x_k)^i y_k- \\sum_{j=0}^n  (x_k)^{i+j} a_j\\right] = 0\n\\tag{1}\\]\n를 만족해야 한다. 이제 행렬 \\(\\boldsymbol{X} \\in \\mathcal{M}_{N\\times (n+1)}(\\mathbb{F}),\\,\\boldsymbol{a} \\in\\mathcal{M}_{n+1}(\\mathbb{F}),\\,\\boldsymbol{y}\\in \\mathcal{M}_N(\\mathbb{F})\\) 를 다음과 같이 정의하자.\n\\[\nX_{ij} = (x_i)^{j-1},\\qquad \\boldsymbol{a} = \\begin{bmatrix} a_0 & \\cdots & a_n\\end{bmatrix}^T, \\qquad \\boldsymbol{y} = \\begin{bmatrix} y_1 & \\cdots & y_N \\end{bmatrix}\n\\]\n그렇다면,\n\\[\n(\\boldsymbol{X}^T\\boldsymbol{X})_{ij} = \\sum_{k=1}^N X_{ki}X_{kj} = \\sum_{k=1}^N x_{k}^{i+j-2}\n\\]\n이므로 식 1 는 다음과 같은 선형방정식이 된다. 아래와 같은 형태의 방정식을 정규 방정식(normal equation) 이라고 한다.\n\\[\n\\boldsymbol{X}^T\\boldsymbol{Xa} = \\boldsymbol{X}^T\\boldsymbol{y}\n\\tag{2}\\]\n\n\n연습문제 1 위에서 정의된 \\(\\boldsymbol{X}\\) 에 대해 다음을 보여라.\n  (\\(1\\)) \\(\\text{nullity} (\\boldsymbol{X})=0\\).\n  (\\(2\\)) \\(\\boldsymbol{X}^T\\boldsymbol{X}\\) 는 가역행렬이다.\n\n\n(해답). (\\(1\\)) \\(\\text{nullity} (\\boldsymbol{x}) &gt; 0\\) 이라면 어떤 nontrivial 한 \\(\\boldsymbol{a}\\) 에 대해 \\(\\boldsymbol{Xa}=\\boldsymbol{0}\\) 이어야 한다. 그렇다면, \\(\\sum_{i=0}^n {x_k}^i a_i = 0\\) (\\(i=1,\\ldots,\\,N\\)) 인데 \\(N&gt;n+1\\) 조건에서 \\(n\\) 차 방정식이 \\(N &gt; n+1\\) 개의 근을 갖는다는 이야기이므로 모순이다. 우리는 이미 \\(x_1 &lt; \\cdots &lt; x_N\\) 을 가정했다. 따라서 \\(\\boldsymbol{Xa}=\\boldsymbol{0}\\) 을 만족하는 \\(\\boldsymbol{a}\\) 는 \\(\\boldsymbol{0}\\) 뿐이다.\n(\\(2\\)) \\(\\boldsymbol{X}^T\\boldsymbol{X}\\) 는 대칭행렬이며 \\(\\text{nullity}(\\boldsymbol{X})=0\\) 이므로 non-trivial 한 벡터 \\(\\boldsymbol{a}\\) 에 대해 \\(\\boldsymbol{a}^T\\boldsymbol{X}^T\\boldsymbol{Xa} = \\|\\boldsymbol{Xa}\\|^2&gt;0\\) 이다. 따라서 \\(\\boldsymbol{X}^T\\boldsymbol{X}\\) 는 가역이다.\n\n\n연습문제 1 에 따라 \\(\\boldsymbol{a} = (\\boldsymbol{X}^T\\boldsymbol{X})^{-1}\\boldsymbol{X}^T\\boldsymbol{y}\\) 로 정해진다. 이것을 julia 로 구현하면 다음과 같다. x, y 의 베열을 입력하면 다항식의 계수를 order 에 대한 오름차순으로 반환한다. 즉 반환값의 첫번째 성분은 상수이다.\nusing LinearAlgebra\n\nfunction least_square_poly(\n    x::AbstractVector{&lt;:Real}, \n    y::AbstractVector{&lt;:Real}, \n    order::Integer)\n    @assert length(x) == length(y)\n    @assert order ≥ 2 && order &lt; length(x)-1\n    X = [(xi)^i for xi in x, i in 0:order]\n    a = inv(X'*X) *X' * y\n    return a\nend\nNAJ.jl 에서는 같은 이름 least_square_poly 함수가 정의되어 있다. 시그너쳐는 같고 반환값은 계수가 아니라 SimplePolynomial 객체이다.\nx = collect(-3:0.1:5)\nr = polynomial_from_roots([-3, 1, 4])\ny = r.(x) \nscatter(x, y, label = \"Data\")\np = least_square_poly(x, y, 3)\nplot!(x, p.(x), label = \"LeastSquared Polynoimal\")\n\n\n\n\n\n\n그림 2: 다항식을 이용한 최소자승법",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "Approximation"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/14_approximation.html#직교-다항식을-이용한-최소자승법",
    "href": "src/numerical_analysis_using_julia/14_approximation.html#직교-다항식을-이용한-최소자승법",
    "title": "Approximation",
    "section": "2 직교 다항식을 이용한 최소자승법",
    "text": "2 직교 다항식을 이용한 최소자승법\n\n2.1 내적벡터공간으로서의 함수의 집합\n\n필드 \\(\\mathbb{F}\\) 에서 정의된 \\(x\\) 를 변수로 갖는 \\(n\\) 차 이하의 다항식의 집합을 \\(\\mathbb{F}_n [x]\\) 라고 하자. 또한 \\(x\\) 를 변수로 하는 다항식 전체의 집합을 \\(\\mathbb{F}[x]\\) 라고 하자. 실수에서 정의된 2차 이하의 다항식의 집합은 \\(\\mathbb{R}_2[x]\\) 로 쓸 수 있다.\n\\([a,\\,b]\\) 구간에서 연속인 함수의 집합 \\(C_{[a,\\,b]}\\) 가 벡터공간이기 때문에 선형대수학에의 중요한 개념인 벡터, 선형독립, 기저와 같은 개념을 그대로 쓸 수 있다.\n\n\n\n연습문제 2 \\(p_k(x)\\) 가 각각 \\(k\\) 차 다항식일 때 \\(\\{p_1(x),\\ldots,\\,p_n(x)\\}\\) 은 선형독립이다.\n\n\n(해답). \\(c_1p_1(x) + \\cdots + c_n p_n(x)=0\\) 이라고 하자. \\(n\\) 차항은 \\(p_n(x)\\) 밖에 없으므로 \\(c_n=0\\) 이다. \\(n-1\\) 차항은 \\(p_{n-1}\\) 박에 없으므로 \\(c_{n-1}=0\\) 이다. 이것을 반복하면 \\(c_1= \\cdots = c_n=0\\) 을 보인다.\n\n\n\\(C_[a,\\,b]\\) 에서 내적을 어떤 정해진 함수 \\(w(x)\\) 에 대해 다음과 같이 정의 할 수 있다.\n\\[\n\\langle \\varphi,\\, \\psi \\rangle := \\int_{a}^b \\varphi(x)\\, \\psi(x)\\, w(x)\\, dx\n\\]\n이 때 \\(w(x)\\) 를 무게 함수(weight function) 이라고 하며 (1) 모든 \\(x\\in [a,\\,b]\\) 에서 \\(w(x)\\ge 0\\) 이며 (2) \\([a,\\,b]\\) 에 포함되는 모든 \\([c,\\,d]\\) 에서 \\(w([c,\\,d]) \\ne \\{0\\}\\) 이다. 이렇게 정의된 내적에 대해 \\(\\langle \\varphi,\\, \\psi \\rangle = 0\\) 이면 \\(\\varphi\\) 와 \\(\\psi\\) 는 서로 직교한다(be orthoginal)고 한다. \\(\\{\\phi_1,\\ldots,\\,\\phi_n\\} \\subset C_{[a,\\,b]}\\) 에 대해 \\(\\langle \\phi_i,\\,\\phi_j\\rangle = c_i\\delta_{ij}\\), \\(c_{i} &gt; 0\\) 이면 \\(\\{\\phi_1,\\ldots,\\,\\phi_n\\}\\) 을 직교하는 함수의 집합이라고 하며, \\(\\langle \\phi_i,\\,\\phi_j\\rangle =\\delta_{ij}\\) 이면 정규직교집합 이라고 한다.\n\\(p(x) \\in C_{[a,\\,b]}\\) 가 직교하는 함수의 집합 \\(\\{\\phi_1,\\ldots,\\,\\phi_n\\}\\) 의 선형결합이라고 하자. \\(p(x) = \\sum_{i=1}^n a_n \\phi_n (x)\\) 이며 여기에 무게함수 \\(w(x)\\) 정의되어 있다면\n\\[\n\\langle p(x),\\, \\phi_k(x) \\rangle = a_k \\langle \\phi_k,\\, \\phi_k \\rangle\n\\]\n이다. \\(\\{\\phi_1,\\ldots,\\,\\phi_n\\}\\) 가 정규직교집합이라면 \\(c_k=1\\) 이므로 \\(a_k = \\langle p(x),\\,\\phi_k(x)\\rangle\\) 이다.\n\\(C_{[a,\\,b]}\\) 이 내적벡터공간이며 내적벡터공간에서의 정규직교벡터-여기서는 직교하는 함수의 집합-을 생각 할 수 있으므로 당연히 이 정규하는 함수의 집합으로부터 정규직교집합을 구성 할 수 있다. 그 방법중 한가지는 그람-슈미트 과정이다. \\(\\{\\phi_1,\\ldots,\\,\\phi_n\\}\\) 이 직교하는 함수의 집합이며 \\(\\|f\\|= \\sqrt{\\langle f,\\, f\\rangle}\\) 라고 할 때,\n\\[\n\\begin{aligned}\n\\psi_1(x) &= \\dfrac{\\phi_1(x)}{\\|\\phi_1(x)\\|}, \\\\\n\\varphi_k (x) &= \\phi_k(x) - \\sum_{j=1}^{k-1} \\langle \\phi_k,\\, \\psi_j\\rangle \\psi_k(x),\\\\\n\\psi_k (x) &= \\dfrac{\\varphi_k(x)}{\\|\\varphi_k(x)\\|}\n\\end{aligned}\n\\]\n라고 정의하면 \\(\\{\\psi_1(x),\\ldots,\\,\\psi_k(x)\\}\\) 는 정규직교집합이다.\n\n\n\n2.2 르장드르 다항식\n\n\n\n\n\n\n\n정의 1 (르장드르 다항식) 르장드르 다항식 \\(P_n(x)\\) \\((n=0,\\,1,\\ldots)\\) 는 \\([-1,\\,1]\\) 구간에서 다음과 같이 재귀적으로 정의되는 다항식이다.\n\\[\n\\begin{aligned}\nP_0(x) & = 1, \\\\\nP_1(x) & = x, \\\\\nnP_n(x) & = (2n−1)xP_{n−1}(x)−(n−1)P_{n−2}(x).\n\\end{aligned}\n\\]\n르장드르 다항식에 대한 무게함수는 \\(w(x)=1\\) 이다.\n\n\n\n\n\n\n\n\n\n\n그림 3: 르장드르 다항식\n\n\n\n르장드르 다항식은 르장드르 미분방정식이라고 불리는 2계 제차 미분방정식\n\\[\n(1-x^2) y'' -2xy' + n(n+1)y=0\n\\]\n의 해이며, 무게함수는 \\(w(x)=1\\) 이다. 이 때,\n\\[\n\\langle P_n(x),\\, P_m(x) \\rangle = \\int_{-1}^1 P_n(x)P_m(x)\\,dx =  \\dfrac{2}{2n+1}\\delta_{ij}\n\\tag{3}\\]\n이다.\n\n\n\n2.3 체비쇼프 다항식\n체비쇼프 다항식은 체비쇼프 미분방정식 의 해로 \\(T_n(1) = 1,\\, T_{n}(-1)= (-1)^n\\) 의 경계조건을 만족하는 해이다.\n\n\n\n\n\n\n\n정의 2 (체비쇼프 다항식) 1형 체비쇼프 다항식 \\(T_n(x)\\) \\((n=0,\\,1,\\ldots)\\) 는 \\([-1,\\,1]\\) 구간에서 다음과 같이 재귀적으로 정의되는 다항식이다.\n\\[\n\\begin{aligned}\nT_0(x) & = 1, \\\\\nT_1(x) & = x, \\\\\nT_{n}(x) & = 2xT_{n−1}(x) - T_{n-2}(x).\n\\end{aligned}\n\\]\n체비쇼프 다항식의 무게함수는 \\(w(x) = \\dfrac{1}{\\sqrt{1-x^2}}\\) 이다.\n\n\n\n\n체비쇼프 다항식은 1형과 2형이 있지만 여기서는 1형만 사용한다.\n\n\n\n\n\n그림 4: Chevyshev 다항식\n\n\n\n체비쇼프 다항식의 내적에 대해\n\\[\n\\langle T_m,\\, T_n \\rangle = \\int_{-1}^1 T_m(x) T_n(x) \\dfrac{1}{\\sqrt{1-x^2}}\\,dx = \\left\\{\\begin{array}{ll} 0, \\qquad &m \\ne n \\\\ \\dfrac{\\pi}{2},  & m = n \\neq 0 \\\\ \\pi, & m=n=0 \\\\ \\end{array}\\right.\n\\]\n이 성립한다. 체비쇼프 미분방정식은\n\\[\n(1-x)^2 \\dfrac{d^2T_n}{dx^2} - xT_n (x) = -n^2 T_n(x)\n\\]\n인데 여기서 \\(x=\\cos\\theta\\) 로 놓으면, 위의 미분방정식은\n\\[\n\\dfrac{d^2T_n}{d\\theta^2} + n^2 T_n = 0\n\\]\n이 된다. 즉 \\(T_n(\\theta) = n\\cos\\theta\\) 이므로\n\\[\nT_n (x) = \\cos (n \\arccos x)\n\\tag{4}\\]\n이다.\n식 4 으로부터 우리는 \\(T_n(x) = 0\\) 의 해는\n\\[\nx_k =  \\cos \\left(\\dfrac{2k\\pi+\\pi}{2n}\\right),\\qquad k=0,\\,1,\\ldots,, n-1\n\\]\n임을 알 수 있다. 또한\n\\[\n\\overline{x}_k = \\cos \\left(\\dfrac{k\\pi}{n}\\right),\\qquad k=0,\\ldots,\\, n\n\\]\n에 대해 \\(T_n (\\overline{x}_k) = (-1)^k\\) 임을 안다.",
    "crumbs": [
      "수치해석",
      "Julia 언어를 이용한 수치해석 1부",
      "Approximation"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/A_pde.html",
    "href": "src/numerical_analysis_using_julia/A_pde.html",
    "title": "편미분 방정식",
    "section": "",
    "text": "이름\n방정식\n비고\n\n\n\n\n라플라스 방정식\n\\(\\nabla^2 \\psi = 0\\)\n전기자기학, 유체역학, 열전달, 중력\n\n\n포아송 방정식\n\\(\\nabla^2 \\psi = -\\rho/\\varepsilon_0\\)\nsource term 이 있는 전기/자기 현상\n\n\n헬름홀츠 방정식, 시간 독립적인 확산 방정식\n\\(\\nabla^2 \\psi \\pm k^2 \\psi  = 0\\)\n고체의 탄성파와 음파, 전자기파, 원자력 발전\n\n\n시간 의존적인 확산방정식\n\\(\\nabla^2 \\psi = \\dfrac{1}{a^2}\\dfrac{\\partial \\psi}{\\partial t}\\)\n\n\n\n시간 의존적인 고전 파동 방정식\n\\(\\dfrac{1}{c^2}\\dfrac{\\partial^2 \\psi}{\\partial t^2} = \\nabla^2 \\psi\\)\n\n\n\n클라인-고든 방정식\n\\(\\partial^2 \\psi = -\\mu^2 \\psi\\)\n상대론적 양자 역학\n\n\n시간 독립적인 슈레딩거 방정식\n\\(i\\hbar \\dfrac{\\partial \\psi}{\\partial t} =  -\\dfrac{\\hbar^2}{2m}\\nabla^2 \\psi + V\\psi\\)\n양자역학\n\n\n시간 의존적인 슈레딩거 방정식\n\\(-\\dfrac{\\hbar^2}{2m}\\nabla^2 \\psi + V\\psi = E\\psi\\)\n양자역학",
    "crumbs": [
      "수치해석",
      "수학",
      "편미분 방정식"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/A_pde.html#대표적인-편미분방정식",
    "href": "src/numerical_analysis_using_julia/A_pde.html#대표적인-편미분방정식",
    "title": "편미분 방정식",
    "section": "",
    "text": "이름\n방정식\n비고\n\n\n\n\n라플라스 방정식\n\\(\\nabla^2 \\psi = 0\\)\n전기자기학, 유체역학, 열전달, 중력\n\n\n포아송 방정식\n\\(\\nabla^2 \\psi = -\\rho/\\varepsilon_0\\)\nsource term 이 있는 전기/자기 현상\n\n\n헬름홀츠 방정식, 시간 독립적인 확산 방정식\n\\(\\nabla^2 \\psi \\pm k^2 \\psi  = 0\\)\n고체의 탄성파와 음파, 전자기파, 원자력 발전\n\n\n시간 의존적인 확산방정식\n\\(\\nabla^2 \\psi = \\dfrac{1}{a^2}\\dfrac{\\partial \\psi}{\\partial t}\\)\n\n\n\n시간 의존적인 고전 파동 방정식\n\\(\\dfrac{1}{c^2}\\dfrac{\\partial^2 \\psi}{\\partial t^2} = \\nabla^2 \\psi\\)\n\n\n\n클라인-고든 방정식\n\\(\\partial^2 \\psi = -\\mu^2 \\psi\\)\n상대론적 양자 역학\n\n\n시간 독립적인 슈레딩거 방정식\n\\(i\\hbar \\dfrac{\\partial \\psi}{\\partial t} =  -\\dfrac{\\hbar^2}{2m}\\nabla^2 \\psi + V\\psi\\)\n양자역학\n\n\n시간 의존적인 슈레딩거 방정식\n\\(-\\dfrac{\\hbar^2}{2m}\\nabla^2 \\psi + V\\psi = E\\psi\\)\n양자역학",
    "crumbs": [
      "수치해석",
      "수학",
      "편미분 방정식"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/A_pde.html#계-편미분-방정식",
    "href": "src/numerical_analysis_using_julia/A_pde.html#계-편미분-방정식",
    "title": "편미분 방정식",
    "section": "2 1계 편미분 방정식",
    "text": "2 1계 편미분 방정식\n\n2.1 특성곡선법\n상미분방정식과 같이 선형 편미분 연산자를 \\(\\mathcal{L}\\) 이라고 하자. 다음과 같이 주어진 편미분 방정식을 생각하자.\n\\[\n\\mathcal{L}\\varphi = a\\dfrac{\\partial \\varphi}{\\partial x} + b \\dfrac{\\partial \\varphi}{\\partial y} = 0.\n\\tag{1}\\]\n이 경우 \\(s=ax+by,\\, t= bx-ay\\) 로 선형 변환을 해 주면,\n\\[\n\\begin{aligned}\n0 &= a\\dfrac{\\partial \\varphi}{\\partial x} + b \\dfrac{\\partial \\varphi}{\\partial y} = a \\left(\\dfrac{\\partial \\varphi}{\\partial s}\\dfrac{\\partial s}{\\partial x}+\\dfrac{\\partial \\varphi}{\\partial t}\\dfrac{\\partial t}{\\partial x}\\right) + b\\left(\\dfrac{\\partial \\varphi}{\\partial s}\\dfrac{\\partial s}{\\partial y}+\\dfrac{\\partial \\varphi}{\\partial t}\\dfrac{\\partial t}{\\partial y}\\right) \\\\\n&= (a^2+b^2)\\dfrac{\\partial \\varphi}{\\partial s}\n\\end{aligned}\n\\tag{2}\\]\n이 되며, 따라서 \\(\\varphi\\) 는 \\(t\\) 의 함수이다. 즉, 임의의 \\(C^1\\) 함수 \\(f\\) 에 대해 \\(\\varphi(x,\\,y) = f(bx - ay)\\) 이며 다른 조건은 더이상 찾을 수 없다. 즉 식 1 에서와 같은 편미분 방정식이 \\(\\dfrac{d\\varphi}{ds}=0\\) 인 1계 상미분방정식으로 변한다. 이렇게 편미분 방정식을 하나 혹은 그 이상의 상미분 방정식으로 변환하는 것을 특성곡선법(method of characteristics) 이라고 하며 변화된 상미분 방정식 특성 곡선 (characteristic curve) 혹은 특성 곡면(characteristic curve) 라고 한다.\n이제 식 1 을 다시 보자. \\(\\mathbb{R}^2\\) 에서 생각하면 \\(\\boldsymbol{a} = (a,\\,b)\\) 에 대해 \\(\\boldsymbol{a} \\cdot \\nabla \\varphi (x,\\,y)=0\\) 인 함수 \\(\\varphi (x,\\,y)\\) 를 찾는 것이다. \\(\\nabla \\varphi (x,\\,y)\\) 는 \\(x,\\,y\\) 에서 \\(\\varphi\\) 가 최대로 증가하는 벡터를 의미하며 \\(\\boldsymbol{a} \\cdot \\nabla \\varphi = 0\\) 이므로 \\(\\boldsymbol{a}\\) 는 \\(\\varphi (x, y)=c\\) 인 방향을 의미한다. 즉 \\(t=bx-ay\\) 를 상수로 놓으면 \\(\\varphi (x,\\,y)\\) 도 상수이다. – to be extended–\n이제 좀 더 일반적인 경우를 살펴보자. 아래와 같이 선형 미분 연산자 \\(\\mathcal{L}\\) 에 대한 inhomogeneouse 미분방정식\n\\[\n\\mathcal{L}\\varphi = a\\dfrac{\\partial \\varphi}{\\partial x} + b \\dfrac{\\partial \\varphi}{\\partial y} +q(x,\\,y)\\varphi = F(x, y)\\,.\n\\tag{3}\\]\n를 앞에서와 같이 \\(s=ax+by,\\, t=bx-ay\\) 로 변수를 변환시키면,\n\\[\n(a^2+b^2) \\left(\\dfrac{\\partial \\varphi}{\\partial s}\\right)+ \\overline{q}(s, t) \\varphi = \\overline{F}(s, t)\n\\tag{4}\\]\n이다. 여기서 \\(\\overline{q},\\,\\overline{F}\\) 는 \\(q(x,\\,y),\\, F(x,\\,y)\\) 를 \\(x=\\dfrac{as}{a^2+b^2} + \\dfrac{bt}{a^2+b^2}\\), \\(y=\\dfrac{bs}{a^2+b^2}s - \\dfrac{at}{a^2+b^2}\\) 로 변환시킨 함수이다. 이 경우 식 4 는 \\(\\varphi\\) 의 \\(s\\) 에 대한 1계 ODE 이며 \\(t\\)-constant function 이 특성곡선이 된다.",
    "crumbs": [
      "수치해석",
      "수학",
      "편미분 방정식"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/A_pde.html#계-pde",
    "href": "src/numerical_analysis_using_julia/A_pde.html#계-pde",
    "title": "편미분 방정식",
    "section": "3 2계 PDE",
    "text": "3 2계 PDE\n이제 LHODE 와 같이 선형 제차 편미분방정식을 LHPDE 라고 쓰자. 그리고 함수 \\(u(x, y)\\) 에 대해 \\(u_{x} = \\dfrac{\\partial u}{\\partial x}\\), \\(u_{xy}= \\dfrac{\\partial^2 u}{\\partial x\\partial y}\\) 라고 쓰기로 하자. 이것은 타이핑을 많이 줄여준다.\n\n3.1 2계 PDE 의 분류\n\n2차원의 경우\n2차원에서의 2계 LHPDE 는 다음과 같은 꼴을 갖는다.\n\\[\nAu_{xx} + Bu_{xy} + Cu_{yy} + Du_x + Eu_y + Fu = 0\n\\]\n이 때 \\(B^2-4AC &lt; 0\\) 일 때 이 PDE 를 타원형(elliptical) 이라고 하며, \\(B^2-4AC&gt;0\\) 일 때 쌍곡선형(hyperbollic) 이라고 한다. \\(B^2-4AC=0\\) 일 때는 포물선형(parabolic) 이라고 한다\\(^\\ast\\). \\(^\\ast\\) 그 이유는 \\(Ax^2 +B xy + Cy^2 + Dx + Eu + F = 0\\) 이 \\(B^2-4AC &lt;0\\) 일 때 타원, \\(B^2-4AC&gt;0\\) 일 때 쌍곡선, \\(B^2-4AC=0\\) 일 때 포물선인 데서 유래한다.\n예를 들어 실수 \\(a,\\,c\\) 에 대해\n\\[\na^2 u_{xx} - c^2 u_{yy}=0\n\\]\n의 경우는 쌍곡선형이다. 이 미분방정식은 \\((a\\partial_x+c\\partial_y) (a\\partial_x-c\\partial_y)u=0\\) 를 만족하며 \\((a\\partial_x+c\\partial_y) u=0\\) 이거나 \\((a\\partial_x-c\\partial_y) u=0\\) 의 해 모두 해가 된다. 즉 2차원 LHPDE 가 1차원 LHPDE 로 변형되었다. 또한 \\(s=ax+by,\\, t= bx-ay\\) 가 특성곡선이 된다.\n비슷한 경우로\n\\[\na^2 u_{xx} + c^2 u_{yy}=0\n\\]\n의 경우는 타원형이다. 이 미분방정식은 \\((a\\partial_x+ic\\partial_y) (a\\partial_x-ic\\partial_y)u=0\\) 를 만족한다.\n\\[\na^2 u_{xx} - 2acu_{xy} + c^2u_{yy}=0\n\\]\n의 경우 \\((a\\partial_x - c\\partial_y)^2y=0\\) 이다. 혹은\n\\[\nu_{xx} +au_t=0\n\\]\n인 경우도 포물선형이다.\n\n\n\n다차원의 경우\n주로 2차원 공간 + 시간, 3차원 공간, 3차원 공간+시간 의 경우이며 이보다 많은 차원의 경우도 생각 할 수 있다.\n\n\n\n\n3.2 경계조건\n일반적으로 경계조건은 세가지 가운데 한가지이다.\n\n디리클레 경계 조건 : 경계에서의 함수값이 정해져 있는 경우.\n노이만 경계 조건 : 경계에서의 normal derivative 가 정해져 있는 경우.\n코시 경계 조건 : 디리클레와 노이만 경계조건이 모두 다 정해져 있는 경우. 보통은 미분방정식의 해를 너무 제한하기 때문에 사용하지 않는다.",
    "crumbs": [
      "수치해석",
      "수학",
      "편미분 방정식"
    ]
  },
  {
    "objectID": "src/numerical_analysis_using_julia/A_pde.html#변수분리법",
    "href": "src/numerical_analysis_using_julia/A_pde.html#변수분리법",
    "title": "편미분 방정식",
    "section": "4 변수분리법",
    "text": "4 변수분리법\n\\(n\\) 개의 변수에 대한 PDE 를 \\(n\\) 개의 ODE 로 변환시키는 방법이다.\n\n4.1 데카르트 좌표계에서\n다음과 같이 주어지는 3차원에서의 헬름홀츠 방정식을 생각하자. \\[\n\\nabla^2 \\psi + k^2 \\psi = 0.\n\\tag{5}\\]\n3차원 \\((x,\\,y,\\,z)\\) 에서 정의되는 함수 \\(\\psi\\) 를 각각 \\(x,\\,y,\\,z\\) 에 대한 함수의 곱으로 표현하자. 즉,\n\\[\n\\psi(x,\\,y,\\,z) = X(x)Y(y)Z(z)\n\\]\n라고 하자. 식 5 를 보면 모든 미분항이 하나의 변수에 대한 미분항이다. 즉 \\(\\partial_x\\partial_y\\) 같은 것이 없으며, 이 경우 각 변수에 대한 함수의 곱으로 표현했을 때 유용한 경우가 많다. 이렇게 다차원 함수를 각 변수에 대한 함수의 곱으로 표현하여 방정식을 푸는 것을 변수분리법(separation of variables) 이라고 한다. 이 경우 식 5 는 다음과 같다.\n\\[\n\\dfrac{d^2 X(x)}{dx^2} Y(y)Z(z) + X(x)\\dfrac{d^2Y(y)}{d^2y}Z(z) + X(x)Y(y)\\dfrac{d^2 Z(z)}{dz^2} + k^2 X(x)Y(y)Z(z)=0.\n\\]\n그렇다면,\n\\[\n\\dfrac{1}{X}\\dfrac{d^2 X}{dx^2}= -k^2 - \\dfrac{1}{Y}\\dfrac{d^2Y}{dy^2} - \\dfrac{1}{Z} \\dfrac{d^2Z}{dz^2}\n\\]\n이다. 그런데 좌변은 \\(x\\) 에 대한 함수이고 우변은 \\(y,\\,z\\) 에 대한 함수여야 하므로 이 식은 상수일 수 밖에 없다. 상수를 \\(-l^2\\) 라 놓으면,\n\\[\n\\begin{aligned}\n\\dfrac{1}{X}\\dfrac{d^2 X}{dx^2} &= -l^2 , \\\\\n-k^2 - \\dfrac{1}{Y}\\dfrac{d^2Y}{dy^2} - \\dfrac{1}{Z} \\dfrac{d^2Z}{dz^2} &= -l^2.\n\\end{aligned}\n\\]\n이며, 이 중 두번째 식은,\n\\[\n\\dfrac{1}{Y}\\dfrac{d^2Y}{dy^2}= -k^2+l^2 - \\dfrac{1}{Z}\\dfrac{d^2Z}{dz^2}\n\\]\n가 된다. 역시 좌변은 \\(y\\) 에 대한 함수이고 우변은 \\(z\\) 에 대한 함수이므로,\n\\[\n\\begin{aligned}\n\\dfrac{1}{Y}\\dfrac{d^2Y}{dy^2} &= -m^2 , \\\\\n-k^2+l^2 - \\dfrac{1}{Z}\\dfrac{d^2Z}{dz^2} &= -m^2.\n\\end{aligned}\n\\]\n로 놓을 수 있다. 이제\n\\[\n\\dfrac{1}{Z} \\dfrac{d^2Z}{dz^2}=-n^2\n\\]\n로 놓으면,\n\\[\n\\dfrac{1}{X}\\dfrac{d^2X}{dx^2} = -l^2,\\qquad \\dfrac{1}{Y}\\dfrac{d^2Y}{dy^2} = -m^2, \\qquad\\dfrac{1}{Z} \\dfrac{d^2Z}{dz^2}=-n^2,\\qquad l^2+m^2+n^2=k^2\n\\]\n를 얻는다. 각각의 \\(l,\\,m,\\,n\\) 에 대한 3개의 상미분방정식의 해를 \\(X_l(x),\\, Y_m(y),\\, Z_n(z)\\) 라고 하자. 당연히 \\(l^2+m^2+n^2=k^2\\) 를 만족해야 한다. 그리고 \\(\\psi_{lmn}(x,\\,y,\\,z) = X_l(x)Y_m(y)Z_n(z)\\) 라고 하자. 이제 식 5 의 일반해를 다음과 같이 기술할 수 있다.\n\\[\n\\psi = \\sum_{l, m} a_{lm} \\psi_{lmn}.\n\\]\n인덱스에서 \\(n\\) 을 뺀 이유는 \\(n^2 = k^2-l^2-m^2\\) 로 정해지기 때문이다.\n\n\n\n4.2 원통좌표계에서\n\\((\\rho,\\, \\phi,\\, z)\\) 를 변수로 하는 실린더 좌표계에서의 핼름홀즈 방정식(식 5) 은\n\\[\n\\dfrac{1}{\\rho}\\dfrac{\\partial }{\\partial \\rho} \\left(\\rho\\dfrac{\\partial \\psi}{\\partial \\rho}\\right) + \\dfrac{1}{\\rho^2}\\dfrac{\\partial^2 \\psi}{\\partial \\phi^2} + \\dfrac{\\partial^2 \\psi}{\\partial z^2} + k^2 \\psi = 0\n\\tag{6}\\]\n이 된다. 이 경우 \\(\\partial_\\rho \\partial_\\phi\\) 같은 변수가 섞인 편미분항이 없기 때문에 변수분리법을 시도해 볼 수 있다.\n\\[\n\\psi (\\rho,\\, \\phi,\\, z) = P(\\rho)\\Phi (\\phi) Z(z)\n\\]\n라고 하자. 이 경우 식 6 은\n\\[\n\\dfrac{\\Phi Z}{\\rho} \\dfrac{d}{d\\rho} \\left(\\rho \\dfrac{dP}{d\\rho}\\right) + \\dfrac{PZ}{\\rho^2} \\dfrac{d^2\\Phi}{d\\phi^2} + P\\Phi \\dfrac{d^2Z}{dz^2} + k^2 P \\Phi Z = 0\n\\]\n이 된다. 이 식은 \\[\n\\dfrac{1}{Z(z)} \\dfrac{d^2Z(z)}{dz^2} = - \\dfrac{1}{\\rho P(\\rho)} \\dfrac{d}{d\\rho} \\left(\\rho \\dfrac{dP(\\rho)}{d\\rho}\\right) - \\dfrac{1}{\\rho^2 \\Phi(\\phi)} \\dfrac{d^2\\Phi(\\phi)}{d\\phi^2} -k^2\n\\]\n이며, 좌변은 \\(z\\) 의 함수, 우변은 \\(\\rho,\\, \\phi\\) 의 함수이므로 상수 일 수 밖에 없다. 이 값을 \\(l^2\\) 라고 하면,\n\\[\n\\dfrac{d^2Z}{dz^2}= l^2 Z(z)\n\\tag{7}\\]\n이다. 또한\n\\[\n\\dfrac{1}{\\rho P(\\rho)} \\dfrac{d}{d\\rho} \\left(\\rho \\dfrac{dP(\\rho)}{d\\rho}\\right) + \\dfrac{1}{\\rho^2 \\Phi(\\phi)} \\dfrac{d^2\\Phi(\\phi)}{d\\phi^2} +k^2 = -l^2\n\\]\n로부터 \\(n^2 = k^2+l^2\\) 로 놓고 \\(\\rho^2\\) 를 곱하면,\n\\[\n\\dfrac{\\rho}{P(\\rho)}\\dfrac{d}{d\\rho} \\left(\\rho \\dfrac{dP(\\rho)}{d\\rho}\\right) + n^2\\rho^2 = - \\dfrac{1}{\\Phi (\\phi)}\\dfrac{d^2 \\Phi (\\phi)}{d\\phi^2}\n\\]\n이 되며, 역시 \\(m^2\\) 로 놓으면,\n\\[\n\\dfrac{d^2\\Phi}{d\\phi^2} = -m^2 \\Phi (\\phi)\n\\tag{8}\\]\n와\n\\[\n\\rho\\dfrac{d}{d\\rho} \\left(\\rho \\dfrac{dP(\\rho)}{d\\rho}\\right) + (n^2\\rho^2 - m^2) P(\\rho) = 0\n\\tag{9}\\]\n을 얻는다. 이 때 각에 대한 식 8 의 해인 \\(\\Phi\\) 는 \\(\\sin m\\phi\\) 와 \\(\\cos m\\phi\\) 의 선형결합이며 식 9 를 만족하는 함수 \\(P(\\rho)\\) 는 베셀 함수",
    "crumbs": [
      "수치해석",
      "수학",
      "편미분 방정식"
    ]
  },
  {
    "objectID": "src/tools/Asymptote/asymptote.html",
    "href": "src/tools/Asymptote/asymptote.html",
    "title": "Asymptote",
    "section": "",
    "text": "1 Examples\nimport graph;\nimport geometry;\nimport math;\nimport settings;\nimport fontsize;\n\n\nsettings.outformat = \"pdf\";\ndefaultpen(fontsize(17pt));\ndefaultpen(1);\n\nsize(400,300,IgnoreAspect);\n\nreal a=1, b=1.5, c=2;\nreal ya=1.0, yb=2.4, yc=3.0;\nreal yb2=2.6, yb3=2.2;\nint t=2;\n\nreal f(real x) {\n    real r1=(x-b)*(x-c)/(a-b)/(a-c)*ya ;\n    r1 += (x-a)*(x-c)/(b-a)/(b-c)*yb;\n    r1 += (x-a)*(x-b)/(c-a)/(c-b)*yc;\n    return r1;\n    }\n\nreal f2(real x) {\n    real r1=(x-b)*(x-c)/(a-b)/(a-c)*ya ;\n    r1 += (x-a)*(x-c)/(b-a)/(b-c)*yb2;\n    r1 += (x-a)*(x-b)/(c-a)/(c-b)*yc;\n    return r1;\n    }\nreal f3(real x) {\n    real r1=(x-b)*(x-c)/(a-b)/(a-c)*ya ;\n    r1 += (x-a)*(x-c)/(b-a)/(b-c)*yb3;\n    r1 += (x-a)*(x-b)/(c-a)/(c-b)*yc;\n    return r1;\n    }\n\npair F(real x) {return (x,f(x));}\n\ndotfactor=7;\n\nxaxis(\"$t$\", xmin=0.5, xmax=2.5, Arrow, ticks=Ticks(DefaultFormat,\n                                        new real[] {1, 2}));\nyaxis(\"$P$\", XEquals(0.7), ymin=-0.2, ymax=4, Arrow);\n\npath g=graph(f,a,c);\npath g2=graph(f2,a,c);\npath g3=graph(f3,a,c);\n\ndraw(g,black);   \ndraw(g2,blue+dashed);  \ndraw(g3,dashed+red);  \n\nint n=2;\n\n\n\ndot(Label(\"$P_1$\",align=W), F(a));\ndot(Label(\"$P_2$\",align=E), F(c));\n\n\n\nEuler Lagrange",
    "crumbs": [
      "Tools",
      "Asymptote"
    ]
  },
  {
    "objectID": "src/tools/tikz/tikz_test.html",
    "href": "src/tools/tikz/tikz_test.html",
    "title": "tikz test",
    "section": "",
    "text": "코드\n```{r, engine = 'tikz'}\n#| label: fig-wavelet_haar_wavelet\n#| code-fold: true\n#| output: asis\n#| fig-width: 10\n#| fig-align: center\n#| fig-cap: \"Haar wavelet\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}[samples = 100, scale=2.5]\n\n\\draw[-{stealth}] (-0.5, 0) -- (1.7,0) node[right] {$t$};\n\\draw[-{stealth}] (0,-1.2) -- (0,1.2) node[above] {$\\psi_H(t)$};\n\n\\draw[very thick] (-0.5, 0) -- (0, 0) -- (0, 1) -- (0.5, 1) -- (0.5, -1) -- (1, -1)-- (1, 0) -- (1.5, 0);\n\\node[] at (0, 0) [below left] {$0$};\n\\node[] at (0.5, 0) [below left] {$1/2$};\n\\draw[] (-0.05, 1) -- (0.05, 1 ) node[right] {$1$};\n\n\\begin{scope}[xshift=4cm] \n\n\\draw[-{stealth}] (-1.2, 0) -- (1.2,0) node[right] {$\\omega$};\n\\draw[-{stealth}] (0,0) -- (0,1.2) node[above] {$\\hat{f}(\\omega)$};\n\n\\draw[color=black, thick, domain=-6:6, samples=100, variable = \\t]   plot ({\\t/5}, {1/(\\t*\\t + 1)});\n\\draw[] (-0.05, 1) -- (0.05, 1 ) node[right] {$2/a$};\n\\draw[] (-0.2, 0.05) -- (-0.2, -0.05 ) node[below] {$-\\frac{1}{a}$};\n\\draw[] (0.2, 0.05) -- (0.2, -0.05 ) node[below] {$\\frac{1}{a}$};\n\n\\end{scope}\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 1: Haar wavelet",
    "crumbs": [
      "Tools",
      "tikz test"
    ]
  },
  {
    "objectID": "src/image_processing/wavelet/fourier_transform.html",
    "href": "src/image_processing/wavelet/fourier_transform.html",
    "title": "푸리에 변환",
    "section": "",
    "text": "여기의 상당수 내용은 일반적인 학부 2학년 수준의 선형대수학, 해석학 범위를 넘어선 지식을 요구한다. 이런 내용은 증명하지 않고 언급하고 넘어가거나 사용할 수 있다.",
    "crumbs": [
      "영상 처리/토모그래피",
      "푸리에 변환과 웨이블릿 변환",
      "푸리에 변환"
    ]
  },
  {
    "objectID": "src/image_processing/wavelet/fourier_transform.html#수학적-기반",
    "href": "src/image_processing/wavelet/fourier_transform.html#수학적-기반",
    "title": "푸리에 변환",
    "section": "1 수학적 기반",
    "text": "1 수학적 기반\n\n1.1 \\(L^p\\) 공간 과 \\(L^1\\) 공간에서의 푸리에 변환\n\n\n\n\n\n\n\n정의 1 (\\(L^p\\)-노름 과 \\(L^p\\) 공간) \\(f:\\mathbb{R} \\to \\mathbb{C}\\) 와 \\(1\\le p &lt; \\infty\\) 인 \\(p\\) 에 대해\n\\[\n\\|f\\|_p = \\left[\\int_{-\\infty}^\\infty |f(t)|^p\\, dt\\,\\right]^{1/p} &lt;\\infty\n\\]\n를 \\(L^p\\)-노름 이라고 한다. \\(L^p\\) 노름이 정의된 함수의 집합을 \\(L^p\\)-공간 이라고 하며 \\(L^p\\) 혹은 \\(L^p(\\mathbb{R})\\) 로 쓴다.\n\n\n\n\n행렬과 벡터의 노름에서처럼 \\(p=1,\\,2,\\infty\\) 일 때 가장 중요하다. 또한 \\(L^p\\) 노름이 정의되는 함수의 집합은 벡터공간이다. \\(p=1\\) 일 때 \\(L^1\\) 노름이 정의되는 함수들을 Lebesgue 적분 가능 함수 라고 한다. 이제 \\(f\\in L^1(\\mathbb{R})\\) 이라고 하자. \\(e^{-i\\omega t}\\) 는 유계인 연속 함수이므로 \\(e^{-i \\omega t}f(t)\\) 는 모든 \\(\\omega \\in \\mathbb{R}\\) 에서 국소적으로 적분 가능한 함수(locally integrable function) 이다. 이 경우 아래와 같이 \\(L^1\\) 공간에서의 푸리에 변환을 정의 할 수 있다. \\(L^\\infty(\\mathbb{R})\\) 는 measure zero 인 집합을 제외하면 유계인 함수의 집합이다.\n\n\n\n\n\n\n\n\n정의 2 (\\(L^1(\\mathbb{R})\\) 에서의 푸리에 변환) \\(f\\in L^1(\\mathbb{R})\\) 에 대한 푸리에 변환 \\(\\hat{f}(\\omega)\\) 를 다음과 같이 정의 할 수 있다.\n\\[\n\\hat{f}(\\omega)= \\mathfrak{F}[f(t)] = \\int_{-\\infty}^\\infty e^{-i\\omega t}f(t)\\, dt.\n\\tag{1}\\]\n\n\n\n\n\n원래 함수 \\(f(t)\\) 는 실함수이더라도 \\(\\hat{f}(\\omega)\\) 는 실변수 \\(\\omega\\) 에 대한 복소함수이다. 복소수를 극좌표계에서 \\(x+iy=re^{i\\theta}\\), \\(r=\\sqrt{x^2+y^2}\\), \\(\\theta = \\arctan(y/x)\\) 로 표현하는 것처럼 \\(R(\\omega) = \\text{Re}[\\hat{f}(\\omega)]\\) ,\\(X(\\omega)= \\text{Im}[\\hat{f}(\\omega)]\\) 에 대해\n\\[\n\\hat{f}(\\omega)= R(\\omega)+ iX(\\omega)= A(\\omega) e^{i\\theta(\\omega)}\n\\]\n로 표현할 수 있으며 이 때 \\(A(\\omega)=\\left|\\hat{f}(\\omega)\\right|\\) 를 amplitude spectrum, \\(\\theta(\\omega)\\) 을 phase spectrum 이라고 한다.\n\n\n\n예제 1 (가우시안 함수의 푸리에 변환) 가우시안 함수 \\(f(t) = e^{-t^2/2\\sigma^2}\\) 에 대한 푸리에 변환 역시 가우시안이다.\n\\[\n\\begin{aligned}\n\\hat{f}(\\omega) = \\int_{-\\infty}^\\infty e^{-(i\\omega t + t^2/2\\sigma^2)}\\,dt = \\int_{-\\infty}^\\infty \\exp\\left(-\\dfrac{1}{2\\sigma^2}(t+i\\sigma^2\\omega)^2-\\dfrac{\\omega^2\\sigma^2}{2}\\right) = \\sqrt{2\\pi}\\sigma e^{-\\sigma^2 \\omega^2/2}\n\\end{aligned}\n\\]\n푸리에 변환에 의해 원래 함수의 표준편차 \\(\\sigma\\) 가 \\(1/\\sigma\\) 로 변화한다.\n\n\n\n\n\n예제 2 (직사각 함수의 푸리에 변환) \\[\nf(t) = \\left\\{\\begin{array}{ll} 1, \\qquad & |t|&lt; a \\\\ 0&\\text{otherwise}\\end{array}\\right. .\n\\]\n의 푸리에 변환은 다음과 같다.\n\\[\n\\begin{aligned}\n\\hat{f}(\\omega) = \\int_{-a}^a e^{-i\\omega t}\\, dt= \\left(\\dfrac{2}{\\omega}\\right) \\sin (a\\omega) = 2a\\,  \\text{sinc} (a\\omega)\n\\end{aligned}\n\\]\n이 때 \\(\\textrm{sinc}(x) := \\dfrac{\\sin x}{x}\\) 로 정의되는 함수이다. 기본적인 신호 를 참고하라. 실제로 \\(\\operatorname{sinc}\\) 는 \\(L^1(\\mathbb{R})\\) 함수가 아니다. 즉 \\(f\\in L^1(\\mathbb{R})\\) 이더라도 \\(\\hat{f}\\not\\in L^1(\\mathbb{R})\\) 일 수 있다.\n\n\n\n\n\n예제 3 기본적인 신호 함수들 의 Heaviside 계단함수 \\(\\text{step}(x)\\) 가 사용된 아래와 같은 함수를 생각하자.\n\\[\nf(t) = \\left(1-\\dfrac{|t|}{a}\\right) \\text{step}\\left( 1-\\dfrac{|t|}{a}\\right)\n\\]\n이 함수의 푸리에 변환은 다음과 같다.\n\\[\n\\hat{f}(\\omega)= a \\cdot \\dfrac{\\sin^2 \\left(\\dfrac{a\\omega}{2}\\right)}{\\left(\\dfrac{a\\omega}{2}\\right)^2}\n\\]\n\n\n\n함수의 푸리에 변환\n\n\n\n\n\n\n\n예제 4 \\(f(t) = e^{-a|t|},\\, (a&gt;0)\\) 의 푸리에 변환은 다음과 같다.\n\\[\n\\begin{aligned}\n\\hat{f}(\\omega) = \\mathfrak{F}\\left[ e^{-a|t|} \\right] &= \\int_{-\\infty}^0 e^{(a-i\\omega)t}\\, dt + \\int_0^\\infty e^{-(a+i\\omega)t}\\, dt = \\dfrac{2a}{\\omega^2+a^2}\n\\end{aligned}\n\\]\n\n\n\n\\(e^{-a|t|}\\) 함수의 푸리에 변환\n\n\n\n\n\n\n\n1.2 푸리에 변환의 수학적 성질\n다음은 푸리에 변환의 정의에 의헤 쉽게 증명 할 수 있다.\n\n명제 1 (푸리에 변환의 수학적 성질) \\(f(t),\\,g(t)\\in L^1(\\mathbb{R})\\), \\(a,\\,b\\in \\mathbb{C}\\) 이고 \\(\\hat{f}(\\omega) = \\mathfrak{F}[f(t)]\\), \\(\\hat{g}(t) = \\mathfrak{F}[g(t)]\\) 일 때 다음이 성립한다.\n  (\\(1\\)) (Linearity) \\(\\mathfrak{F}[af(t)+bg(t)] = a \\mathfrak{F}[f(t)] + b\\mathfrak{F}[g(t)]\\).\n  (\\(2\\)) (Shifting) \\(\\mathfrak{F}[f(t-a)] = e^{-ia\\omega}\\hat{f}(\\omega)\\).\n  (\\(3\\)) (Scaling) \\(\\mathfrak{F}[f(at)] =  \\dfrac{1}{a}\\hat{f}\\left(\\dfrac{\\omega}{a}\\right)\\).\n  (\\(4\\)) (Conjugation) \\(\\mathfrak{F}[\\overline{f(t)}] = \\hat{f}(-\\omega)\\).\n  (\\(5\\)) (Modulation) \\(\\mathfrak{F}[e^{ibt}f(t)] = \\hat{f}(\\omega - b)\\).\n  (\\(6\\)) (Continuity) \\(\\hat{f}(\\omega)\\) 는 연속이다.\n  (\\(7\\)) (Differentiation) \\(\\dfrac{d^n \\hat{f}(\\omega)}{d\\omega^n} = (-i)^n \\mathfrak{F}\\left[t^n f(t)\\right]\\)\n\n\n(증명). (\\(7\\)) 만 수학적 귀납법으로 증명한다. 우선 \\(n=1\\) 경우.\n\\[\n\\begin{aligned}\n\\dfrac{d\\hat{f}}{d\\omega} &= \\lim_{h \\to 0}\\dfrac{\\hat{f}(\\omega + h) - \\hat{f}(\\omega)}{h} = \\lim_{h \\to 0} \\int_{-\\infty}^\\infty f(t) e^{-i\\omega t}\\left(\\dfrac{e^{-iht}-1}{h}\\right)\\, dt \\\\\n&= \\int_{-\\infty}^\\infty (-it)f(t)e{-i\\omega t}\\, dt = -i \\mathfrak{F}[tf(t)].\n\\end{aligned}\n\\]\n이제 \\(n\\) 에 대해 성립함을 가정하자.\n\\[\n\\begin{aligned}\n\\dfrac{d^{n+1}\\hat{f}}{d\\omega^{n+1}}&= \\dfrac{d}{d\\omega}\\left((-i)^n\\mathfrak{F}[t^nf(t)]\\right) = (-i)^n \\dfrac{d}{d\\omega}\\mathfrak{F}[t^n f(t)] = (-i)^{n+1}\\mathfrak{F}[t^{n+1}f(t)]\n\\end{aligned}\n\\]\n이다. \\(\\square\\)\n\n\n\n정리 1 (리만-르벡 따름정리) \\(f\\in L^1(\\mathbb{R})\\) 일 때\n\\[\n\\lim_{|\\omega|\\to \\infty} \\left|\\hat{f}(\\omega)\\right| = 0\n\\]\n이다.\n\n\n(증명). \\(e^{-i\\omega t} = - e^{-i\\omega (t+\\pi/\\omega)}\\) 를 이용하면,\n\\[\n\\begin{aligned}\n\\hat{f}(\\omega) & = - \\int_{-\\infty}^\\infty e^{-i\\omega (t+\\pi/\\omega)} f(t) = - \\int_{-\\infty}^\\infty e^{-i \\omega x} f\\left(x-\\dfrac{\\pi}{\\omega}\\right)\\, dx \\\\\n\\end{aligned}\n\\]\n이다. 따라서,\n\\[\n\\begin{aligned}\n\\hat{f}(\\omega) &=  \\dfrac{1}{2}\\left[\\int_{-\\infty}^\\infty e^{-i\\omega t} f(t) \\, dt - \\int_{-\\infty}^\\infty e^{-i\\omega t} f\\left(t- \\dfrac{\\pi}{\\omega}\\right)\\, dt\\right] \\\\[0.5em]\n&= \\dfrac{1}{2} \\int_{-\\infty}^\\infty e^{-i\\omega t}\\left[f(t) - f\\left(t-\\dfrac{\\pi}{\\omega}\\right)\\right]\\, dt \\\\[0.5em]\n\\end{aligned}\n\\]\n이다. 이로부터\n\\[\n\\lim_{|\\omega|\\to \\infty} \\left|\\hat{f}(\\omega) \\right| \\le \\lim_{|\\omega|\\to 0}\\dfrac{1}{2} \\int_{-\\infty}^\\infty \\left| f(t) - f\\left (t-\\dfrac{\\pi}{\\omega}\\right)\\right|\\, dt = 0\n\\]\n임을 안다. \\(\\square\\)\n\n\n\\(C_0 (\\mathbb{R})\\) 은 \\(f:\\mathbb{R}\\to \\mathbb{C}\\) 함수 가운데 모든 \\(\\mathbb{R}\\) 에서 연속이며 \\(\\displaystyle \\lim_{|t|\\to \\infty} f(t) = 0\\) 인 함수의 집합이다. \\(C_0 (\\mathbb{R})\\) 에 대해 노름을\n\\[\n\\|f\\| := \\sup_{t\\in \\mathbb{R}} |f(t)|\n\\]\n로 정의 할 수 있으며, 따라서 \\(C_0 (\\mathbb{R})\\) 은 노름 공간이다. 정리 1 로부터 푸리에 변환은 \\(L^1(\\mathbb{R})\\) 에서 \\(C_0(\\mathbb{R})\\) 로의 선형 변환이라는 것을 알 수 있다.\n\n\n정리 2 (\\(n\\) 계 도함수의 푸리에 변환) \\(f(t)\\) 가 \\(C^1(\\mathbb{R})\\) 함수이고 \\(\\displaystyle \\lim_{|t|\\to\\infty} f(t) = 0\\) 이며 \\(f,\\,f'\\in L^1(\\mathbb{R})\\) 이면\n\\[\n\\mathfrak{F}[f'(t)] = (i\\omega) \\mathfrak{F}[f(t)]\n\\tag{2}\\]\n이 성립한다. 또한 \\(f\\in C^n(\\mathbb{R})\\) 이며 \\(f,\\,f',\\ldots,\\,f^{(n)}\\in L^1(\\mathbb{R})\\) 이고 \\(k=1,\\ldots,\\,n-1\\) 에 대해 \\(\\displaystyle \\lim_{|t|\\to \\infty} f^{(k)}(t) = 0\\) 이라면 다음이 성립한다.\n\\[\n\\mathfrak{F}\\left[f^{(n)}(t)\\right] = (i\\omega)^n \\mathfrak{F}[f(t)].\n\\tag{3}\\]\n\n\n(증명). 푸리에 변환의 정의로부터\n\\[\n\\mathfrak{F}[f'(t)] = \\int_{-\\infty}^\\infty e^{-i\\omega t}f'(t)\\, dt = \\left[e^{-i\\omega t} f(t)\\right]_{-\\infty}^{\\infty} +i\\omega \\int_{\\infty}^\\infty e^{i\\omega t}f(t)\\, dt = (i\\omega)\\mathfrak{F}[f(t)]\n\\]\n이다. \\(1,\\,2,\\ldots,\\,(n-1)\\)-계 도함수에 대해 식 3 이 성립한다고 가정하면\n\\[\n\\begin{aligned}\n\\mathfrak{F}[f^{(n)}(t)] &=(i\\omega)\\mathfrak{F}[f^{(n-1)}(t)] = (i\\omega)^n \\mathfrak{F}[f(t)]\n\\end{aligned}\n\\]\n이다. \\(\\square\\)\n\n\n곡선의 매끄러운 정도(smoothness) 는 그 곡선이 어떤 \\(C^n\\) 급 함수인지를 의미한다. 만약 \\(f^{(n)}\\in L^1(\\mathbb{R})\\) 이며 \\(\\displaystyle \\lim_{|t|\\to\\infty}f^{(n)}(t)=0\\) 이라면 리만 르벡 정리 에 따라 \\(\\displaystyle \\lim_{|\\omega|\\to\\infty} (i\\omega)^n \\mathfrak{F}[f(t)]=0\\) 이다. 즉 \\(f\\) 가 더 매끄러울 수록, 즉 \\(f\\in C^n\\) 에서 \\(n\\) 값이 클 수록 \\(\\mathfrak{F}[f(t)]\\) 는 \\(|\\omega| \\to \\infty\\) 극한에서 더 빨리 \\(0\\) 으로 수렴한다. 뒤에 나오겠지만 그 역도 마찬가지이다. \\(f\\in C^n(\\mathbb{R})\\) 은 함수의 전역적 성질이며 \\(\\displaystyle \\lim_{|\\omega|\\to\\infty}\\mathfrak{F}[f(t)] = 0\\) 은 국소적 성질이다. 함수의 전역적 성질이 그 푸리에 변환의 국소적 성질을 규정한다.",
    "crumbs": [
      "영상 처리/토모그래피",
      "푸리에 변환과 웨이블릿 변환",
      "푸리에 변환"
    ]
  },
  {
    "objectID": "src/image_processing/wavelet/fourier_transform.html#합성곱과-푸리에-변환",
    "href": "src/image_processing/wavelet/fourier_transform.html#합성곱과-푸리에-변환",
    "title": "푸리에 변환",
    "section": "2 합성곱과 푸리에 변환",
    "text": "2 합성곱과 푸리에 변환\n\n\n\n\n\n\n\n정의 3 (합성곱) \\(f,\\,g\\in L^1(\\mathbb{R})\\) 에 대해 두 함수의 합성곱 \\((f \\ast g)(t)\\) 는 다음과 같이 정의된다.\n\\[\n(f \\ast g)(t) := \\int_{-\\infty}^\\infty f(t-\\tau)\\,g(\\tau)\\, d\\tau\n\\tag{4}\\]\n\n\n\n\n\n\n명제 2 정의 3 에서의 \\((f\\ast g)\\in L^1(\\mathbb{R})\\) 이다.\n\n\n(증명). \\[\n\\int_{-\\infty}^\\infty \\int_{-\\infty}^\\infty |f(t-\\tau)\\, g(\\tau)| \\, d\\tau\\, dt                                                                                                                                                                                = \\int_{-\\infty}^\\infty g(\\tau)\\,d\\tau\\, \\int_{-\\infty}^\\infty |f(t)|\\,dt = \\|g\\|_1 \\|f\\|_1. \\qquad \\square\n\\]\n\n\n\n명제 3 \\(f,\\,g,\\,h \\in L^1(\\mathbb{R})\\) 에 대해 다음이 성립한다.\n  (\\(1\\)) \\(f \\ast g= g \\ast f\\).\n  (\\(2\\)) \\(f\\ast (g \\ast h)= (f \\ast g)\\ast h\\).\n  (\\(3\\)) \\(f \\ast (g + h) = f\\ast g + f \\ast h\\).\n\n\n(증명). (\\(1\\)) \\(\\displaystyle (f\\ast g)(t) = \\int_{-\\infty}^\\infty f(t-\\tau)g(\\tau) \\, d\\tau \\stackrel{s=t-\\tau}{=} \\int_{-\\infty}^\\infty f(s)\\, g(t-s)\\, ds = (g\\ast f)(t).\\)\n(\\(2\\))\n\\[\n\\begin{aligned}\n\\left[f\\ast (g \\ast h)\\right](t)&= \\int_{-\\infty}^\\infty f(t-\\tau) \\left[\\int_{-\\infty}^{\\infty} g(\\tau - s)\\, h (s)\\, ds\\right]\\, d\\tau \\\\\n&=\\int_{-\\infty}^\\infty \\left[\\int_{-\\infty}^\\infty f(t-\\tau) \\,g(\\tau-s) \\, d\\tau \\right] h(s)\\, ds \\\\\n&\\stackrel{x=\\tau-s}{=} \\int_{-\\infty}^\\infty \\left[\\int_{-\\infty}^\\infty f((t-s)-x))\\, g(x)\\, dx\\right] h(s)\\, ds\\\\\n&= \\int_{-\\infty}^\\infty (f \\ast g)(t-s)\\, h(s)\\,ds \\\\\n&= (f \\ast g)\\ast h (t).\n\\end{aligned}\n\\]\n(\\(3\\)) trivial. \\(\\square\\)\n\n\n아래의 두 명제는 증명 없이 받아들인다.\n\n명제 4 \\(f\\in L^1(\\mathbb{R})\\) 이고 \\(g\\in L^\\infty(\\mathbb{R})\\) 이면 \\(f\\ast g\\) 는 \\(\\mathbb{R}\\) 에서 연속이다.\n\n\n\n명제 5 양수 \\(p,\\,q,\\,s\\) 가 \\(\\dfrac{1}{s} = \\dfrac{1}{p} + \\dfrac{1}{q} -1\\) 일 때 다음이 성립한다.\n\\[\n\\|f\\ast g\\|_s \\le \\|f\\|_p \\|g\\|_q\n\\]\n\n\n\n정리 3 (Convolution theorem) \\(f,\\,g\\in L^1(\\mathbb{R})\\) 일 때 다음이 성립한다.\n\\[\n\\mathfrak{F}[(f \\ast g)(t)] = \\mathfrak{F}[f(t)]\\mathfrak{F}[g(t)].\n\\]\n\n\n(증명). \\[\n\\begin{aligned}\n\\mathfrak{F}[(f \\ast g)(t)] &= \\int_{-\\infty}^\\infty e^{-i \\omega t} \\int_{-\\infty}^\\infty f(t-\\tau)\\, g(\\tau)\\, d\\tau\\, dt \\\\\n&= \\int_{-\\infty}^\\infty\\left[ \\int_{-\\infty}^\\infty e^{-i\\omega (t-\\tau)} f(t-\\tau) \\, dt\\right] e^{-i \\omega \\tau}g(\\tau)\\, d\\tau \\\\\n&= \\int_{-\\infty}^\\infty \\mathfrak{F}[f(t)] \\, e^{-i \\omega \\tau} g(\\tau)\\, d\\tau\\\\\n&= \\mathfrak{F}[f(t)]\\mathfrak{F}[g(t)].\n\\end{aligned}\n\\]\n\n위의 정리는 합성곱의 푸리에 변환은 각 함수의 푸리에 변환의 곱과 같다는 의미이다.\n\n\n따름정리 1 \\(f,\\,g,\\,h\\in L^1(\\mathbb{R})\\) 이며\n\\[\nh(x) = \\int_{-\\infty}^\\infty g(\\omega)\\, e^{i\\omega x}\\, d\\omega\n\\]\n일 때 다음이 성립한다.\n\\[\n(f\\ast h)(x) = \\int_{-\\infty}^\\infty g(\\omega)\\, \\hat{f}(\\omega) \\, e^{i\\omega x}\\, d\\omega.\n\\]\n\n\n(증명). \\[\n\\begin{aligned}\n(f\\ast h)(x) &= \\int_{-\\infty}^\\infty f(x-\\tau) h(\\tau)\\, d\\tau = \\int_{-\\infty}^\\infty f(x-\\tau) \\left[\\int_{-\\infty}^\\infty g(\\omega)\\, e^{i\\omega \\tau}\\, d\\omega\\right]\\, d\\tau \\\\\n&= \\int_{-\\infty}^\\infty g(\\omega) \\left[\\int_{-\\infty}^\\infty f(x-\\tau) e^{i\\omega \\tau} \\, d\\tau\\right] \\, d\\omega\\\\\n&=\\int_{-\\infty}^\\infty g(\\omega) \\left[\\int_{-\\infty}^\\infty f(x-\\tau) e^{-i\\omega (x-\\tau)} \\, d\\tau\\right] \\, e^{i\\omega x} d\\omega\\\\\n&= \\int_{-\\infty}^\\infty g(\\omega) \\hat{f}(\\omega) e^{i\\omega x}\\, d\\omega, \\qquad \\square\n\\end{aligned}\n\\]",
    "crumbs": [
      "영상 처리/토모그래피",
      "푸리에 변환과 웨이블릿 변환",
      "푸리에 변환"
    ]
  },
  {
    "objectID": "src/image_processing/wavelet/fourier_transform.html#역-푸리에-변환-문제",
    "href": "src/image_processing/wavelet/fourier_transform.html#역-푸리에-변환-문제",
    "title": "푸리에 변환",
    "section": "3 역 푸리에 변환 문제",
    "text": "3 역 푸리에 변환 문제\n우리는 \\(f \\in L^1(\\mathbb{R})\\) 에 대한 푸리에 변환을 알아보았다. 이제 그 역변환, 즉 어떤 frequency domain 에서의 함수 \\(\\hat{f}(\\omega)\\) 로 부터 원함수 \\(f(t)\\) 를 어떤 조건에서 구할 수 있는지 알아보기로 하자.\n\n정리 4 (푸리에 역변환) \\(f\\in L^1(\\mathbb{R})\\) 이고 \\(\\hat{f}=\\mathfrak{F}[f(t)]\\in L^1(\\mathbb{R})\\) 일 때\n\\[\n\\dfrac{1}{2\\pi}\\int_{-\\infty}^\\infty \\hat{f}(\\omega) e^{i\\omega t}\\, d\\omega = f(t)\n\\tag{5}\\]\n이다.\n\n\n(증명). \\[\n\\begin{aligned}\n\\dfrac{1}{2\\pi} \\int_{-\\infty}^\\infty \\hat{f}(\\omega)e^{i\\omega t}\\, d\\omega &= \\dfrac{1}{2\\pi} \\int_{-\\infty}^\\infty \\left[\\int_{-\\infty}^\\infty f(t')e^{-i\\omega t'}\\, dt'\\right] e^{i\\omega t}\\, d\\omega \\\\\n&= \\dfrac{1}{2\\pi} \\int_{-\\infty}^\\infty \\left[\\int_{-\\infty}^\\infty e^{i\\omega (t-t')}\\, d\\omega\\right] \\, f(t')\\, dt'\n\\end{aligned}\n\\]\n여기서 \\(\\int_\\mathbb{R} e^{i\\omega t}\\, d\\omega = 2\\pi \\delta(t)\\) 이므로\n\\[\n\\dfrac{1}{2\\pi} \\int_{-\\infty}^\\infty \\hat{f}(\\omega)e^{i\\omega t}\\, d\\omega = \\int_{-\\infty}^\\infty f'(t) \\delta(t-t')\\, dt' = f(t)\n\\]\n이다. \\(\\square\\)\n\n그러나 예제 2 에서 보았듯이 \\(f\\in L^1(\\mathbb{R})\\) 이더라도 \\(f\\not\\in L^1(\\mathbb{R})\\) 일 수 있다. 여기에 어떤 함수 \\(K_\\lambda(\\omega)\\) 를 도입하여 대부분의 \\(t\\in \\mathbb{R}\\) 에 대해 다음이 성립할 수 있도록 할 수 있음을 보이고자 한다.\n\\[\n\\lim_{\\lambda\\to \\infty} \\int_{-\\lambda}^\\lambda \\hat{f}(\\omega)K_\\lambda (\\omega)e^{i\\omega t}\\, dt = f(t).\n\\]\n이 때 \\(K_\\lambda(\\omega)\\) 를 summability kernel 이라고 한다.\n\n\n\n\n\n\n\n\n정의 4 (Summability kernel) \\(\\mathbb{R}\\) 에서의 summability kernel 은 아래의 조건을 만족하는 연속함수 \\(K_\\lambda :\\mathbb{R} \\to \\mathbb{C}\\) 의 집합 이다.\n  (\\(1\\)) \\(\\forall \\lambda &gt; 0,\\, \\displaystyle \\int_\\mathbb{R} K_\\lambda (x)\\, dx = 1\\).\n  (\\(2\\)) \\(\\exists M&gt;0,\\forall \\lambda &gt;0\\,\\, \\displaystyle \\|K_\\lambda\\|_1=\\int_{\\mathbb{R}} |K_\\lambda(x)|\\, dx \\le M\\).\n  (\\(3\\)) \\(\\forall \\delta &gt;0,\\, \\displaystyle \\lim_{\\lambda \\to \\infty} \\int_{|x|&gt;\\delta} |K_\\lambda(x)| \\, dx = 0\\).\n\n\n\n\n\n\n정리 5 \\(f\\in L^{1}(\\mathbb{R})\\) 이며 \\(\\{K_\\lambda\\}\\) 가 summability kernel 의 집합일 때 다음이 성립한다.\n\\[\n\\lim_{\\lambda \\to \\infty} \\|(f\\ast K_\\lambda)- f\\| = 0.\n\\tag{6}\\]\n\n\n(증명). \\[\n\\begin{aligned}\n\\left|(f\\ast K_\\lambda) (t)- f(t)\\right| &= \\left|\\int_{-\\infty}^\\infty f(t-\\tau)\\, K_\\lambda(\\tau)\\, d\\tau - \\int_{-\\infty}^\\infty K_\\lambda(\\tau)f(t)\\, d\\tau\\right| & &;\\text{정의 ($1$)}\\\\\n&=\\left|\\int_{-\\infty}^\\infty \\left(f(t-\\tau) - f(t)\\right)K_\\lambda (\\tau)\\, d\\tau\\right| \\\\\n&\\le \\int_{-\\infty}^\\infty |K_\\lambda(\\tau) |f(t-\\tau)-f(t)|\\, d\\tau\n\\end{aligned}\n\\]\n정의 (\\(2\\)) 에서 \\(\\|K_\\lambda\\|_1 \\le M\\) 이라고 하자. \\(f\\in L^p(\\mathbb{R})\\) 일 때 \\(f(t-\\tau)- f(t)\\) 는 연속이므로 모든 \\(\\varepsilon&gt;0\\) 에 대해 어떤 \\(\\delta&gt;0\\) 이 존재하여 \\(|\\tau|&lt;\\delta\\) 이면 \\(|f(t-\\tau)-f(t)|&lt;\\dfrac{\\varepsilon}{M}\\) 이 되도록 할 수 있다. 따라서\n\\[\n\\begin{aligned}\n\\|(f\\ast K_\\lambda) (t) - f(t)\\| &= \\int_{-\\infty}^\\infty |(f\\ast K_\\lambda)(t) - f(t)|\\, dt \\\\\n&\\le\\int_{-\\infty}^\\infty dt \\int_{-\\infty}^\\infty |K_\\lambda(\\tau)| |f(t-\\tau) - f(t)|\\, d\\tau \\\\\n\\end{aligned}\n\\]\n이 때\n\\[\n\\sigma(\\tau) := \\int_{-\\infty}^\\infty |f(t-\\tau)-f(t)|\\, dt\n\\]\n라고 하면, \\(\\sigma(\\tau) = C &lt;\\infty\\) 이다.\n\\[\n\\begin{aligned}\n\\|(f\\ast K_\\lambda) (t) - f(t)\\| & \\le \\int_{-\\infty}^\\infty |K_\\lambda (\\tau)|\\sigma(\\tau)\\, d\\tau\\\\\n&= \\int_{|\\tau|&lt;\\delta} |K_\\lambda(\\tau)| \\sigma(\\tau)\\, d\\tau + \\int_{|\\tau|&gt; \\delta}  |K_\\lambda(\\tau)| \\sigma(\\tau)\\, d\\tau \\\\\n&\\le \\varepsilon + C\\int_{-\\infty}^\\infty |K_\\lambda (\\tau)|d\\tau\n\\end{aligned}\n\\]\n이므로 식 6 이 성립한다. \\(\\square\\)\n\n\n\n정리 6 \\(\\hat{f}=\\mathfrak{F}[f(t)],\\, \\hat{g}=\\mathfrak{F}[g(t)]\\) 이며 \\(\\hat{f},\\, \\hat{g}\\in L^1(\\mathbb{R})\\) 일 때 다음이 성립한다.\n\\[\n\\mathfrak{F}[f(t)\\,g(t)]= \\dfrac{1}{2\\pi}\\left(\\hat{f} \\ast \\hat{g}\\right).\n\\tag{7}\\]\n\n\n(증명). \\(\\hat{f},\\,\\hat{g}\\in L^1(\\mathbb{R})\\) 이므로 역변환이 가능하다. 정리 4 을 이용한다.\n\\[\\begin{aligned}\n\\mathfrak{F}[f(t)\\,g(t)](\\omega) &=\\int_{-\\infty}^\\infty e^{-i\\omega t} f(t)\\, g(t)\\, dt= \\dfrac{1}{2\\pi}\\int_{-\\infty}^\\infty e^{-i \\omega t}g(t)\\, dt \\int_{-\\infty}^\\infty \\hat{f}(\\omega') e^{i\\omega' t}d\\omega' \\\\\n&= \\dfrac{1}{2\\pi}\\int_{-\\infty}^\\infty \\hat{f}(\\omega') \\left[\\int_{-\\infty}^\\infty g(t)\\,e^{-i(\\omega-\\omega')t}\\, dt\\right]\\, d\\omega' \\\\\n&= \\dfrac{1}{2\\pi}\\int_{-\\infty}^\\infty \\hat{f}(\\omega') \\hat{g}(\\omega-\\omega')\\, d\\omega' = \\dfrac{1}{2\\pi} (\\hat{f} \\ast \\hat{g})(\\omega),\\qquad \\square\n\\end{aligned}\\]",
    "crumbs": [
      "영상 처리/토모그래피",
      "푸리에 변환과 웨이블릿 변환",
      "푸리에 변환"
    ]
  },
  {
    "objectID": "src/image_processing/wavelet/fourier_transform.html#l2mathbbr-에서의-푸리에-변환",
    "href": "src/image_processing/wavelet/fourier_transform.html#l2mathbbr-에서의-푸리에-변환",
    "title": "푸리에 변환",
    "section": "4 \\(L^2(\\mathbb{R})\\) 에서의 푸리에 변환",
    "text": "4 \\(L^2(\\mathbb{R})\\) 에서의 푸리에 변환\n\\(L^2\\) 공간에서의 노름 \\(\\|\\cdot\\|_2\\) 은 다음과 같이 정의된다.\n\\[\n\\|f\\|_2 := \\left(\\int_{-\\infty}^\\infty |f(t)|^2\\, dt\\right)^{1/2}\n\\]\n\\(f\\in L^2(\\mathbb{R})\\) 일 때 \\(\\left\\|\\hat{f}\\right\\|_2 = \\sqrt{2\\pi}\\|f\\|_2\\) 이다. \\(\\sqrt{2\\pi}\\) factor 를 안보이게 하기 위해 푸리에 변환을 다음과 같이 재정의 한다.\n\\[\n\\hat{f}(\\omega):= \\mathfrak{F}[f(t)]=\\dfrac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^\\infty e^{-i\\omega t}\\, f(t)\\, dt\n\\tag{8}\\]\n\n\n정리 7 \\(f\\in C_{\\mathbb{R}}\\) 이며 어떤 유계인 구간 밖에서 \\(0\\) 값을 갖는다고 하자. 그렇다면 \\(\\hat{f}=\\mathfrak{F}[f(t)]\\in L^2(\\mathbb{R})\\) 이며\n\\[\n\\|f\\|_2 = \\left\\|\\hat{f}\\right\\|_2\n\\]\n이다.\n\n\n(증명). 일반성을 잃지 않고 \\(t\\not\\in [-\\pi,\\,\\pi]\\) 일 때 \\(f(t)=0\\) 이라고 할 수 있다. 아래의 \\(\\{\\phi_n(t)\\}\\) 는 \\(L^2(\\mathbb{R})\\) 의 정규직교기저이다.\n\\[\n\\left\\{\\phi_n(t)=\\dfrac{1}{\\sqrt{2\\pi}} e^{int}: n\\in \\mathbb{Z}\\right\\}.\n\\]\n따라서,\n\\[\nf(t) = \\sum_{n\\in \\mathbb{Z}}f_n e^{int},\\qquad \\text{where}\\; f_n = \\int \\overline{\\phi_n(t)} f(t)\\, dt = \\dfrac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}  ^\\infty e^{-int}f(t)\\,dt = \\hat{f}(n)\n\\]\n이며,\n\\[\n{\\|f\\|_2}^2 = \\sum_{n\\in \\mathbb{Z}} |\\hat{f}(n)|^2\n\\]\n이다. \\(g(t) = e^{i\\mu t}f(t)\\) 에 대해 \\(|g(t)|=|f(t)|\\) 이므로 \\(\\|g\\|_2 = \\|f\\|_2\\) 이다. 또한 \\(\\displaystyle g(t) = \\sum_{n\\in \\mathbb{Z}}f_n e^{i(n+\\mu)t}\\) 이므로\n\\[\n{\\|f\\|_2}^2 =\\sum_{n\\in \\mathbb{Z}} \\left|\\hat{f}(n+\\mu)\\right|^2\n\\]\n이다. 위 식의 양 변을 \\(\\mu\\) 에 대해 \\([0,\\,1]\\) 구간에서 적분하면\n\\[\n{\\|f\\|_2}^2 = \\sum_{n\\in \\mathbb{Z}}\\int_0^1 \\left|\\hat{f}(n+\\mu)\\right|^2 \\, d\\mu = \\int_{-\\infty}^\\infty \\left|\\hat{f}(\\mu)\\right|^2\\, d\\mu = {\\left\\|\\hat{f}\\right\\|_2}^2\n\\]\n이다. \\(\\square\\)\n\n\n정리 7 은 \\(f\\in L^2(\\mathbb{R}) \\iff\\hat{f}\\in L^2(\\mathbb{R})\\) 를 의미한다. \\(f\\in L^1(\\mathbb{R})\\) 일 경우에는 이것이 성립하지 않았음을 생각하라(예제 2).\n\n\n\n\n\n\n\n\n정의 5 (콤팩트 지지 함수) 위상공간 \\(X\\) 에서 정의된 \\(f:X \\to \\mathbb{R}\\) 에 대해 \\(S=f^{-1}(\\{0\\})\\) 의 closure \\(\\overline{S}\\) 를 \\(f\\) 에 대한 support 라고 하고 \\(\\textrm{supp}(f)\\) 라고 쓴다. \\(\\textrm{supp}(f)\\) 가 옹골집합(compact set) 일 때 \\(f\\) 를 콤팩트 지지 함수 (compactly supported function) 라고 한다.\n\n\n\n\n\\(\\mathbb{R}\\) 에서의 옹골집합은 유계인 닫힌 집합과 동치이다. 즉 \\(\\mathbb{R}\\) 에서의 콤팩트 지지함수는 support 가 유계인 집합이다. 그렇다면 \\(f\\) 가 \\(L^2(\\mathbb{R})\\) 에서의 콤팩트 지지함수라면 정리 7 에 따라 푸리에 변환이 존재하며 \\(\\|f\\|_2 = \\left\\|\\hat{f}\\right\\|_2\\) 이다.\n또 한가지 사실은 \\(\\mathbb{R}\\) 에서 정의된 모든 컴팩트 지지함수의 집합은 \\(L^2(\\mathbb{R})\\) 에서 조밀하다는 것이다(이것은 증명하지 않고 받아들이기로 하자). 즉 \\(f\\in L^2(\\mathbb{R})\\) 라면 임의의 \\(\\varepsilon&gt;0\\) 에 대해 \\(\\|f-g\\|_2&lt;\\varepsilon\\) 인 콤팩트 지지함수 \\(g\\in L^2(\\mathbb{R})\\) 을 찾을 수 있다는 의미이다. 그런 의미에서 푸리에 변환을 다음과 같이 정의 할 수 있다.\n\n\n\n\n\n\n\n\n정의 6 (\\(L^2(\\mathbb{R})\\) 에서의 푸리에 변환) \\(f\\in L^2(\\mathbb{R})\\) 이며 \\(\\{f_n : f_n\\in L^2(\\mathbb{R})\\}\\) 을 \\(\\displaystyle \\lim_{n \\to \\infty}f_n = f\\) 인 콤팩트 지지함수의 함수열이라고 하자. 이 때 \\(f\\) 의 푸리에 변환은 다음과 같이 정의된다.\n\\[\n\\hat{f} = \\lim_{n \\to \\infty} \\mathfrak{F}[f_n]\n\\]\n\n\n\n\n\\(f_n\\) 이 콤팩트 지지함수이므로 정리 7 에 따라 \\(\\|\\hat{f}_n\\|_2\\) 가 존재하며 그 극한이 \\(f\\) 의 푸리에 변환이다. 그렇다면 이 정의는 우리가 \\(L^1(\\mathbb{R})\\) 에서 했던 정의와 동일할까?\n\n정리 8 (Parseval’s Identity) \\(f\\in L^2(\\mathbb{R})\\) 이면 \\(\\|f\\|_2 = \\left\\|\\hat{f}\\right\\|_2\\) 이다.\n\n\n(증명). \n\n\n\n정리 9 \\(f\\in L_2(\\mathbb{R})\\) 일 때\n\\[\n\\hat{f}(\\omega)= \\lim_{n \\to \\infty} \\dfrac{1}{\\sqrt{2\\pi}} \\int_{-n}^n e^{-i\\omega t}f(t)\\, dt\n\\]\n이다.\n\n\n(증명). \\(n\\in \\mathbb{Z}_+\\) 에 대해 \\(f_n(t)\\) 를 아래와 같이 정의한다.\n\\[\nf_n (t) = \\left\\{\\begin{array}{ll} f(t), \\qquad &\\text{for }|t|&lt;n, \\\\ 0&\\text{otherwise}.\\end{array}\\right.\n\\]\n\\(\\displaystyle \\lim_{n \\to \\infty} \\|f-f_n\\|_2=0\\) 이며, 따라서 \\(\\displaystyle \\lim_{n \\to \\infty}\\|\\hat{f} - \\hat{f}_n\\|_2 = 0\\) 이다. \\(\\square\\)",
    "crumbs": [
      "영상 처리/토모그래피",
      "푸리에 변환과 웨이블릿 변환",
      "푸리에 변환"
    ]
  },
  {
    "objectID": "src/tools/tikz/tikz_wavelet.html",
    "href": "src/tools/tikz/tikz_wavelet.html",
    "title": "tikz Wavelet",
    "section": "",
    "text": "코드\n```{r, engine = 'tikz'}\n#| label: fig-wavelet_sharp_function_1\n#| code-fold: true\n#| output: asis\n#| fig-width: 10\n#| fig-align: center\n#| fig-cap: \"Legendre 다항식\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}[samples = 100, scale=2]\n\n\\draw[-{stealth}] (-1.5, 0) -- (1.5,0) node[right] {$t$};\n\\draw[-{stealth}] (0,0) -- (0,1.2) node[above] {$f(t)$};\n\n\\draw[color=black, thick, domain=-1:0, variable = \\t]   plot ({\\t}, {(1+\\t)});\n\\draw[color=black, thick, domain=0:1, variable = \\t]   plot ({\\t}, {(1-\\t)});\n\\draw[] (-1, 0.05) -- (-1, -0.05 ) node[below] {$-a$};\n\\draw[] (1, 0.05) -- (1, -0.05 ) node[below] {$a$};\n\n\\begin{scope}[xshift=3.5cm] \n\n\\draw[-{stealth}] (-1.5, 0) -- (1.5,0) node[right] {$\\omega$};\n\\draw[-{stealth}] (0,0) -- (0,1.2) node[above] {$\\hat{f}(\\omega)$};\n\n\\draw[color=black, thick, domain=-6:6, samples=100, variable = \\t]   plot ({\\t/5}, { (2 * sin((\\t * 180 / pi) /2)/((\\t)))^2 });\n\\draw[] (-0.2, 0.05) -- (-0.2, -0.05 ) node[below] {$-\\frac{1}{a}$};\n\\draw[] (0.2, 0.05) -- (0.2, -0.05 ) node[below] {$\\frac{1}{a}$};\n\n\\end{scope}\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 1: Legendre 다항식\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-wavelet_sharp_function_2\n#| code-fold: true\n#| output: asis\n#| fig-width: 10\n#| fig-align: center\n#| fig-cap: \"Legendre 다항식\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}[samples = 100, scale=2.5]\n\n\\draw[-{stealth}] (-1.2, 0) -- (1.22,0) node[right] {$t$};\n\\draw[-{stealth}] (0,0) -- (0,1.2) node[above] {$f(t)$};\n\n\\draw[color=black, thick, domain=-6:0, variable = \\t]   plot ({\\t/5}, {exp(\\t)});\n\\draw[color=black, thick, domain=0:6, variable = \\t]   plot ({\\t/5}, {exp(-\\t)});\n\\draw[] (-1, 0.05) -- (-1, -0.05 ) node[below] {$-5a$};\n\\draw[] (1, 0.05) -- (1, -0.05 ) node[below] {$5a$};\n\\draw[] (-0.05, 1) -- (0.05, 1 ) node[right] {$1$};\n\n\\begin{scope}[xshift=2.8cm] \n\n\\draw[-{stealth}] (-1.2, 0) -- (1.2,0) node[right] {$\\omega$};\n\\draw[-{stealth}] (0,0) -- (0,1.2) node[above] {$\\hat{f}(\\omega)$};\n\n\\draw[color=black, thick, domain=-6:6, samples=100, variable = \\t]   plot ({\\t/5}, {1/(\\t*\\t + 1)});\n\\draw[] (-0.05, 1) -- (0.05, 1 ) node[right] {$2/a$};\n\\draw[] (-0.2, 0.05) -- (-0.2, -0.05 ) node[below] {$-\\frac{1}{a}$};\n\\draw[] (0.2, 0.05) -- (0.2, -0.05 ) node[below] {$\\frac{1}{a}$};\n\n\\end{scope}\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 2: Legendre 다항식\n\n\n\n\n\n\n코드\n```{r, engine = 'tikz'}\n#| label: fig-wavelet_haar_wavelet\n#| code-fold: true\n#| output: asis\n#| fig-width: 10\n#| fig-align: center\n#| fig-cap: \"Haar wavelet\"\n\n\\usetikzlibrary{arrows}\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{calc}\n\\usetikzlibrary{arrows}\n\n\\begin{tikzpicture}[samples = 100, scale=2.5]\n\n\\draw[-{stealth}] (-0.5, 0) -- (1.7,0) node[right] {$t$};\n\\draw[-{stealth}] (0,-1.2) -- (0,1.2) node[above] {$\\psi_H(t)$};\n\n\\draw[very thick] (-0.5, 0) -- (0, 0) -- (0, 1) -- (0.5, 1) -- (0.5, -1) -- (1, -1)-- (1, 0) -- (1.5, 0);\n\\node[] at (0, 0) [below left] {$0$};\n\\node[] at (0.5, 0) [below left] {$\\frac{1}{2}$};\n\\node[] at (1, 0) [below left] {$1$};\n\\draw[] (0.1, 1) -- (-0.1, 1) node[left] {$1$};\n\\node[] at (0, -1) [left] {$-1$};\n\n\\begin{scope}[xshift=3.3cm] \n\n\\draw[-{stealth}] (-1.2, -1) -- (1.2,-1) node[right] {$\\omega$};\n\\draw[-{stealth}] (0,-1.0) -- (0,1.2) node[above] {$|\\hat{\\psi}_H(\\omega)|$};\n\n\\draw[color=black, very thick, domain=0.01:40, samples=100, variable = \\t]   plot ({\\t/40}, {(2*(sin(\\t*180/pi/4))*(sin(\\t*180/pi/4)) / (\\t/4)-1)});\n\\draw[color=black, very thick, domain=-40:-0.01, samples=100, variable = \\t]   plot ({\\t/40}, {(-2*(sin(\\t*180/pi/4))*(sin(\\t*180/pi/4)) / (\\t/4)-1)});\n\\draw[] (0.0, -0.96) -- (0.0, -1.04 ) node[below] {$0$};\n\\draw[] (0.314, -0.96) -- (0.314, -1.04 ) node[below] {$4\\pi$};\n\\draw[] (0.628, -0.96) -- (0.628, -1.04 ) node[below] {$8\\pi$};\n\\draw[] (0.942, -0.96) -- (0.942, -1.04 ) node[below] {$12\\pi$};\n\n\\end{scope}\n\n\\end{tikzpicture}\n```\n\n\n\n\n\n\n\n그림 3: Haar wavelet",
    "crumbs": [
      "Tools",
      "tikz Wavelet"
    ]
  }
]